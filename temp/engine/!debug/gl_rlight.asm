; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_rlight.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_CL_RunLightStyles
PUBLIC	_R_PushDlights
PUBLIC	_R_MarkLights
PUBLIC	_R_LightVec
PUBLIC	_R_CountSurfaceDlights
PUBLIC	_R_LightPoint
PUBLIC	_R_CountDlights
PUBLIC	_R_LightVecInternal
PUBLIC	__real@00000000
PUBLIC	__real@3c000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@41200000
PUBLIC	__real@41b00000
PUBLIC	__real@43000000
PUBLIC	__real@43800000
PUBLIC	__real@45000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_LightToTexGamma:PROC
EXTRN	_sqrt:PROC
EXTRN	_BoundsAndSphereIntersect:PROC
EXTRN	_Matrix3x4_VectorIRotate:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_GL_FrustumCullSphere:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_vec3_origin:BYTE
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_lightstyle_lerping:DWORD
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_cl_dlights:BYTE
EXTRN	_r_lighting_extended:DWORD
EXTRN	_r_lighting_modulate:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_g_trace_lightspot DD 03H DUP (?)
_g_trace_lightvec DD 03H DUP (?)
_g_trace_fraction DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c000000
CONST	SEGMENT
__real@3c000000 DD 03c000000r			; 0.0078125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	080cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	014dbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0b4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0edH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_LightVecInternal
_TEXT	SEGMENT
tv350 = -228						; size = 4
tv346 = -228						; size = 4
tv342 = -228						; size = 4
tv239 = -228						; size = 4
tv218 = -228						; size = 4
tv197 = -228						; size = 4
tv173 = -228						; size = 4
tv84 = -228						; size = 4
_ilength$1 = -160					; size = 4
_matrix$2 = -156					; size = 64
_pnodes$3 = -92						; size = 4
_end_l$4 = -88						; size = 12
_start_l$5 = -76					; size = 12
_offset$6 = -64						; size = 12
_pe$7 = -52						; size = 4
_cv$ = -48						; size = 16
_light$ = -32						; size = 16
_maxEnts$ = -16						; size = 4
_i$ = -12						; size = 4
_last_fraction$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_lspot$ = 20						; size = 4
_lvec$ = 24						; size = 4
_R_LightVecInternal PROC				; COMDAT

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 384  : 	float	last_fraction;
; 385  : 	int	i, maxEnts = 1;

	mov	DWORD PTR _maxEnts$[ebp], 1

; 386  : 	colorVec	light, cv;
; 387  : 
; 388  : 	if( lspot ) VectorClear( lspot );

	cmp	DWORD PTR _lspot$[ebp], 0
	je	SHORT $LN5@R_LightVec
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lspot$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _lspot$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lspot$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN5@R_LightVec:

; 389  : 	if( lvec ) VectorClear( lvec );

	cmp	DWORD PTR _lvec$[ebp], 0
	je	SHORT $LN6@R_LightVec
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lvec$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _lvec$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lvec$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN6@R_LightVec:

; 390  : 
; 391  : 	if( cl.worldmodel && cl.worldmodel->lightdata )

	cmp	DWORD PTR _cl+4579004, 0
	je	$LN7@R_LightVec
	mov	eax, DWORD PTR _cl+4579004
	cmp	DWORD PTR [eax+380], 0
	je	$LN7@R_LightVec

; 392  : 	{
; 393  : 		light.r = light.g = light.b = light.a = 0;

	mov	DWORD PTR _light$[ebp+12], 0
	mov	eax, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR _light$[ebp+8], eax
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR _light$[ebp+4], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR _light$[ebp], edx

; 394  : 		last_fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _last_fraction$[ebp], xmm0

; 395  : 
; 396  : 		// get light from bmodels too
; 397  : 		if( CVAR_TO_BOOL( r_lighting_extended ))

	cmp	DWORD PTR _r_lighting_extended, 0
	je	SHORT $LN21@R_LightVec
	mov	eax, DWORD PTR _r_lighting_extended
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@R_LightVec
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN22@R_LightVec
$LN21@R_LightVec:
	mov	DWORD PTR tv84[ebp], 0
$LN22@R_LightVec:
	cmp	DWORD PTR tv84[ebp], 0
	je	SHORT $LN9@R_LightVec

; 398  : 			maxEnts = clgame.pmove->numphysent;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR _maxEnts$[ebp], ecx
$LN9@R_LightVec:

; 399  : 
; 400  : 		// check all the bsp-models
; 401  : 		for( i = 0; i < maxEnts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_LightVec
$LN2@R_LightVec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_LightVec:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _maxEnts$[ebp]
	jge	$LN3@R_LightVec

; 402  : 		{
; 403  : 			physent_t	*pe = &clgame.pmove->physents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$7[ebp], edx

; 404  : 			vec3_t	offset, start_l, end_l;
; 405  : 			mnode_t	*pnodes;
; 406  : 			matrix4x4	matrix;
; 407  : 
; 408  : 			if( !pe->model || pe->model->type != mod_brush )

	mov	eax, DWORD PTR _pe$7[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN11@R_LightVec
	mov	eax, DWORD PTR _pe$7[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN10@R_LightVec
$LN11@R_LightVec:

; 409  : 				continue; // skip non-bsp models

	jmp	SHORT $LN2@R_LightVec
$LN10@R_LightVec:

; 410  : 
; 411  : 			pnodes = &pe->model->nodes[pe->model->hulls[0].firstclipnode];

	mov	eax, DWORD PTR _pe$7[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _pe$7[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	edx, 40					; 00000028H
	imul	edx, edx, 0
	imul	eax, DWORD PTR [eax+edx+216], 52
	add	eax, DWORD PTR [ecx+164]
	mov	DWORD PTR _pnodes$3[ebp], eax

; 412  : 			VectorSubtract( pe->model->hulls[0].clip_mins, vec3_origin, offset );

	mov	eax, DWORD PTR _pe$7[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+16]
	subss	xmm0, DWORD PTR _vec3_origin[edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$6[ebp+ecx], xmm0
	mov	edx, DWORD PTR _pe$7[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+208]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+ecx+16]
	subss	xmm0, DWORD PTR _vec3_origin[edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _offset$6[ebp+eax], xmm0
	mov	ecx, DWORD PTR _pe$7[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+208]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _vec3_origin[ecx]
	movss	DWORD PTR tv173[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR _offset$6[ebp+edx], xmm0

; 413  : 			VectorAdd( offset, pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR _offset$6[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$6[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR _offset$6[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$6[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR _offset$6[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+36]
	movss	DWORD PTR tv197[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv197[ebp]
	movss	DWORD PTR _offset$6[ebp+eax], xmm0

; 414  : 			VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$6[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$5[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$6[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$5[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$6[ebp+ecx]
	movss	DWORD PTR tv218[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv218[ebp]
	movss	DWORD PTR _start_l$5[ebp+eax], xmm0

; 415  : 			VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$6[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$4[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$6[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$6[ebp+ecx]
	movss	DWORD PTR tv239[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv239[ebp]
	movss	DWORD PTR _end_l$4[ebp+eax], xmm0

; 416  : 
; 417  : 			// rotate start and end into the models frame of reference
; 418  : 			if( !VectorIsNull( pe->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@R_LightVec
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@R_LightVec
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$7[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@R_LightVec
$LN13@R_LightVec:

; 419  : 			{
; 420  : 				Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$7[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$2[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 421  : 				Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$2[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 422  : 				Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$2[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN12@R_LightVec:

; 423  : 			}
; 424  : 
; 425  : 			VectorClear( g_trace_lightspot );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightspot[eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightspot[ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightspot[eax], xmm0

; 426  : 			VectorClear( g_trace_lightvec );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightvec[eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightvec[ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_trace_lightvec[eax], xmm0

; 427  : 			g_trace_fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _g_trace_fraction, xmm0

; 428  : 
; 429  : 			if( !R_RecursiveLightPoint( pe->model, pnodes, 0.0f, 1.0f, &cv, start_l, end_l ))

	lea	eax, DWORD PTR _end_l$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_l$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _cv$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pnodes$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$7[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_R_RecursiveLightPoint
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN14@R_LightVec

; 430  : 				continue;	// didn't hit anything

	jmp	$LN2@R_LightVec
$LN14@R_LightVec:

; 431  : 
; 432  : 			if( g_trace_fraction < last_fraction )

	movss	xmm0, DWORD PTR _last_fraction$[ebp]
	comiss	xmm0, DWORD PTR _g_trace_fraction
	jbe	$LN19@R_LightVec

; 433  : 			{
; 434  : 				if( lspot ) VectorCopy( g_trace_lightspot, lspot );

	cmp	DWORD PTR _lspot$[ebp], 0
	je	SHORT $LN16@R_LightVec
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lspot$[ebp]
	mov	ecx, DWORD PTR _g_trace_lightspot[ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lspot$[ebp]
	mov	edx, DWORD PTR _g_trace_lightspot[edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lspot$[ebp]
	mov	eax, DWORD PTR _g_trace_lightspot[eax]
	mov	DWORD PTR [edx+ecx], eax
$LN16@R_LightVec:

; 435  : 				if( lvec ) VectorNormalize2( g_trace_lightvec, lvec );

	cmp	DWORD PTR _lvec$[ebp], 0
	je	$LN17@R_LightVec
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _g_trace_lightvec[ecx]
	mulss	xmm0, DWORD PTR _g_trace_lightvec[eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _g_trace_lightvec[ecx]
	mulss	xmm1, DWORD PTR _g_trace_lightvec[edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _g_trace_lightvec[eax]
	mulss	xmm1, DWORD PTR _g_trace_lightvec[ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@R_LightVec
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN18@R_LightVec:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_trace_lightvec[ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lvec$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_trace_lightvec[eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lvec$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_trace_lightvec[eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lvec$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN17@R_LightVec:

; 436  : 				light.r = Q_min(( cv.r >> 7 ), 255 );

	mov	eax, DWORD PTR _cv$[ebp]
	shr	eax, 7
	cmp	eax, 255				; 000000ffH
	jae	SHORT $LN23@R_LightVec
	mov	ecx, DWORD PTR _cv$[ebp]
	shr	ecx, 7
	mov	DWORD PTR tv342[ebp], ecx
	jmp	SHORT $LN24@R_LightVec
$LN23@R_LightVec:
	mov	DWORD PTR tv342[ebp], 255		; 000000ffH
$LN24@R_LightVec:
	mov	edx, DWORD PTR tv342[ebp]
	mov	DWORD PTR _light$[ebp], edx

; 437  : 				light.g = Q_min(( cv.g >> 7 ), 255 );

	mov	eax, DWORD PTR _cv$[ebp+4]
	shr	eax, 7
	cmp	eax, 255				; 000000ffH
	jae	SHORT $LN25@R_LightVec
	mov	ecx, DWORD PTR _cv$[ebp+4]
	shr	ecx, 7
	mov	DWORD PTR tv346[ebp], ecx
	jmp	SHORT $LN26@R_LightVec
$LN25@R_LightVec:
	mov	DWORD PTR tv346[ebp], 255		; 000000ffH
$LN26@R_LightVec:
	mov	edx, DWORD PTR tv346[ebp]
	mov	DWORD PTR _light$[ebp+4], edx

; 438  : 				light.b = Q_min(( cv.b >> 7 ), 255 );

	mov	eax, DWORD PTR _cv$[ebp+8]
	shr	eax, 7
	cmp	eax, 255				; 000000ffH
	jae	SHORT $LN27@R_LightVec
	mov	ecx, DWORD PTR _cv$[ebp+8]
	shr	ecx, 7
	mov	DWORD PTR tv350[ebp], ecx
	jmp	SHORT $LN28@R_LightVec
$LN27@R_LightVec:
	mov	DWORD PTR tv350[ebp], 255		; 000000ffH
$LN28@R_LightVec:
	mov	edx, DWORD PTR tv350[ebp]
	mov	DWORD PTR _light$[ebp+8], edx

; 439  : 				last_fraction = g_trace_fraction;

	movss	xmm0, DWORD PTR _g_trace_fraction
	movss	DWORD PTR _last_fraction$[ebp], xmm0

; 440  : 
; 441  : 				if(( light.r + light.g + light.b ) != 0 )

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, DWORD PTR _light$[ebp+4]
	add	eax, DWORD PTR _light$[ebp+8]
	je	SHORT $LN19@R_LightVec

; 442  : 					break; // we get light now

	jmp	SHORT $LN3@R_LightVec
$LN19@R_LightVec:

; 443  : 			}
; 444  : 		}

	jmp	$LN2@R_LightVec
$LN3@R_LightVec:

; 445  : 	}

	jmp	SHORT $LN8@R_LightVec
$LN7@R_LightVec:

; 446  : 	else
; 447  : 	{
; 448  : 		light.r = light.g = light.b = 255;

	mov	DWORD PTR _light$[ebp+8], 255		; 000000ffH
	mov	eax, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR _light$[ebp+4], eax
	mov	ecx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR _light$[ebp], ecx

; 449  : 		light.a = 0;

	mov	DWORD PTR _light$[ebp+12], 0
$LN8@R_LightVec:

; 450  : 	}
; 451  : 
; 452  : 	return light;

	mov	eax, DWORD PTR __$ReturnAddress$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 453  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LightVecInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_RecursiveLightPoint
_TEXT	SEGMENT
tv936 = -304						; size = 4
tv1515 = -300						; size = 8
tv1511 = -292						; size = 4
tv1503 = -288						; size = 8
tv1499 = -280						; size = 4
tv1491 = -276						; size = 8
tv821 = -272						; size = 4
tv429 = -272						; size = 4
tv1487 = -268						; size = 4
tv968 = -268						; size = 4
tv957 = -268						; size = 4
tv909 = -268						; size = 4
tv810 = -268						; size = 4
tv459 = -268						; size = 4
tv418 = -268						; size = 4
tv251 = -268						; size = 4
tv233 = -268						; size = 4
tv182 = -268						; size = 4
tv180 = -268						; size = 4
tv174 = -268						; size = 4
tv136 = -268						; size = 4
_f$1 = -200						; size = 4
_lightNormal$2 = -196					; size = 12
_srcNormal$3 = -184					; size = 12
_scale$4 = -172						; size = 4
_ilength$5 = -168					; size = 4
_ilength$6 = -164					; size = 4
_ilength$7 = -160					; size = 4
_faceNormal$8 = -156					; size = 12
_tmax$9 = -144						; size = 4
_smax$10 = -140						; size = 4
_mid$ = -136						; size = 12
_tbn$ = -124						; size = 48
_tex$ = -76						; size = 4
_surf$ = -72						; size = 4
_info$ = -68						; size = 4
_dm$ = -64						; size = 4
_lm$ = -60						; size = 4
_sample_size$ = -56					; size = 4
_t$ = -52						; size = 4
_s$ = -48						; size = 4
_dt$ = -44						; size = 4
_ds$ = -40						; size = 4
_size$ = -36						; size = 4
_side$ = -32						; size = 4
_map$ = -28						; size = 4
_i$ = -24						; size = 4
_midf$ = -20						; size = 4
_frac$ = -16						; size = 4
_back$ = -12						; size = 4
_front$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_node$ = 12						; size = 4
_p1f$ = 16						; size = 4
_p2f$ = 20						; size = 4
_cv$ = 24						; size = 4
_start$ = 28						; size = 4
_end$ = 32						; size = 4
_R_RecursiveLightPoint PROC				; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 230  : 	float		front, back, frac, midf;
; 231  : 	int		i, map, side, size;
; 232  : 	float		ds, dt, s, t;
; 233  : 	int		sample_size;
; 234  : 	color24		*lm, *dm;
; 235  : 	mextrasurf_t	*info;
; 236  : 	msurface_t	*surf;
; 237  : 	mtexinfo_t	*tex;
; 238  : 	matrix3x4		tbn;
; 239  : 	vec3_t		mid;
; 240  : 
; 241  : 	// didn't hit anything
; 242  : 	if( !node || node->contents < 0 )

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN9@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN8@R_Recursiv
$LN9@R_Recursiv:

; 243  : 	{
; 244  : 		cv->r = cv->g = cv->b = cv->a = 0;

	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax], 0

; 245  : 		return false;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN8@R_Recursiv:

; 246  : 	}
; 247  : 
; 248  : 	// calculate mid point
; 249  : 	front = PlaneDiff( start, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN29@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv136[ebp], xmm0
	jmp	SHORT $LN30@R_Recursiv
$LN29@R_Recursiv:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv136[ebp], xmm0
$LN30@R_Recursiv:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv136[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _front$[ebp], xmm0

; 250  : 	back = PlaneDiff( end, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN31@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv174[ebp], xmm0
	jmp	SHORT $LN32@R_Recursiv
$LN31@R_Recursiv:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv174[ebp], xmm0
$LN32@R_Recursiv:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv174[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _back$[ebp], xmm0

; 251  : 
; 252  : 	side = front < 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN33@R_Recursiv
	mov	DWORD PTR tv180[ebp], 1
	jmp	SHORT $LN34@R_Recursiv
$LN33@R_Recursiv:
	mov	DWORD PTR tv180[ebp], 0
$LN34@R_Recursiv:
	mov	eax, DWORD PTR tv180[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 253  : 	if(( back < 0 ) == side )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN35@R_Recursiv
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN36@R_Recursiv
$LN35@R_Recursiv:
	mov	DWORD PTR tv182[ebp], 0
$LN36@R_Recursiv:
	mov	eax, DWORD PTR tv182[ebp]
	cmp	eax, DWORD PTR _side$[ebp]
	jne	SHORT $LN10@R_Recursiv

; 254  : 		return R_RecursiveLightPoint( model, node->children[side], p1f, p2f, cv, start, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cv$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_R_RecursiveLightPoint
	add	esp, 28					; 0000001cH
	jmp	$LN1@R_Recursiv
$LN10@R_Recursiv:

; 255  : 
; 256  : 	frac = front / ( front - back );

	movss	xmm0, DWORD PTR _front$[ebp]
	subss	xmm0, DWORD PTR _back$[ebp]
	movss	xmm1, DWORD PTR _front$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 257  : 
; 258  : 	VectorLerp( start, frac, end, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv233[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 259  : 	midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 260  : 
; 261  : 	// co down front side	
; 262  : 	if( R_RecursiveLightPoint( model, node->children[side], p1f, midf, cv, start, mid ))

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cv$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_R_RecursiveLightPoint
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN11@R_Recursiv

; 263  : 		return true; // hit something

	mov	eax, 1
	jmp	$LN1@R_Recursiv
$LN11@R_Recursiv:

; 264  : 
; 265  : 	if(( back < 0 ) == side )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN37@R_Recursiv
	mov	DWORD PTR tv251[ebp], 1
	jmp	SHORT $LN38@R_Recursiv
$LN37@R_Recursiv:
	mov	DWORD PTR tv251[ebp], 0
$LN38@R_Recursiv:
	mov	eax, DWORD PTR tv251[ebp]
	cmp	eax, DWORD PTR _side$[ebp]
	jne	SHORT $LN12@R_Recursiv

; 266  : 	{
; 267  : 		cv->r = cv->g = cv->b = cv->a = 0;

	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax], 0

; 268  : 		return false; // didn't hit anything

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN12@R_Recursiv:

; 269  : 	}
; 270  : 
; 271  : 	// check for impact on this node
; 272  : 	surf = model->surfaces + node->firstsurface;

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _model$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], edx

; 273  : 	VectorCopy( mid, g_trace_lightspot );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mid$[ebp+ecx]
	mov	DWORD PTR _g_trace_lightspot[eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR _g_trace_lightspot[eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR _g_trace_lightspot[eax], ecx

; 274  : 
; 275  : 	for( i = 0; i < node->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Recursiv
$LN2@R_Recursiv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN4@R_Recursiv:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN3@R_Recursiv

; 276  : 	{
; 277  : 		int	smax, tmax;
; 278  : 
; 279  : 		tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 280  : 		info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 281  : 
; 282  : 		if( FBitSet( surf->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN13@R_Recursiv

; 283  : 			continue;	// no lightmaps

	jmp	SHORT $LN2@R_Recursiv
$LN13@R_Recursiv:

; 284  : 
; 285  : 		s = DotProduct( mid, info->lmvecs[0] ) + info->lmvecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _s$[ebp], xmm0

; 286  : 		t = DotProduct( mid, info->lmvecs[1] ) + info->lmvecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _t$[ebp], xmm0

; 287  : 
; 288  : 		if( s < info->lightmapmins[0] || t < info->lightmapmins[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR _s$[ebp]
	ja	SHORT $LN15@R_Recursiv
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	comiss	xmm0, DWORD PTR _t$[ebp]
	jbe	SHORT $LN14@R_Recursiv
$LN15@R_Recursiv:

; 289  : 			continue;

	jmp	$LN2@R_Recursiv
$LN14@R_Recursiv:

; 290  : 
; 291  : 		ds = s - info->lightmapmins[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _ds$[ebp], xmm1

; 292  : 		dt = t - info->lightmapmins[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _t$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _dt$[ebp], xmm1

; 293  : 		
; 294  : 		if ( ds > info->lightextents[0] || dt > info->lightextents[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _ds$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN17@R_Recursiv
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+52]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dt$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@R_Recursiv
$LN17@R_Recursiv:

; 295  : 			continue;

	jmp	$LN2@R_Recursiv
$LN16@R_Recursiv:

; 296  : 
; 297  : 		cv->r = cv->g = cv->b = cv->a = 0;

	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax], 0

; 298  : 
; 299  : 		if( !surf->samples )

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN18@R_Recursiv

; 300  : 			return true;

	mov	eax, 1
	jmp	$LN1@R_Recursiv
$LN18@R_Recursiv:

; 301  : 
; 302  : 		sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 303  : 		smax = (info->lightextents[0] / sample_size) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$10[ebp], eax

; 304  : 		tmax = (info->lightextents[1] / sample_size) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$9[ebp], eax

; 305  : 		ds /= sample_size;

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _ds$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _ds$[ebp], xmm1

; 306  : 		dt /= sample_size;

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _dt$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _dt$[ebp], xmm1

; 307  : 
; 308  : 		lm = surf->samples + Q_rint( dt ) * smax + Q_rint( ds );

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dt$[ebp]
	jbe	SHORT $LN39@R_Recursiv
	movss	xmm0, DWORD PTR _dt$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv418[ebp], eax
	jmp	SHORT $LN40@R_Recursiv
$LN39@R_Recursiv:
	movss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv418[ebp], ecx
$LN40@R_Recursiv:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _ds$[ebp]
	jbe	SHORT $LN41@R_Recursiv
	movss	xmm0, DWORD PTR _ds$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv429[ebp], edx
	jmp	SHORT $LN42@R_Recursiv
$LN41@R_Recursiv:
	movss	xmm0, DWORD PTR _ds$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv429[ebp], eax
$LN42@R_Recursiv:
	mov	ecx, DWORD PTR tv418[ebp]
	imul	ecx, DWORD PTR _smax$10[ebp]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, edx
	imul	edx, DWORD PTR tv429[ebp], 3
	add	ecx, edx
	mov	DWORD PTR _lm$[ebp], ecx

; 309  : 		g_trace_fraction = midf;

	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR _g_trace_fraction, xmm0

; 310  : 		size = smax * tmax;

	mov	eax, DWORD PTR _smax$10[ebp]
	imul	eax, DWORD PTR _tmax$9[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 311  : 		dm = NULL;

	mov	DWORD PTR _dm$[ebp], 0

; 312  : 
; 313  : 		if( surf->info->deluxemap )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	cmp	DWORD PTR [ecx+88], 0
	je	$LN19@R_Recursiv

; 314  : 		{
; 315  : 			vec3_t	faceNormal;
; 316  : 
; 317  : 			if( FBitSet( surf->flags, SURF_PLANEBACK ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	$LN20@R_Recursiv

; 318  : 				VectorNegate( surf->plane->normal, faceNormal );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _faceNormal$8[ebp+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _faceNormal$8[ebp+eax], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv459[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv459[ebp]
	movss	DWORD PTR _faceNormal$8[ebp+ecx], xmm0
	jmp	SHORT $LN21@R_Recursiv
$LN20@R_Recursiv:

; 319  : 			else VectorCopy( surf->plane->normal, faceNormal );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _faceNormal$8[ebp+edx], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _faceNormal$8[ebp+ecx], edx
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _faceNormal$8[ebp+eax], ecx
$LN21@R_Recursiv:

; 320  : 
; 321  : 			// compute face TBN
; 322  : #if 1
; 323  : 			Vector4Set( tbn[0], surf->info->lmvecs[0][0], surf->info->lmvecs[0][1], surf->info->lmvecs[0][2], 0.0f );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+56]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+56]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 324  : 			Vector4Set( tbn[1], -surf->info->lmvecs[1][0], -surf->info->lmvecs[1][1], -surf->info->lmvecs[1][2], 0.0f );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+56]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 325  : 			Vector4Set( tbn[2], faceNormal[0], faceNormal[1], faceNormal[2], 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _faceNormal$8[ebp+ecx]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _faceNormal$8[ebp+eax]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _faceNormal$8[ebp+ecx]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 326  : #else
; 327  : 			Vector4Set( tbn[0], surf->info->lmvecs[0][0], -surf->info->lmvecs[1][0], faceNormal[0], 0.0f );
; 328  : 			Vector4Set( tbn[1], surf->info->lmvecs[0][1], -surf->info->lmvecs[1][1], faceNormal[1], 0.0f );
; 329  : 			Vector4Set( tbn[2], surf->info->lmvecs[0][2], -surf->info->lmvecs[1][2], faceNormal[2], 0.0f );
; 330  : #endif
; 331  : 			VectorNormalize( tbn[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	lea	eax, DWORD PTR _tbn$[ebp+eax]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _tbn$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	lea	edx, DWORD PTR _tbn$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	lea	ecx, DWORD PTR _tbn$[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$7[ebp]
	movss	xmm0, DWORD PTR _ilength$7[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@R_Recursiv
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$7[ebp]
	movss	DWORD PTR _ilength$7[ebp], xmm0
$LN22@R_Recursiv:
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	ecx, DWORD PTR _tbn$[ebp+edx]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _tbn$[ebp+eax]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _tbn$[ebp+eax]
	movss	DWORD PTR [edx+ecx], xmm0

; 332  : 			VectorNormalize( tbn[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	edx, DWORD PTR _tbn$[ebp+edx]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	eax, DWORD PTR _tbn$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	ecx, DWORD PTR _tbn$[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$6[ebp]
	movss	xmm0, DWORD PTR _ilength$6[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@R_Recursiv
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$6[ebp]
	movss	DWORD PTR _ilength$6[ebp], xmm0
$LN23@R_Recursiv:
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	movss	DWORD PTR [edx+eax], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	movss	DWORD PTR [edx+eax], xmm0

; 333  : 			VectorNormalize( tbn[2] );

	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	edx, DWORD PTR _tbn$[ebp+edx]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	eax, DWORD PTR _tbn$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	ecx, DWORD PTR _tbn$[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$5[ebp]
	movss	xmm0, DWORD PTR _ilength$5[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@R_Recursiv
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$5[ebp]
	movss	DWORD PTR _ilength$5[ebp], xmm0
$LN24@R_Recursiv:
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	movss	DWORD PTR [edx+eax], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _tbn$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _tbn$[ebp+ecx]
	movss	DWORD PTR [edx+eax], xmm0

; 334  : 			dm = surf->info->deluxemap + Q_rint( dt ) * smax + Q_rint( ds );

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dt$[ebp]
	jbe	SHORT $LN43@R_Recursiv
	movss	xmm0, DWORD PTR _dt$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv810[ebp], eax
	jmp	SHORT $LN44@R_Recursiv
$LN43@R_Recursiv:
	movss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv810[ebp], ecx
$LN44@R_Recursiv:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _ds$[ebp]
	jbe	SHORT $LN45@R_Recursiv
	movss	xmm0, DWORD PTR _ds$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv821[ebp], edx
	jmp	SHORT $LN46@R_Recursiv
$LN45@R_Recursiv:
	movss	xmm0, DWORD PTR _ds$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv821[ebp], eax
$LN46@R_Recursiv:
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR tv810[ebp]
	imul	eax, DWORD PTR _smax$10[ebp]
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+88]
	add	edx, ecx
	imul	eax, DWORD PTR tv821[ebp], 3
	add	edx, eax
	mov	DWORD PTR _dm$[ebp], edx
$LN19@R_Recursiv:

; 335  : 		}
; 336  : 
; 337  : 		for( map = 0; map < MAXLIGHTMAPS && surf->styles[map] != 255; map++ )

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN7@R_Recursiv
$LN5@R_Recursiv:
	mov	eax, DWORD PTR _map$[ebp]
	add	eax, 1
	mov	DWORD PTR _map$[ebp], eax
$LN7@R_Recursiv:
	cmp	DWORD PTR _map$[ebp], 4
	jge	$LN6@R_Recursiv
	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	$LN6@R_Recursiv

; 338  : 		{
; 339  : 			uint	scale = tr.lightstylevalue[surf->styles[map]];

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	mov	edx, DWORD PTR _tr[ecx*4+87324]
	mov	DWORD PTR _scale$4[ebp], edx

; 340  : 
; 341  : 			if( tr.ignore_lightgamma )

	cmp	DWORD PTR _tr+83204, 0
	je	SHORT $LN25@R_Recursiv

; 342  : 			{
; 343  : 				cv->r += lm->r * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, DWORD PTR _scale$4[ebp]
	mov	edx, DWORD PTR _cv$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax], ecx

; 344  : 				cv->g += lm->g * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	imul	ecx, DWORD PTR _scale$4[ebp]
	mov	edx, DWORD PTR _cv$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 345  : 				cv->b += lm->b * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	imul	ecx, DWORD PTR _scale$4[ebp]
	mov	edx, DWORD PTR _cv$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 346  : 			}

	jmp	SHORT $LN26@R_Recursiv
$LN25@R_Recursiv:

; 347  : 			else
; 348  : 			{
; 349  : 				cv->r += LightToTexGamma( lm->r ) * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edx, DWORD PTR _scale$4[ebp]
	mov	eax, DWORD PTR _cv$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx], edx

; 350  : 				cv->g += LightToTexGamma( lm->g ) * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edx, DWORD PTR _scale$4[ebp]
	mov	eax, DWORD PTR _cv$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 351  : 				cv->b += LightToTexGamma( lm->b ) * scale;

	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edx, DWORD PTR _scale$4[ebp]
	mov	eax, DWORD PTR _cv$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _cv$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN26@R_Recursiv:

; 352  : 			}
; 353  : 			lm += size; // skip to next lightmap

	imul	eax, DWORD PTR _size$[ebp], 3
	add	eax, DWORD PTR _lm$[ebp]
	mov	DWORD PTR _lm$[ebp], eax

; 354  : 
; 355  : 			if( dm != NULL )

	cmp	DWORD PTR _dm$[ebp], 0
	je	$LN27@R_Recursiv

; 356  : 			{
; 357  : 				vec3_t	srcNormal, lightNormal;
; 358  : 				float	f = (1.0f / 128.0f);

	movss	xmm0, DWORD PTR __real@3c000000
	movss	DWORD PTR _f$1[ebp], xmm0

; 359  : 
; 360  : 				VectorSet( srcNormal, ((float)dm->r - 128.0f) * f, ((float)dm->g - 128.0f) * f, ((float)dm->b - 128.0f) * f );

	mov	eax, DWORD PTR _dm$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	subss	xmm0, DWORD PTR __real@43000000
	mulss	xmm0, DWORD PTR _f$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _srcNormal$3[ebp+eax], xmm0
	mov	ecx, DWORD PTR _dm$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2ss xmm0, edx
	subss	xmm0, DWORD PTR __real@43000000
	mulss	xmm0, DWORD PTR _f$1[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _srcNormal$3[ebp+eax], xmm0
	mov	ecx, DWORD PTR _dm$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cvtsi2ss xmm0, edx
	subss	xmm0, DWORD PTR __real@43000000
	mulss	xmm0, DWORD PTR _f$1[ebp]
	movss	DWORD PTR tv909[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv909[ebp]
	movss	DWORD PTR _srcNormal$3[ebp+eax], xmm0

; 361  : 				Matrix3x4_VectorIRotate( tbn, srcNormal, lightNormal );		// turn to world space

	lea	eax, DWORD PTR _lightNormal$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _srcNormal$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _tbn$[ebp]
	push	edx
	call	_Matrix3x4_VectorIRotate
	add	esp, 12					; 0000000cH

; 362  : 				VectorScale( lightNormal, (float)scale * -1.0f, lightNormal );	// turn direction from light

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _scale$4[ebp]
	mov	DWORD PTR tv1487[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1487[ebp]
	mov	eax, DWORD PTR tv1487[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1491[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1491[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _lightNormal$2[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lightNormal$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _scale$4[ebp]
	mov	DWORD PTR tv1499[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1499[ebp]
	mov	edx, DWORD PTR tv1499[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1503[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1503[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _lightNormal$2[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _lightNormal$2[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _scale$4[ebp]
	mov	DWORD PTR tv1511[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1511[ebp]
	mov	eax, DWORD PTR tv1511[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1515[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1515[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR _lightNormal$2[ebp+ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv936[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv936[ebp]
	movss	DWORD PTR _lightNormal$2[ebp+ecx], xmm0

; 363  : 				VectorAdd( g_trace_lightvec, lightNormal, g_trace_lightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _g_trace_lightvec[ecx]
	addss	xmm0, DWORD PTR _lightNormal$2[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _g_trace_lightvec[edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_trace_lightvec[eax]
	addss	xmm0, DWORD PTR _lightNormal$2[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _g_trace_lightvec[edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _g_trace_lightvec[eax]
	addss	xmm0, DWORD PTR _lightNormal$2[ebp+ecx]
	movss	DWORD PTR tv957[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv957[ebp]
	movss	DWORD PTR _g_trace_lightvec[edx], xmm0

; 364  : 				dm += size; // skip to next deluxmap

	imul	eax, DWORD PTR _size$[ebp], 3
	add	eax, DWORD PTR _dm$[ebp]
	mov	DWORD PTR _dm$[ebp], eax
$LN27@R_Recursiv:

; 365  : 			}
; 366  : 		}

	jmp	$LN5@R_Recursiv
$LN6@R_Recursiv:

; 367  : 
; 368  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_Recursiv

; 369  : 	}

	jmp	$LN2@R_Recursiv
$LN3@R_Recursiv:

; 370  : 
; 371  : 	// go down back side
; 372  : 	return R_RecursiveLightPoint( model, node->children[!side], midf, p2f, cv, mid, end );

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN47@R_Recursiv
	mov	DWORD PTR tv968[ebp], 1
	jmp	SHORT $LN48@R_Recursiv
$LN47@R_Recursiv:
	mov	DWORD PTR tv968[ebp], 0
$LN48@R_Recursiv:
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cv$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR tv968[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_R_RecursiveLightPoint
	add	esp, 28					; 0000001cH
$LN1@R_Recursiv:

; 373  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RecursiveLightPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_CountDlights
_TEXT	SEGMENT
_numDlights$ = -12					; size = 4
_i$ = -8						; size = 4
_l$ = -4						; size = 4
_R_CountDlights PROC					; COMDAT

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 178  : 	dlight_t	*l;
; 179  : 	int	i, numDlights = 0;

	mov	DWORD PTR _numDlights$[ebp], 0

; 180  : 
; 181  : 	for( i = 0, l = cl_dlights; i < MAX_DLIGHTS; i++, l++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _l$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@R_CountDli
$LN2@R_CountDli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _l$[ebp], ecx
$LN4@R_CountDli:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@R_CountDli

; 182  : 	{
; 183  : 		if( l->die < cl.time || !l->radius )

	mov	eax, DWORD PTR _l$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN6@R_CountDli
	mov	eax, DWORD PTR _l$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_CountDli
$LN6@R_CountDli:

; 184  : 			continue;

	jmp	SHORT $LN2@R_CountDli
$LN5@R_CountDli:

; 185  : 
; 186  : 		numDlights++;

	mov	eax, DWORD PTR _numDlights$[ebp]
	add	eax, 1
	mov	DWORD PTR _numDlights$[ebp], eax

; 187  : 	}

	jmp	SHORT $LN2@R_CountDli
$LN3@R_CountDli:

; 188  : 
; 189  : 	return numDlights;

	mov	eax, DWORD PTR _numDlights$[ebp]

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CountDlights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_LightPoint
_TEXT	SEGMENT
tv79 = -100						; size = 4
$T1 = -96						; size = 16
_p1$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_p0$ = 12						; size = 4
_R_LightPoint PROC					; COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 485  : 	vec3_t	p1;
; 486  : 
; 487  : 	VectorSet( p1, p0[0], p0[1], p0[2] - 2048.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p0$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _p1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p0$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _p1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _p0$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR __real@45000000
	movss	DWORD PTR tv79[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR _p1$[ebp+ecx], xmm0

; 488  : 
; 489  : 	return R_LightVec( p0, p1, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _p1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p0$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR __$ReturnAddress$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LightPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_CountSurfaceDlights
_TEXT	SEGMENT
_numDlights$ = -8					; size = 4
_i$ = -4						; size = 4
_surf$ = 8						; size = 4
_R_CountSurfaceDlights PROC				; COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 199  : 	int	i, numDlights = 0;

	mov	DWORD PTR _numDlights$[ebp], 0

; 200  : 
; 201  : 	for( i = 0; i < MAX_DLIGHTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_CountSur
$LN2@R_CountSur:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_CountSur:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@R_CountSur

; 202  : 	{
; 203  : 		if(!( surf->dlightbits & BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _surf$[ebp]
	and	eax, DWORD PTR [ecx+52]
	jne	SHORT $LN5@R_CountSur

; 204  : 			continue;	// not lit by this light

	jmp	SHORT $LN2@R_CountSur
$LN5@R_CountSur:

; 205  : 
; 206  : 		numDlights++;

	mov	eax, DWORD PTR _numDlights$[ebp]
	add	eax, 1
	mov	DWORD PTR _numDlights$[ebp], eax

; 207  : 	}

	jmp	SHORT $LN2@R_CountSur
$LN3@R_CountSur:

; 208  : 
; 209  : 	return numDlights;

	mov	eax, DWORD PTR _numDlights$[ebp]

; 210  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CountSurfaceDlights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_LightVec
_TEXT	SEGMENT
tv74 = -120						; size = 4
$T1 = -116						; size = 16
$T2 = -100						; size = 16
_light$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_lspot$ = 20						; size = 4
_lvec$ = 24						; size = 4
_R_LightVec PROC					; COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 464  : 	colorVec	light = R_LightVecInternal( start, end, lspot, lvec );

	mov	eax, DWORD PTR _lvec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lspot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_R_LightVecInternal
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _light$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _light$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _light$[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _light$[ebp+12], eax

; 465  : 
; 466  : 	if( CVAR_TO_BOOL( r_lighting_extended ) && lspot != NULL && lvec != NULL )

	cmp	DWORD PTR _r_lighting_extended, 0
	je	SHORT $LN5@R_LightVec
	mov	eax, DWORD PTR _r_lighting_extended
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_LightVec
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN6@R_LightVec
$LN5@R_LightVec:
	mov	DWORD PTR tv74[ebp], 0
$LN6@R_LightVec:
	cmp	DWORD PTR tv74[ebp], 0
	je	SHORT $LN3@R_LightVec
	cmp	DWORD PTR _lspot$[ebp], 0
	je	SHORT $LN3@R_LightVec
	cmp	DWORD PTR _lvec$[ebp], 0
	je	SHORT $LN3@R_LightVec

; 467  : 	{
; 468  : 		// trying to get light from ceiling (but ignore gradient analyze)
; 469  : 		if(( light.r + light.g + light.b ) == 0 )

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, DWORD PTR _light$[ebp+4]
	add	eax, DWORD PTR _light$[ebp+8]
	jne	SHORT $LN3@R_LightVec

; 470  : 			return R_LightVecInternal( end, start, lspot, lvec );

	mov	eax, DWORD PTR _lvec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lspot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_R_LightVecInternal
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR __$ReturnAddress$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]
	jmp	SHORT $LN1@R_LightVec
$LN3@R_LightVec:

; 471  : 	}
; 472  : 
; 473  : 	return light;

	mov	eax, DWORD PTR __$ReturnAddress$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]
$LN1@R_LightVec:

; 474  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LightVec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_MarkLights
_TEXT	SEGMENT
tv135 = -80						; size = 4
_i$ = -12						; size = 4
_surf$ = -8						; size = 4
_dist$ = -4						; size = 4
_light$ = 8						; size = 4
_bit$ = 12						; size = 4
_node$ = 16						; size = 4
_R_MarkLights PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 103  : 	float		dist;
; 104  : 	msurface_t	*surf;
; 105  : 	int		i;
; 106  : 	
; 107  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@R_MarkLigh

; 108  : 		return;

	jmp	$LN1@R_MarkLigh
$LN5@R_MarkLigh:

; 109  : 
; 110  : 	dist = PlaneDiff( light->origin, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN11@R_MarkLigh
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _light$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN12@R_MarkLigh
$LN11@R_MarkLigh:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _light$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _light$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _light$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv135[ebp], xmm0
$LN12@R_MarkLigh:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv135[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _dist$[ebp], xmm0

; 111  : 
; 112  : 	if( dist > light->radius )

	mov	eax, DWORD PTR _light$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN6@R_MarkLigh

; 113  : 	{
; 114  : 		R_MarkLights( light, bit, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _bit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	push	edx
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 115  : 		return;

	jmp	$LN1@R_MarkLigh
$LN6@R_MarkLigh:

; 116  : 	}
; 117  : 	if( dist < -light->radius )

	mov	eax, DWORD PTR _light$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN7@R_MarkLigh

; 118  : 	{
; 119  : 		R_MarkLights( light, bit, node->children[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	mov	eax, DWORD PTR _bit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 120  : 		return;

	jmp	$LN1@R_MarkLigh
$LN7@R_MarkLigh:

; 121  : 	}
; 122  : 		
; 123  : 	// mark the polygons
; 124  : 	surf = RI.currentmodel->surfaces + node->firstsurface;

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _RI+32
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], edx

; 125  : 
; 126  : 	for( i = 0; i < node->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_MarkLigh
$LN2@R_MarkLigh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN4@R_MarkLigh:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@R_MarkLigh

; 127  : 	{
; 128  : 		if( !BoundsAndSphereIntersect( surf->info->mins, surf->info->maxs, light->origin, light->radius ))

	mov	eax, DWORD PTR _light$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	_BoundsAndSphereIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN8@R_MarkLigh

; 129  : 			continue;	// no intersection

	jmp	SHORT $LN2@R_MarkLigh
$LN8@R_MarkLigh:

; 130  : 
; 131  : 		if( surf->dlightframe != tr.dlightframecount )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR _tr+83192
	je	SHORT $LN9@R_MarkLigh

; 132  : 		{
; 133  : 			surf->dlightbits = 0;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [eax+52], 0

; 134  : 			surf->dlightframe = tr.dlightframecount;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _tr+83192
	mov	DWORD PTR [eax+48], ecx
$LN9@R_MarkLigh:

; 135  : 		}
; 136  : 		surf->dlightbits |= bit;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, DWORD PTR _bit$[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 137  : 	}

	jmp	$LN2@R_MarkLigh
$LN3@R_MarkLigh:

; 138  : 
; 139  : 	R_MarkLights( light, bit, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _bit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	push	edx
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 140  : 	R_MarkLights( light, bit, node->children[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	mov	eax, DWORD PTR _bit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	call	_R_MarkLights
	add	esp, 12					; 0000000cH
$LN1@R_MarkLigh:

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_MarkLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _R_PushDlights
_TEXT	SEGMENT
_i$ = -8						; size = 4
_l$ = -4						; size = 4
_R_PushDlights PROC					; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 150  : 	dlight_t	*l;
; 151  : 	int	i;
; 152  : 
; 153  : 	tr.dlightframecount = tr.framecount;

	mov	eax, DWORD PTR _tr+83200
	mov	DWORD PTR _tr+83192, eax

; 154  : 	l = cl_dlights;

	mov	DWORD PTR _l$[ebp], OFFSET _cl_dlights

; 155  : 
; 156  : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 157  : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 158  : 
; 159  : 	for( i = 0; i < MAX_DLIGHTS; i++, l++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_PushDlig
$LN2@R_PushDlig:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _l$[ebp], ecx
$LN4@R_PushDlig:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@R_PushDlig

; 160  : 	{
; 161  : 		if( l->die < cl.time || !l->radius )

	mov	eax, DWORD PTR _l$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN6@R_PushDlig
	mov	eax, DWORD PTR _l$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_PushDlig
$LN6@R_PushDlig:

; 162  : 			continue;

	jmp	SHORT $LN2@R_PushDlig
$LN5@R_PushDlig:

; 163  : 
; 164  : 		if( GL_FrustumCullSphere( &RI.frustum, l->origin, l->radius, 15 ))

	push	15					; 0000000fH
	mov	eax, DWORD PTR _l$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET _RI+56
	call	_GL_FrustumCullSphere
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@R_PushDlig

; 165  : 			continue;

	jmp	SHORT $LN2@R_PushDlig
$LN7@R_PushDlig:

; 166  : 
; 167  : 		R_MarkLights( l, 1<<i, RI.currentmodel->nodes );

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 168  : 	}

	jmp	$LN2@R_PushDlig
$LN3@R_PushDlig:

; 169  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PushDlights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rlight.c
;	COMDAT _CL_RunLightStyles
_TEXT	SEGMENT
tv156 = -108						; size = 4
_ls$ = -40						; size = 4
_scale$ = -36						; size = 4
_frametime$ = -32					; size = 4
_backlerp$ = -28					; size = 4
_lerpfrac$ = -24					; size = 4
_l$ = -20						; size = 4
_clight$ = -16						; size = 4
_flight$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_RunLightStyles PROC					; COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 38   : 	int		i, k, flight, clight;
; 39   : 	float		l, lerpfrac, backlerp;
; 40   : 	float		frametime = (cl.time - cl.oldtime);

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _frametime$[ebp], xmm0

; 41   : 	float		scale;
; 42   : 	lightstyle_t	*ls;
; 43   : 
; 44   : 	if( !cl.worldmodel ) return;

	cmp	DWORD PTR _cl+4579004, 0
	jne	SHORT $LN5@CL_RunLigh
	jmp	$LN3@CL_RunLigh
$LN5@CL_RunLigh:

; 45   : 
; 46   : 	scale = r_lighting_modulate->value;

	mov	eax, DWORD PTR _r_lighting_modulate
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _scale$[ebp], xmm0

; 47   : 
; 48   : 	// light animations
; 49   : 	// 'm' is normal light, 'a' is no light, 'z' is double bright
; 50   : 	for( i = 0, ls = cl.lightstyles; i < MAX_LIGHTSTYLES; i++, ls++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _ls$[ebp], OFFSET _cl+2897300
	jmp	SHORT $LN4@CL_RunLigh
$LN2@CL_RunLigh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ls$[ebp]
	add	ecx, 1296				; 00000510H
	mov	DWORD PTR _ls$[ebp], ecx
$LN4@CL_RunLigh:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN3@CL_RunLigh

; 51   : 	{
; 52   : 		if( !cl.worldmodel->lightdata )

	mov	eax, DWORD PTR _cl+4579004
	cmp	DWORD PTR [eax+380], 0
	jne	SHORT $LN6@CL_RunLigh

; 53   : 		{
; 54   : 			tr.lightstylevalue[i] = 256 * 256;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[eax*4+87324], 65536	; 00010000H

; 55   : 			continue;

	jmp	SHORT $LN2@CL_RunLigh
$LN6@CL_RunLigh:

; 56   : 		}
; 57   : 
; 58   : 		if( !cl.paused && frametime <= 0.1f )

	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN7@CL_RunLigh
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _frametime$[ebp]
	jb	SHORT $LN7@CL_RunLigh

; 59   : 			ls->time += frametime; // evaluate local time

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	addss	xmm0, DWORD PTR _frametime$[ebp]
	mov	ecx, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [ecx+1292], xmm0
$LN7@CL_RunLigh:

; 60   : 
; 61   : 		flight = (int)Q_floor( ls->time * 10 );

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	cvtsi2ss xmm0, ecx
	cvttss2si edx, xmm0
	mov	DWORD PTR _flight$[ebp], edx

; 62   : 		clight = (int)Q_ceil( ls->time * 10 );

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si ecx, xmm0
	cvtsi2ss xmm0, ecx
	cvttss2si edx, xmm0
	mov	DWORD PTR _clight$[ebp], edx

; 63   : 		lerpfrac = ( ls->time * 10 ) - flight;

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	mulss	xmm0, DWORD PTR __real@41200000
	cvtsi2ss xmm1, DWORD PTR _flight$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _lerpfrac$[ebp], xmm0

; 64   : 		backlerp = 1.0f - lerpfrac;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _lerpfrac$[ebp]
	movss	DWORD PTR _backlerp$[ebp], xmm0

; 65   : 
; 66   : 		if( !ls->length )

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1280], 0
	jne	SHORT $LN8@CL_RunLigh

; 67   : 		{
; 68   : 			tr.lightstylevalue[i] = 256 * scale;

	movss	xmm0, DWORD PTR __real@43800000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[ecx*4+87324], eax

; 69   : 			continue;

	jmp	$LN2@CL_RunLigh

; 70   : 		}

	jmp	$LN12@CL_RunLigh
$LN8@CL_RunLigh:

; 71   : 		else if( ls->length == 1 )

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1280], 1
	jne	SHORT $LN10@CL_RunLigh

; 72   : 		{
; 73   : 			// single length style so don't bother interpolating
; 74   : 			tr.lightstylevalue[i] = ls->map[0] * 22 * scale;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+256]
	mulss	xmm0, DWORD PTR __real@41b00000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[ecx*4+87324], eax

; 75   : 			continue;

	jmp	$LN2@CL_RunLigh

; 76   : 		}

	jmp	SHORT $LN12@CL_RunLigh
$LN10@CL_RunLigh:

; 77   : 		else if( !ls->interp || !CVAR_TO_BOOL( cl_lightstyle_lerping ))

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1288], 0
	je	SHORT $LN13@CL_RunLigh
	cmp	DWORD PTR _cl_lightstyle_lerping, 0
	je	SHORT $LN15@CL_RunLigh
	mov	eax, DWORD PTR _cl_lightstyle_lerping
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@CL_RunLigh
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN16@CL_RunLigh
$LN15@CL_RunLigh:
	mov	DWORD PTR tv156[ebp], 0
$LN16@CL_RunLigh:
	cmp	DWORD PTR tv156[ebp], 0
	jne	SHORT $LN12@CL_RunLigh
$LN13@CL_RunLigh:

; 78   : 		{
; 79   : 			tr.lightstylevalue[i] = ls->map[flight%ls->length] * 22 * scale;

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _flight$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	mulss	xmm0, DWORD PTR __real@41b00000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[edx*4+87324], ecx

; 80   : 			continue;

	jmp	$LN2@CL_RunLigh
$LN12@CL_RunLigh:

; 81   : 		}
; 82   : 
; 83   : 		// interpolate animating light
; 84   : 		// frame just gone
; 85   : 		k = ls->map[flight % ls->length];

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _flight$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx*4+256]
	mov	DWORD PTR _k$[ebp], ecx

; 86   : 		l = (float)( k * 22.0f ) * backlerp;

	cvtsi2ss xmm0, DWORD PTR _k$[ebp]
	mulss	xmm0, DWORD PTR __real@41b00000
	mulss	xmm0, DWORD PTR _backlerp$[ebp]
	movss	DWORD PTR _l$[ebp], xmm0

; 87   : 
; 88   : 		// upcoming frame
; 89   : 		k = ls->map[clight % ls->length];

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _clight$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx*4+256]
	mov	DWORD PTR _k$[ebp], ecx

; 90   : 		l += (float)( k * 22.0f ) * lerpfrac;

	cvtsi2ss xmm0, DWORD PTR _k$[ebp]
	mulss	xmm0, DWORD PTR __real@41b00000
	mulss	xmm0, DWORD PTR _lerpfrac$[ebp]
	addss	xmm0, DWORD PTR _l$[ebp]
	movss	DWORD PTR _l$[ebp], xmm0

; 91   : 
; 92   : 		tr.lightstylevalue[i] = (int)l * scale;

	cvttss2si eax, DWORD PTR _l$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[edx*4+87324], ecx

; 93   : 	}

	jmp	$LN2@CL_RunLigh
$LN3@CL_RunLigh:

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RunLightStyles ENDP
_TEXT	ENDS
END
