; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_pmove.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_ClipPMoveToEntity
PUBLIC	_CL_SetSolidEntities
PUBLIC	_CL_SetSolidPlayers
PUBLIC	_CL_InitClientMove
PUBLIC	_CL_PredictMovement
PUBLIC	_CL_CheckPredictionError
PUBLIC	_CL_IsPredicted
PUBLIC	_CL_TruePointContents
PUBLIC	_CL_WaterEntity
PUBLIC	_CL_GetWaterEntity
PUBLIC	_CL_SetupPMove
PUBLIC	_CL_TestLine
PUBLIC	_CL_VisTraceLine
PUBLIC	_CL_TraceLine
PUBLIC	_CL_PushTraceBounds
PUBLIC	_CL_PopTraceBounds
PUBLIC	_CL_MoveSpectatorCamera
PUBLIC	_CL_SetLastUpdate
PUBLIC	_CL_RedoPrediction
PUBLIC	_CL_ClearPhysEnts
PUBLIC	_CL_PushPMStates
PUBLIC	_CL_PopPMStates
PUBLIC	_CL_SetUpPlayerPrediction
PUBLIC	_CL_SetIdealPitch
PUBLIC	_CL_PlayerTeleported
PUBLIC	_CL_AddLinksToPmove
PUBLIC	_CL_FinishPMove
PUBLIC	_CL_RunUsercmd
PUBLIC	??_C@_0CD@HNDKBLNP@?$FO3player?5teleported?3?$FO7?5?$CF?43f?5uni@ ; `string'
PUBLIC	??_C@_0CC@CCPCEFNP@?$FO1prediction?5error?3?$FO7?5?$CF?43f?5unit@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_ClipPMoveToEntity@@9@9	; `CL_ClipPMoveToEntity'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@EDEEDIAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_09MEHKIDOB@player?5?$CFi@			; `string'
PUBLIC	??_C@_0DK@EEFEJKGH@CL?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@ ; `string'
PUBLIC	??_C@_03NKBOLEBK@0?41@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4059000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41400000
PUBLIC	__real@42800000
PUBLIC	__real@43200000
PUBLIC	__real@43b40000
PUBLIC	__real@447a0000
PUBLIC	__real@bdcccccd
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileSize:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_pfnGetModelBounds:PROC
EXTRN	_pfnGetModelType:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_Particle:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_sqrt:PROC
EXTRN	_SinCos:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_RankForContents:PROC
EXTRN	_CL_DemoInterpolateAngles:PROC
EXTRN	_CL_PlaybackEvent:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_ComputePlayerOrigin:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_Pmove_Init:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	_PM_RecursiveHullCheck:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_TestPlayerPosition:PROC
EXTRN	_PM_HullPointContents:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_PM_TestLineExt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtol3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memcpy:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_nopred:DWORD
EXTRN	_cl_showerror:DWORD
EXTRN	_cl_nosmooth:DWORD
EXTRN	_cl_smoothtime:DWORD
EXTRN	_cl_solid_players:DWORD
EXTRN	_cl_idealpitchscale:DWORD
EXTRN	_cl_lw:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?pos@?1??CL_CheckPredictionError@@9@9 DD 01H DUP (?)	; `CL_CheckPredictionError'::`2'::pos
?tr@?1??CL_VisTraceLine@@9@9 DB 044H DUP (?)		; `CL_VisTraceLine'::`2'::tr
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?tr@?1??pfnTraceLineEx@@9@9 DB 044H DUP (?)		; `pfnTraceLineEx'::`2'::tr
_BSS	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43200000
CONST	SEGMENT
__real@43200000 DD 043200000r			; 160
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_03NKBOLEBK@0?41@
CONST	SEGMENT
??_C@_03NKBOLEBK@0?41@ DB '0.1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EEFEJKGH@CL?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@
CONST	SEGMENT
??_C@_0DK@EEFEJKGH@CL?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@ DB 'C'
	DB	'L: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEHKIDOB@player?5?$CFi@
CONST	SEGMENT
??_C@_09MEHKIDOB@player?5?$CFi@ DB 'player %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@ DB 'tr != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EDEEDIAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@EDEEDIAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_pmove.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ClipPMoveToEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ClipPMoveToEntity@@9@9 DD 014bH	; `CL_ClipPMoveToEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CC@CCPCEFNP@?$FO1prediction?5error?3?$FO7?5?$CF?43f?5unit@
CONST	SEGMENT
??_C@_0CC@CCPCEFNP@?$FO1prediction?5error?3?$FO7?5?$CF?43f?5unit@ DB '^1p'
	DB	'rediction error:^7 %.3f units', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HNDKBLNP@?$FO3player?5teleported?3?$FO7?5?$CF?43f?5uni@
CONST	SEGMENT
??_C@_0CD@HNDKBLNP@?$FO3player?5teleported?3?$FO7?5?$CF?43f?5uni@ DB '^3p'
	DB	'layer teleported:^7 %.3f units', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01ebH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0408H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0155H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	09dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0231H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0278H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03bcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01208H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_RunUsercmd
_TEXT	SEGMENT
_split$ = -9840						; size = 56
_temp$ = -9784						; size = 9724
_cmd$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_u$ = 16						; size = 4
_runfuncs$ = 20						; size = 4
_time$ = 24						; size = 4
_random_seed$ = 28					; size = 4
_CL_RunUsercmd PROC					; COMDAT

; 1154 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 10352				; 00002870H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1155 : 	usercmd_t		cmd;
; 1156 : 	local_state_t	temp;
; 1157 : 	usercmd_t		split;
; 1158 : 
; 1159 : 	memset( &temp, 0, sizeof( temp ));

	push	9724					; 000025fcH
	push	0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1160 : 
; 1161 : 	if( u->msec > 50 )

	mov	eax, DWORD PTR _u$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 50					; 00000032H
	jle	$LN2@CL_RunUser

; 1162 : 	{
; 1163 : 		split = *u;

	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR _u$[ebp]
	lea	edi, DWORD PTR _split$[ebp]
	rep movsd

; 1164 : 		split.msec /= 2;

	movzx	eax, BYTE PTR _split$[ebp+2]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _split$[ebp+2], al

; 1165 : 		CL_RunUsercmd( from, &temp, &split, runfuncs, time, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	lea	eax, DWORD PTR _split$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1166 : 		split.impulse = split.weaponselect = 0;

	mov	BYTE PTR _split$[ebp+37], 0
	mov	al, BYTE PTR _split$[ebp+37]
	mov	BYTE PTR _split$[ebp+36], al

; 1167 : 		CL_RunUsercmd( &temp, to, &split, runfuncs, time, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	lea	eax, DWORD PTR _split$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1168 : 		return;

	jmp	$LN1@CL_RunUser
$LN2@CL_RunUser:

; 1169 : 	}
; 1170 : 
; 1171 : 	cmd = *u;	// deal with local copy

	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR _u$[ebp]
	lea	edi, DWORD PTR _cmd$[ebp]
	rep movsd

; 1172 : 	*to = *from;

	push	9724					; 000025fcH
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1173 : 
; 1174 : 	if( CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	je	$LN5@CL_RunUser

; 1175 : 	{
; 1176 : 		// setup playermove state
; 1177 : 		CL_SetupPMove( clgame.pmove, from, &cmd, runfuncs, *time );

	mov	eax, DWORD PTR _time$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _runfuncs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	call	_CL_SetupPMove
	add	esp, 24					; 00000018H

; 1178 : 
; 1179 : 		// motor!
; 1180 : 		clgame.dllFuncs.pfnPlayerMove( clgame.pmove, false );

	push	0
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	call	DWORD PTR _clgame+28
	add	esp, 8

; 1181 : 
; 1182 : 		// copy results back to client
; 1183 : 		CL_FinishPMove( clgame.pmove, to );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	call	_CL_FinishPMove
	add	esp, 8

; 1184 : 
; 1185 : 		if( clgame.pmove->onground > 0 && clgame.pmove->onground < clgame.pmove->numphysent )

	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+224], 0
	jle	SHORT $LN4@CL_RunUser
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [eax+224]
	cmp	edx, DWORD PTR [ecx+588]
	jge	SHORT $LN4@CL_RunUser

; 1186 : 			cl.local.lastground = clgame.pmove->physents[clgame.pmove->onground].info;

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+224], 224
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+ecx+672]
	mov	DWORD PTR _cl+2212624, eax
	jmp	SHORT $LN5@CL_RunUser
$LN4@CL_RunUser:

; 1187 : 		else cl.local.lastground = clgame.pmove->onground; // world(0) or in air(-1)

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+224]
	mov	DWORD PTR _cl+2212624, ecx
$LN5@CL_RunUser:

; 1188 : 	}
; 1189 : 
; 1190 : 	clgame.dllFuncs.pfnPostRunCmd( from, to, &cmd, runfuncs, *time, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	call	DWORD PTR _clgame+104
	add	esp, 28					; 0000001cH

; 1191 : 
; 1192 : 	*time += (double)cmd.msec / 1000.0;

	movzx	eax, BYTE PTR _cmd$[ebp+2]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mov	ecx, DWORD PTR _time$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _time$[ebp]
	movsd	QWORD PTR [edx], xmm0
$LN1@CL_RunUser:

; 1193 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RunUsercmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_FinishPMove
_TEXT	SEGMENT
_cd$ = -8						; size = 4
_ps$ = -4						; size = 4
_pmove$ = 8						; size = 4
_to$ = 12						; size = 4
_CL_FinishPMove PROC					; COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1102 : 	entity_state_t	*ps;
; 1103 : 	clientdata_t	*cd;
; 1104 : 
; 1105 : 	ps = &to->playerstate;

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _ps$[ebp], eax

; 1106 : 	cd = &to->client;

	mov	eax, DWORD PTR _to$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _cd$[ebp], eax

; 1107 : 
; 1108 : 	cd->flags = pmove->flags;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+44], edx

; 1109 : 	cd->bInDuck = pmove->bInDuck;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+140], edx

; 1110 : 	cd->flTimeStepSound = pmove->flTimeStepSound;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+148], edx

; 1111 : 	cd->flDuckTime = pmove->flDuckTime;

	mov	eax, DWORD PTR _pmove$[ebp]
	cvttss2si ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [edx+152], ecx

; 1112 : 	cd->flSwimTime = (int)pmove->flSwimTime;

	mov	eax, DWORD PTR _pmove$[ebp]
	cvttss2si ecx, DWORD PTR [eax+172]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [edx+156], ecx

; 1113 : 	cd->waterjumptime = (int)pmove->waterjumptime;

	mov	eax, DWORD PTR _pmove$[ebp]
	cvttss2si ecx, DWORD PTR [eax+204]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [edx+160], ecx

; 1114 : 	cd->watertype = pmove->watertype;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	DWORD PTR [eax+52], edx

; 1115 : 	cd->waterlevel = pmove->waterlevel;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+48], edx

; 1116 : 	cd->maxspeed = pmove->clientmaxspeed;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR [eax+164], edx

; 1117 : 	cd->deadflag = pmove->deadflag;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+212]
	mov	DWORD PTR [eax+228], edx

; 1118 : 	VectorCopy( pmove->velocity, cd->velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [ecx+eax+12], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+12], eax

; 1119 : 	VectorCopy( pmove->view_ofs, cd->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+128]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+128]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+128]
	mov	DWORD PTR [edx+ecx+56], eax

; 1120 : 	VectorCopy( pmove->origin, ps->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [edx+ecx+16], eax

; 1121 : 	VectorCopy( pmove->angles, ps->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [edx+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [edx+ecx+28], eax

; 1122 : 	VectorCopy( pmove->basevelocity, ps->basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+116]
	mov	DWORD PTR [edx+eax+300], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+116]
	mov	DWORD PTR [ecx+eax+300], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+116]
	mov	DWORD PTR [edx+ecx+300], eax

; 1123 : 	VectorCopy( pmove->punchangle, cd->punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+32], eax

; 1124 : 	ps->oldbuttons = pmove->oldbuttons;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR [eax+316], edx

; 1125 : 	ps->friction = pmove->friction;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+196], edx

; 1126 : 	ps->movetype = pmove->movetype;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR [eax+88], edx

; 1127 : 	ps->onground = pmove->onground;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR [eax+320], edx

; 1128 : 	ps->effects = pmove->effects;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+60], edx

; 1129 : 	ps->usehull = pmove->usehull;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR [eax+312], edx

; 1130 : 	ps->iStepLeft = pmove->iStepLeft;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+324], edx

; 1131 : 	ps->flFallVelocity = pmove->flFallVelocity;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	DWORD PTR [eax+328], edx

; 1132 : 	cd->iuser1 = pmove->iuser1;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	mov	DWORD PTR [eax+488], edx

; 1133 : 	cd->iuser2 = pmove->iuser2;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	mov	DWORD PTR [eax+492], edx

; 1134 : 	cd->iuser3 = pmove->iuser3;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [eax+496], edx

; 1135 : 	cd->iuser4 = pmove->iuser4;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+520]
	mov	DWORD PTR [eax+500], edx

; 1136 : 	cd->fuser1 = pmove->fuser1;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+524]
	mov	DWORD PTR [eax+504], edx

; 1137 : 	cd->fuser2 = pmove->fuser2;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+528]
	mov	DWORD PTR [eax+508], edx

; 1138 : 	cd->fuser3 = pmove->fuser3;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	DWORD PTR [eax+512], edx

; 1139 : 	cd->fuser4 = pmove->fuser4;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR [eax+516], edx

; 1140 : 	VectorCopy( pmove->vuser1, cd->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+540]
	mov	DWORD PTR [edx+eax+520], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+540]
	mov	DWORD PTR [ecx+eax+520], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+540]
	mov	DWORD PTR [edx+ecx+520], eax

; 1141 : 	VectorCopy( pmove->vuser2, cd->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+552]
	mov	DWORD PTR [edx+eax+532], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+552]
	mov	DWORD PTR [ecx+eax+532], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+552]
	mov	DWORD PTR [edx+ecx+532], eax

; 1142 : 	VectorCopy( pmove->vuser3, cd->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+564]
	mov	DWORD PTR [edx+eax+544], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+564]
	mov	DWORD PTR [ecx+eax+544], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+564]
	mov	DWORD PTR [edx+ecx+544], eax

; 1143 : 	VectorCopy( pmove->vuser4, cd->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+576]
	mov	DWORD PTR [edx+eax+556], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+576]
	mov	DWORD PTR [ecx+eax+556], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+576]
	mov	DWORD PTR [edx+ecx+556], eax

; 1144 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FinishPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTraceSurface
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC					; COMDAT

; 953  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 954  : 	physent_t *pe;
; 955  : 
; 956  : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 957  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 958  : 
; 959  : 	pe = &clgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 960  : 	return PM_TraceSurface( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 961  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTraceLineEx
_TEXT	SEGMENT
tv66 = -208						; size = 4
$T1 = -204						; size = 68
$T2 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_pmFilter$ = 24						; size = 4
_pfnTraceLineEx PROC					; COMDAT

; 930  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 931  : 	static pmtrace_t	tr;
; 932  : 	int		old_usehull;
; 933  : 
; 934  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 935  : 	clgame.pmove->usehull = usehull;	

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 936  : 
; 937  : 	switch( flags )

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 938  : 	{
; 939  : 	case PM_TRACELINE_PHYSENTSONLY:
; 940  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd

; 941  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 942  : 	case PM_TRACELINE_ANYVISIBLE:
; 943  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 149336				; 00024758H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+149332]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 944  : 		break;
; 945  : 	}
; 946  : 
; 947  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 948  : 
; 949  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLineEx@@9@9

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLineEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTestPlayerPositionEx
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pmFilter$ = 16						; size = 4
_pfnTestPlayerPositionEx PROC				; COMDAT

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 926  : 	return PM_TestPlayerPosition( clgame.pmove, pos, ptrace, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptrace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 927  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTestPlayerPositionEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnPlayerTraceEx
_TEXT	SEGMENT
$T1 = -132						; size = 68
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_pmFilter$ = 24						; size = 4
_pfnPlayerTraceEx PROC					; COMDAT

; 920  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 921  : 	return PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 922  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTraceEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnPlaybackEventFull
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_clientindex$ = 12					; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_vparam1$ = 56						; size = 4
_vparam2$ = 60						; size = 4
_aparam1$ = 64						; size = 4
_aparam2$ = 68						; size = 4
_aparam3$ = 72						; size = 1
_pfnPlaybackEventFull PROC				; COMDAT

; 914  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 915  : 	CL_PlaybackEvent(flags, NULL, eventindex, delay, origin, angles, fparam1, fparam2, iparam1, iparam2, bparam1, bparam2, vparam1, vparam2, aparam1, aparam2, aparam3);

	movzx	eax, BYTE PTR _aparam3$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _aparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aparam1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vparam2$[ebp]
	push	edx
	mov	eax, DWORD PTR _vparam1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bparam2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bparam1$[ebp]
	push	edx
	mov	eax, DWORD PTR _iparam2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iparam1$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _eventindex$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	call	_CL_PlaybackEvent
	add	esp, 68					; 00000044H

; 916  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnPlaySound
_TEXT	SEGMENT
_channel$ = 8						; size = 4
_sample$ = 12						; size = 4
_volume$ = 16						; size = 4
_attenuation$ = 20					; size = 4
_fFlags$ = 24						; size = 4
_pitch$ = 28						; size = 4
_pfnPlaySound PROC					; COMDAT

; 905  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 906  : 	if( !clgame.pmove->runfuncs )

	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+325044], 0
	jne	SHORT $LN2@pfnPlaySou

; 907  : 		return;

	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 908  : 
; 909  : 	S_StartSound( NULL, clgame.pmove->player_index + 1, channel, S_RegisterSound( sample ), volume, attenuation, pitch, fFlags );

	mov	eax, DWORD PTR _fFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attenuation$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	push	edx
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@pfnPlaySou:

; 910  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTraceTexture
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC					; COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 895  : 	physent_t *pe;
; 896  : 
; 897  : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 898  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 899  : 
; 900  : 	pe = &clgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 901  : 	return PM_TraceTexture( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 902  : }			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTraceModel
_TEXT	SEGMENT
tv248 = -196						; size = 4
tv170 = -196						; size = 4
tv149 = -196						; size = 4
_hull$ = -128						; size = 4
_matrix$ = -124						; size = 64
_rotated$ = -60						; size = 4
_temp$ = -56						; size = 12
_offset$ = -44						; size = 12
_end_l$ = -32						; size = 12
_start_l$ = -20						; size = 12
_old_usehull$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_trace$ = 20						; size = 4
_pfnTraceModel PROC					; COMDAT

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 849  : 	int	old_usehull;
; 850  : 	vec3_t	start_l, end_l;
; 851  : 	vec3_t	offset, temp;
; 852  : 	qboolean	rotated;
; 853  : 	matrix4x4	matrix;
; 854  : 	hull_t	*hull;
; 855  : 
; 856  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 857  : 	clgame.pmove->usehull = 2;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+188], 2

; 858  : 
; 859  : 	hull = PM_HullForBsp( pe, clgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 860  : 
; 861  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 862  : 
; 863  : 	if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	SHORT $LN2@pfnTraceMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@pfnTraceMo
$LN4@pfnTraceMo:

; 864  : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN3@pfnTraceMo
$LN2@pfnTraceMo:

; 865  : 	else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN3@pfnTraceMo:

; 866  : 
; 867  :  	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN5@pfnTraceMo

; 868  :  	{
; 869  :  		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 870  :  		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 871  :  		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 872  :  	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 873  :  	else
; 874  :  	{
; 875  :  		VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv149[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 876  :  		VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN6@pfnTraceMo:

; 877  :  	}
; 878  : 
; 879  : 	PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, (pmtrace_t *)trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 880  : 	trace->ent = NULL;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+48], 0

; 881  : 
; 882  : 	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN7@pfnTraceMo

; 883  : 	{
; 884  : 		VectorCopy( trace->plane.normal, temp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR _temp$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], eax

; 885  : 		Matrix4x4_TransformPositivePlane( matrix, temp, trace->plane.dist, trace->plane.normal, &trace->plane.dist );

	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _trace$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H
$LN7@pfnTraceMo:

; 886  : 	}
; 887  : 
; 888  : 	VectorLerp( start, trace->fraction, end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv248[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv248[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 889  : 
; 890  : 	return trace->fraction;

	mov	eax, DWORD PTR _trace$[ebp]
	fld	DWORD PTR [eax+16]

; 891  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnHullForBsp
_TEXT	SEGMENT
_pe$ = 8						; size = 4
_offset$ = 12						; size = 4
_pfnHullForBsp PROC					; COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 844  : 	return PM_HullForBsp( pe, clgame.pmove, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTraceLine
_TEXT	SEGMENT
tv66 = -208						; size = 4
$T1 = -204						; size = 68
$T2 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC					; COMDAT

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 821  : 	static pmtrace_t	tr;
; 822  : 	int		old_usehull;
; 823  : 
; 824  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 825  : 	clgame.pmove->usehull = usehull;	

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 826  : 
; 827  : 	switch( flags )

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 828  : 	{
; 829  : 	case PM_TRACELINE_PHYSENTSONLY:
; 830  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 831  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 832  : 	case PM_TRACELINE_ANYVISIBLE:
; 833  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 149336				; 00024758H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+149332]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 834  : 		break;
; 835  : 	}
; 836  : 
; 837  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 838  : 
; 839  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 840  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnPlayerTrace
_TEXT	SEGMENT
$T1 = -132						; size = 68
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_ignore_pe$ = 24					; size = 4
_pfnPlayerTrace PROC					; COMDAT

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 816  : 	return PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnHullPointContents
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_pfnHullPointContents PROC				; COMDAT

; 810  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 811  : 	return PM_HullPointContents( hull, num, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH

; 812  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTruePointContents
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pfnTruePointContents PROC				; COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 806  : 	return CL_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_TruePointContents
	add	esp, 4

; 807  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnPointContents
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC					; COMDAT

; 793  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 794  : 	int	cont, truecont;
; 795  : 
; 796  : 	truecont = cont = CL_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_TruePointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], ecx

; 797  : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 798  : 
; 799  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 800  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 801  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnStuckTouch
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hitent$ = 8						; size = 4
_tr$ = 12						; size = 4
_pfnStuckTouch PROC					; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 775  : 	int	i;
; 776  : 
; 777  : 	for( i = 0; i < clgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnStuckTo
$LN2@pfnStuckTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnStuckTo:
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+283792]
	jge	SHORT $LN3@pfnStuckTo

; 778  : 	{
; 779  : 		if( clgame.pmove->touchindex[i].ent == hitent )

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [ecx+eax+283844]
	cmp	edx, DWORD PTR _hitent$[ebp]
	jne	SHORT $LN5@pfnStuckTo

; 780  : 			return;

	jmp	$LN1@pfnStuckTo
$LN5@pfnStuckTo:

; 781  : 	}

	jmp	SHORT $LN2@pfnStuckTo
$LN3@pfnStuckTo:

; 782  : 
; 783  : 	if( clgame.pmove->numtouch >= MAX_PHYSENTS )

	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+283792], 600		; 00000258H
	jl	SHORT $LN6@pfnStuckTo

; 784  : 		return;

	jmp	$LN1@pfnStuckTo
$LN6@pfnStuckTo:

; 785  : 
; 786  : 	VectorCopy( clgame.pmove->velocity, tr->deltavelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [edx+eax+52], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [ecx+eax+52], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+52], eax

; 787  : 	tr->ent = hitent;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	ecx, DWORD PTR _hitent$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 788  : 
; 789  : 	clgame.pmove->touchindex[clgame.pmove->numtouch++] = *tr;

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+283792], 68
	mov	edx, DWORD PTR _clgame+1344
	lea	edi, DWORD PTR [edx+ecx+283796]
	mov	ecx, 17					; 00000011H
	mov	esi, DWORD PTR _tr$[ebp]
	rep movsd
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+283792]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1344
	mov	DWORD PTR [edx+283792], ecx
$LN1@pfnStuckTo:

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStuckTouch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _pfnTestPlayerPosition
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pfnTestPlayerPosition PROC				; COMDAT

; 769  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 770  : 	return PM_TestPlayerPosition( clgame.pmove, pos, ptrace, NULL );

	push	0
	mov	eax, DWORD PTR _ptrace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	push	edx
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_AddLinksToPmove
_TEXT	SEGMENT
_i$ = -16						; size = 4
_pe$ = -12						; size = 4
_model$ = -8						; size = 4
_state$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_AddLinksToPmove PROC				; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 434  : 	entity_state_t	*state;
; 435  : 	model_t		*model;
; 436  : 	physent_t		*pe;
; 437  : 	int		i;
; 438  : 
; 439  : 	if( !frame->valid ) return;

	mov	eax, DWORD PTR _frame$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@CL_AddLink
	jmp	$LN3@CL_AddLink
$LN5@CL_AddLink:

; 440  : 
; 441  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_AddLink
$LN2@CL_AddLink:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_AddLink:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jge	$LN3@CL_AddLink

; 442  : 	{
; 443  : 		state = &cls.packet_entities[(frame->first_entity + i) % cls.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], ecx

; 444  : 
; 445  : 		if( state->number >= 1 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN6@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _cl+2213004
	jg	SHORT $LN6@CL_AddLink

; 446  : 			continue;

	jmp	SHORT $LN2@CL_AddLink
$LN6@CL_AddLink:

; 447  : 
; 448  : 		if( !state->modelindex )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN7@CL_AddLink

; 449  : 			continue;

	jmp	SHORT $LN2@CL_AddLink
$LN7@CL_AddLink:

; 450  : 
; 451  : 		model = CL_ModelHandle( state->modelindex );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 452  : 		if( !model ) continue;

	cmp	DWORD PTR _model$[ebp], 0
	jne	SHORT $LN8@CL_AddLink
	jmp	SHORT $LN2@CL_AddLink
$LN8@CL_AddLink:

; 453  : 
; 454  : 		if(( state->owner != 0 ) && ( state->owner == cl.playernum + 1 ))

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+192], 0
	je	SHORT $LN9@CL_AddLink
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+192], eax
	jne	SHORT $LN9@CL_AddLink

; 455  : 			continue;

	jmp	$LN2@CL_AddLink
$LN9@CL_AddLink:

; 456  : 
; 457  : 		if(( model->hulls[1].lastclipnode || model->type == mod_studio ) && clgame.pmove->numvisent < MAX_PHYSENTS )

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+eax+220], 0
	jne	SHORT $LN11@CL_AddLink
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN10@CL_AddLink
$LN11@CL_AddLink:
	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+149332], 600		; 00000258H
	jge	SHORT $LN10@CL_AddLink

; 458  : 		{
; 459  : 			pe = &clgame.pmove->visents[clgame.pmove->numvisent];

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+149332], 224
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+149336]
	mov	DWORD PTR _pe$[ebp], eax

; 460  : 			CL_CopyEntityToPhysEnt( pe, state, true );

	push	1
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 461  : 			clgame.pmove->numvisent++;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+149332]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1344
	mov	DWORD PTR [edx+149332], ecx
$LN10@CL_AddLink:

; 462  : 		}
; 463  : 
; 464  : 		if( state->solid == SOLID_TRIGGER || ( state->solid == SOLID_NOT && state->skin >= CONTENTS_EMPTY ))

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	cmp	ecx, 1
	je	SHORT $LN13@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	test	ecx, ecx
	jne	SHORT $LN12@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+136], -1
	jl	SHORT $LN12@CL_AddLink
$LN13@CL_AddLink:

; 465  : 			continue;

	jmp	$LN2@CL_AddLink
$LN12@CL_AddLink:

; 466  : 
; 467  : 		// dead body
; 468  : 		if( state->mins[2] == 0.0f && state->maxs[2] == 1.0f )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+164]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_AddLink
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+176]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_AddLink

; 469  : 			continue;

	jmp	$LN2@CL_AddLink
$LN14@CL_AddLink:

; 470  : 
; 471  : 		// can't collide with zeroed hull
; 472  : 		if( VectorIsNull( state->mins ) && VectorIsNull( state->maxs ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+164]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN15@CL_AddLink
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+164]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN15@CL_AddLink
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+164]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+176]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+176]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+176]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink

; 473  : 			continue;

	jmp	$LN2@CL_AddLink
$LN15@CL_AddLink:

; 474  : 
; 475  : 		if( state->solid == SOLID_NOT && state->skin < CONTENTS_EMPTY )

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	test	ecx, ecx
	jne	SHORT $LN16@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+136], -1
	jge	SHORT $LN16@CL_AddLink

; 476  : 		{
; 477  : 			if( clgame.pmove->nummoveent >= MAX_MOVEENTS )

	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+134992], 64		; 00000040H
	jl	SHORT $LN18@CL_AddLink

; 478  : 				continue;

	jmp	$LN2@CL_AddLink
$LN18@CL_AddLink:

; 479  : 
; 480  : 			pe = &clgame.pmove->moveents[clgame.pmove->nummoveent];

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+134992], 224
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+134996]
	mov	DWORD PTR _pe$[ebp], eax

; 481  : 			CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 482  : 			clgame.pmove->nummoveent++;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+134992]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1344
	mov	DWORD PTR [edx+134992], ecx

; 483  : 		}

	jmp	$LN17@CL_AddLink
$LN16@CL_AddLink:

; 484  : 		else
; 485  : 		{
; 486  : 			if( !model->hulls[1].lastclipnode && model->type != mod_studio )

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+eax+220], 0
	jne	SHORT $LN19@CL_AddLink
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 3
	je	SHORT $LN19@CL_AddLink

; 487  : 				continue;

	jmp	$LN2@CL_AddLink
$LN19@CL_AddLink:

; 488  : 
; 489  : 			// reserve slots for all the clients
; 490  : 			if( clgame.pmove->numphysent >= ( MAX_PHYSENTS - cl.maxclients ))

	mov	eax, 600				; 00000258H
	sub	eax, DWORD PTR _cl+2213004
	mov	ecx, DWORD PTR _clgame+1344
	cmp	DWORD PTR [ecx+588], eax
	jl	SHORT $LN20@CL_AddLink

; 491  : 				continue;

	jmp	$LN2@CL_AddLink
$LN20@CL_AddLink:

; 492  : 
; 493  : 			pe = &clgame.pmove->physents[clgame.pmove->numphysent];

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+588], 224
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+592]
	mov	DWORD PTR _pe$[ebp], eax

; 494  : 			CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 495  : 			clgame.pmove->numphysent++;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1344
	mov	DWORD PTR [edx+588], ecx
$LN17@CL_AddLink:

; 496  : 		}
; 497  : 	}

	jmp	$LN2@CL_AddLink
$LN3@CL_AddLink:

; 498  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddLinksToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_CopyEntityToPhysEnt
_TEXT	SEGMENT
tv293 = -72						; size = 4
_mod$ = -4						; size = 4
_pe$ = 8						; size = 4
_state$ = 12						; size = 4
_visent$ = 16						; size = 4
_CL_CopyEntityToPhysEnt PROC				; COMDAT

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 348  : 	model_t	*mod = CL_ModelHandle( state->modelindex );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 349  : 
; 350  : 	pe->player = 0;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+32], 0

; 351  : 
; 352  : 	if( state->number >= 1 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN2@CL_CopyEnt
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _cl+2213004
	jg	SHORT $LN2@CL_CopyEnt

; 353  : 		pe->player = state->number;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+32], edx
$LN2@CL_CopyEnt:

; 354  : 
; 355  : 	if( pe->player )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@CL_CopyEnt

; 356  : 	{
; 357  : 		// client or bot
; 358  : 		Q_snprintf( pe->name, sizeof( pe->name ), "player %i", pe->player - 1 );

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sub	ecx, 1
	push	ecx
	push	OFFSET ??_C@_09MEHKIDOB@player?5?$CFi@
	push	32					; 00000020H
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 359  : 	}

	jmp	SHORT $LN4@CL_CopyEnt
$LN3@CL_CopyEnt:

; 360  : 	else
; 361  : 	{
; 362  : 		// otherwise copy the modelname
; 363  : 		Q_strncpy( pe->name, mod->name, sizeof( pe->name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN4@CL_CopyEnt:

; 364  : 	}
; 365  : 
; 366  : 	pe->model = pe->studiomodel = NULL;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 367  : 
; 368  : 	VectorCopy( state->mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+164]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+164]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+164]
	mov	DWORD PTR [edx+ecx+56], eax

; 369  : 	VectorCopy( state->maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+176]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+176]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+176]
	mov	DWORD PTR [edx+ecx+68], eax

; 370  : 
; 371  : 	if( state->solid == SOLID_BBOX )

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	cmp	ecx, 2
	jne	SHORT $LN5@CL_CopyEnt

; 372  : 	{
; 373  : 		if( FBitSet( mod->flags, STUDIO_TRACE_HITBOX ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 512				; 00000200H
	je	SHORT $LN7@CL_CopyEnt

; 374  : 			pe->studiomodel = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN7@CL_CopyEnt:

; 375  : 	}

	jmp	SHORT $LN9@CL_CopyEnt
$LN5@CL_CopyEnt:

; 376  : 	else
; 377  : 	{
; 378  : 		if( pe->solid != SOLID_BSP && ( mod != NULL ) && ( mod->type == mod_studio ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	je	SHORT $LN8@CL_CopyEnt
	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN8@CL_CopyEnt
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN8@CL_CopyEnt

; 379  : 			pe->studiomodel = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+52], ecx
	jmp	SHORT $LN9@CL_CopyEnt
$LN8@CL_CopyEnt:

; 380  : 		else pe->model = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+48], ecx
$LN9@CL_CopyEnt:

; 381  : 	}
; 382  : 
; 383  : 	// rare case: not solid entities in vistrace
; 384  : 	if( visent && VectorIsNull( pe->mins ))

	cmp	DWORD PTR _visent$[ebp], 0
	je	$LN10@CL_CopyEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt

; 385  : 	{
; 386  : 		VectorCopy( mod->mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+84]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+84]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+84]
	mov	DWORD PTR [edx+ecx+56], eax

; 387  : 		VectorCopy( mod->maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+96]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+96]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+96]
	mov	DWORD PTR [edx+ecx+68], eax
$LN10@CL_CopyEnt:

; 388  : 	}
; 389  : 
; 390  : 	pe->info = state->number;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+80], edx

; 391  : 	VectorCopy( state->origin, pe->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+36], eax

; 392  : 	VectorCopy( state->angles, pe->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+84], eax

; 393  : 
; 394  : 	pe->solid = state->solid;

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 395  : 	pe->rendermode = state->rendermode;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+104], edx

; 396  : 	pe->skin = state->skin;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+100], edx

; 397  : 	pe->frame = state->frame;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+108], edx

; 398  : 	pe->sequence = state->sequence;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+112], edx

; 399  : 
; 400  : 	memcpy( &pe->controller[0], &state->controller[0], sizeof( pe->controller ));

	push	4
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+100]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	lea	ecx, DWORD PTR [eax+edx+116]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 401  : 	memcpy( &pe->blending[0], &state->blending[0], sizeof( pe->blending ));

	push	2
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+104]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	lea	ecx, DWORD PTR [eax+edx+120]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 402  : 
; 403  : 	pe->movetype = state->movetype;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+124], edx

; 404  : 	pe->takedamage = (pe->player) ? DAMAGE_YES : DAMAGE_NO;

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN12@CL_CopyEnt
	mov	DWORD PTR tv293[ebp], 1
	jmp	SHORT $LN13@CL_CopyEnt
$LN12@CL_CopyEnt:
	mov	DWORD PTR tv293[ebp], 0
$LN13@CL_CopyEnt:
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR tv293[ebp]
	mov	DWORD PTR [ecx+128], edx

; 405  : 	pe->team = state->team;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+136], edx

; 406  : 	pe->classnumber = state->playerclass;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	mov	DWORD PTR [eax+140], edx

; 407  : 	pe->blooddecal = 0;	// unused in GoldSrc

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+132], 0

; 408  : 
; 409  : 	// for mods
; 410  : 	pe->iuser1 = state->iuser1;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+372]
	mov	DWORD PTR [eax+144], edx

; 411  : 	pe->iuser2 = state->iuser2;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+376]
	mov	DWORD PTR [eax+148], edx

; 412  : 	pe->iuser3 = state->iuser3;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+380]
	mov	DWORD PTR [eax+152], edx

; 413  : 	pe->iuser4 = state->iuser4;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+384]
	mov	DWORD PTR [eax+156], edx

; 414  : 	pe->fuser1 = state->fuser1;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR [eax+160], edx

; 415  : 	pe->fuser2 = state->fuser2;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+164], edx

; 416  : 	pe->fuser3 = state->fuser3;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	DWORD PTR [eax+168], edx

; 417  : 	pe->fuser4 = state->fuser4;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+172], edx

; 418  : 
; 419  : 	VectorCopy( state->vuser1, pe->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+404]
	mov	DWORD PTR [edx+eax+176], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+404]
	mov	DWORD PTR [ecx+eax+176], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+404]
	mov	DWORD PTR [edx+ecx+176], eax

; 420  : 	VectorCopy( state->vuser2, pe->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+416]
	mov	DWORD PTR [edx+eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+416]
	mov	DWORD PTR [ecx+eax+188], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+416]
	mov	DWORD PTR [edx+ecx+188], eax

; 421  : 	VectorCopy( state->vuser3, pe->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+428]
	mov	DWORD PTR [edx+eax+200], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+428]
	mov	DWORD PTR [ecx+eax+200], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+428]
	mov	DWORD PTR [edx+ecx+200], eax

; 422  : 	VectorCopy( state->vuser4, pe->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+440]
	mov	DWORD PTR [edx+eax+212], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+440]
	mov	DWORD PTR [ecx+eax+212], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+440]
	mov	DWORD PTR [edx+ecx+212], eax

; 423  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CopyEntityToPhysEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PlayerTeleported
_TEXT	SEGMENT
tv151 = -92						; size = 4
tv90 = -92						; size = 4
_delta$ = -24						; size = 12
_maxlen$ = -12						; size = 4
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_CL_PlayerTeleported PROC				; COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 213  : 	int	len, maxlen;
; 214  : 	vec3_t	delta;
; 215  : 
; 216  : 	VectorSubtract( to->playerstate.origin, from->playerstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+16]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 217  : 
; 218  : 	// compute potential max movement in units per frame and compare with entity movement
; 219  : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1076
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvttsd2si eax, xmm0
	mov	DWORD PTR _maxlen$[ebp], eax

; 220  : 	len = VectorLength( delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _len$[ebp], eax

; 221  : 
; 222  : 	return (len > maxlen);

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _maxlen$[ebp]
	jle	SHORT $LN3@CL_PlayerT
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_PlayerT
$LN3@CL_PlayerT:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_PlayerT:
	mov	eax, DWORD PTR tv151[ebp]

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetIdealPitch
_TEXT	SEGMENT
$T1 = -284						; size = 68
_tr$ = -152						; size = 68
_bottom$ = -84						; size = 12
_top$ = -72						; size = 12
_z$ = -60						; size = 24
_steps$ = -36						; size = 4
_dir$ = -32						; size = 4
_step$ = -28						; size = 4
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_cosval$ = -16						; size = 4
_sinval$ = -12						; size = 4
_angleval$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_SetIdealPitch PROC					; COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 143  : 	float	angleval, sinval, cosval;
; 144  : 	int	i, j, step, dir, steps;
; 145  : 	float	z[MAX_FORWARD];
; 146  : 	vec3_t	top, bottom;
; 147  : 	pmtrace_t	tr;
; 148  : 
; 149  : 	if( cl.local.onground == -1 )

	cmp	DWORD PTR _cl+2212728, -1
	jne	SHORT $LN8@CL_SetIdea

; 150  : 		return;

	jmp	$LN1@CL_SetIdea
$LN8@CL_SetIdea:

; 151  : 
; 152  : 	angleval = cl.viewangles[YAW] * M_PI2 / 360.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+2212784]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _angleval$[ebp], xmm0

; 153  : 	SinCos( angleval, &sinval, &cosval );

	lea	eax, DWORD PTR _cosval$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sinval$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angleval$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 154  : 
; 155  : 	// Now move forward by 36, 48, 60, etc. units from the eye position and drop lines straight down
; 156  : 	// 160 or so units to see what's below
; 157  : 	for( i = 0; i < MAX_FORWARD; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetIdea
$LN2@CL_SetIdea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetIdea:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@CL_SetIdea

; 158  : 	{
; 159  : 		top[0] = cl.simorg[0] + cosval * (i + 3.0f) * 12.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _cosval$[ebp]
	mulss	xmm0, DWORD PTR __real@41400000
	addss	xmm0, DWORD PTR _cl[ecx+2212976]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _top$[ebp+eax], xmm0

; 160  : 		top[1] = cl.simorg[1] + sinval * (i + 3.0f) * 12.0f;

	mov	eax, 4
	shl	eax, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _sinval$[ebp]
	mulss	xmm0, DWORD PTR __real@41400000
	addss	xmm0, DWORD PTR _cl[eax+2212976]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _top$[ebp+ecx], xmm0

; 161  : 		top[2] = cl.simorg[2] + cl.viewheight[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _cl[eax+2212976]
	addss	xmm0, DWORD PTR _cl[ecx+2212796]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _top$[ebp+edx], xmm0

; 162  : 		
; 163  : 		bottom[0] = top[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _top$[ebp+ecx]
	mov	DWORD PTR _bottom$[ebp+eax], ecx

; 164  : 		bottom[1] = top[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _top$[ebp+eax]
	mov	DWORD PTR _bottom$[ebp+ecx], edx

; 165  : 		bottom[2] = top[2] - 160.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _top$[ebp+eax]
	subss	xmm0, DWORD PTR __real@43200000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _bottom$[ebp+ecx], xmm0

; 166  : 
; 167  : 		// skip any monsters (only world and brush models)
; 168  : 		tr = CL_TraceLine( top, bottom, PM_STUDIO_BOX );

	push	2
	lea	eax, DWORD PTR _bottom$[ebp]
	push	eax
	lea	ecx, DWORD PTR _top$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 169  : 		if( tr.allsolid ) return; // looking at a wall, leave ideal the way is was

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN9@CL_SetIdea
	jmp	$LN1@CL_SetIdea
$LN9@CL_SetIdea:

; 170  : 
; 171  : 		if( tr.fraction == 1.0f )

	movss	xmm0, DWORD PTR _tr$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_SetIdea

; 172  : 			return;	// near a dropoff

	jmp	$LN1@CL_SetIdea
$LN10@CL_SetIdea:

; 173  : 		
; 174  : 		z[i] = top[2] + tr.fraction * (bottom[2] - top[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _bottom$[ebp+ecx]
	subss	xmm0, DWORD PTR _top$[ebp+edx]
	mulss	xmm0, DWORD PTR _tr$[ebp+16]
	addss	xmm0, DWORD PTR _top$[ebp+eax]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _z$[ebp+eax*4], xmm0

; 175  : 	}

	jmp	$LN2@CL_SetIdea
$LN3@CL_SetIdea:

; 176  : 	
; 177  : 	dir = 0;

	mov	DWORD PTR _dir$[ebp], 0

; 178  : 	steps = 0;

	mov	DWORD PTR _steps$[ebp], 0

; 179  : 
; 180  : 	for( j = 1; j < i; j++ )

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@CL_SetIdea
$LN5@CL_SetIdea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@CL_SetIdea:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	$LN6@CL_SetIdea

; 181  : 	{
; 182  : 		step = z[j] - z[j-1];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp+eax*4]
	subss	xmm0, DWORD PTR _z$[ebp+ecx*4-4]
	cvttss2si edx, xmm0
	mov	DWORD PTR _step$[ebp], edx

; 183  : 		if( step > -ON_EPSILON && step < ON_EPSILON )

	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jbe	SHORT $LN11@CL_SetIdea
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@CL_SetIdea

; 184  : 			continue;

	jmp	SHORT $LN5@CL_SetIdea
$LN11@CL_SetIdea:

; 185  : 
; 186  : 		if( dir && ( step-dir > ON_EPSILON || step-dir < -ON_EPSILON ))

	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN12@CL_SetIdea
	mov	eax, DWORD PTR _step$[ebp]
	sub	eax, DWORD PTR _dir$[ebp]
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR __real@3dcccccd
	ja	SHORT $LN13@CL_SetIdea
	mov	eax, DWORD PTR _step$[ebp]
	sub	eax, DWORD PTR _dir$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@bdcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@CL_SetIdea
$LN13@CL_SetIdea:

; 187  : 			return; // mixed changes

	jmp	SHORT $LN1@CL_SetIdea
$LN12@CL_SetIdea:

; 188  : 
; 189  : 		steps++;	

	mov	eax, DWORD PTR _steps$[ebp]
	add	eax, 1
	mov	DWORD PTR _steps$[ebp], eax

; 190  : 		dir = step;

	mov	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _dir$[ebp], eax

; 191  : 	}

	jmp	$LN5@CL_SetIdea
$LN6@CL_SetIdea:

; 192  : 	
; 193  : 	if( !dir )

	cmp	DWORD PTR _dir$[ebp], 0
	jne	SHORT $LN14@CL_SetIdea

; 194  : 	{
; 195  : 		cl.local.idealpitch = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+2212644, xmm0

; 196  : 		return;

	jmp	SHORT $LN1@CL_SetIdea
$LN14@CL_SetIdea:

; 197  : 	}
; 198  : 	
; 199  : 	if( steps < 2 ) return;

	cmp	DWORD PTR _steps$[ebp], 2
	jge	SHORT $LN15@CL_SetIdea
	jmp	SHORT $LN1@CL_SetIdea
$LN15@CL_SetIdea:

; 200  : 	cl.local.idealpitch = -dir * cl_idealpitchscale->value;

	mov	eax, DWORD PTR _dir$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _cl_idealpitchscale
	mulss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _cl+2212644, xmm0
$LN1@CL_SetIdea:

; 201  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetIdealPitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetUpPlayerPrediction
_TEXT	SEGMENT
_i$ = -16						; size = 4
_ent$ = -12						; size = 4
_player$ = -8						; size = 4
_state$ = -4						; size = 4
_dopred$ = 8						; size = 4
_bIncludeLocalClient$ = 12				; size = 4
_CL_SetUpPlayerPrediction PROC				; COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 285  : 	entity_state_t	*state;
; 286  : 	predicted_player_t	*player;
; 287  : 	cl_entity_t	*ent;
; 288  : 	int		i;
; 289  : 
; 290  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetUpPl
$LN2@CL_SetUpPl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetUpPl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_SetUpPl

; 291  : 	{
; 292  : 		state = &cl.frames[cl.parsecountmod].playerstate[i];

	imul	eax, DWORD PTR _cl+12, 24056
	imul	ecx, DWORD PTR _i$[ebp], 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	DWORD PTR _state$[ebp], edx

; 293  : 		player = &cls.predicted_players[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _cls+295016
	mov	DWORD PTR _player$[ebp], eax

; 294  : 
; 295  : 		player->active = false;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+12], 0

; 296  : 
; 297  : 		if( state->messagenum != cl.parsecount )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _cl+8
	je	SHORT $LN5@CL_SetUpPl

; 298  : 			continue; // not present this frame

	jmp	SHORT $LN2@CL_SetUpPl
$LN5@CL_SetUpPl:

; 299  : 
; 300  : 		if( !state->modelindex )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN6@CL_SetUpPl

; 301  : 			continue;

	jmp	SHORT $LN2@CL_SetUpPl
$LN6@CL_SetUpPl:

; 302  : 
; 303  : 		player->active = true;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+12], 1

; 304  : 		player->movetype = state->movetype;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax], edx

; 305  : 		player->solid = state->solid;

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 306  : 		player->usehull = state->usehull;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+8], edx

; 307  : 
; 308  : 		if( FBitSet( state->effects, EF_NODRAW ) && !bIncludeLocalClient && ( cl.playernum == i ))

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@CL_SetUpPl
	cmp	DWORD PTR _bIncludeLocalClient$[ebp], 0
	jne	SHORT $LN7@CL_SetUpPl
	mov	eax, DWORD PTR _cl+2213000
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN7@CL_SetUpPl

; 309  : 			continue;

	jmp	$LN2@CL_SetUpPl
$LN7@CL_SetUpPl:

; 310  : 
; 311  : 		// note that the local player is special, since he moves locally
; 312  : 		// we use his last predicted postition
; 313  : 		if( cl.playernum == i )

	mov	eax, DWORD PTR _cl+2213000
	cmp	eax, DWORD PTR _i$[ebp]
	jne	$LN8@CL_SetUpPl

; 314  : 		{
; 315  : 			VectorCopy( state->origin, player->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+16], eax

; 316  : 			VectorCopy( state->angles, player->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+28], eax

; 317  : 		}

	jmp	$LN9@CL_SetUpPl
$LN8@CL_SetUpPl:

; 318  : 		else
; 319  : 		{
; 320  : 			ent = CL_GetEntityByIndex( i + 1 );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 321  : 
; 322  : 			CL_ComputePlayerOrigin( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ComputePlayerOrigin
	add	esp, 4

; 323  : 
; 324  : 			VectorCopy( ent->origin, player->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+16], eax

; 325  : 			VectorCopy( ent->angles, player->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3236]
	mov	DWORD PTR [edx+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3236]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3236]
	mov	DWORD PTR [edx+ecx+28], eax
$LN9@CL_SetUpPl:

; 326  : 		}
; 327  : 	}

	jmp	$LN2@CL_SetUpPl
$LN3@CL_SetUpPl:

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetUpPlayerPrediction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PopPMStates
_TEXT	SEGMENT
_CL_PopPMStates PROC					; COMDAT

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 65   : 	if( !clgame.pushed ) return;

	cmp	DWORD PTR _clgame+1348, 0
	jne	SHORT $LN2@CL_PopPMSt
	jmp	SHORT $LN1@CL_PopPMSt
$LN2@CL_PopPMSt:

; 66   : 	clgame.pmove->numphysent = clgame.oldphyscount;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _clgame+1356
	mov	DWORD PTR [eax+588], ecx

; 67   : 	clgame.pmove->numvisent  = clgame.oldviscount;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _clgame+1352
	mov	DWORD PTR [eax+149332], ecx

; 68   : 	clgame.pushed = false;

	mov	DWORD PTR _clgame+1348, 0
$LN1@CL_PopPMSt:

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PopPMStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PushPMStates
_TEXT	SEGMENT
_CL_PushPMStates PROC					; COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 51   : 	if( clgame.pushed ) return;

	cmp	DWORD PTR _clgame+1348, 0
	je	SHORT $LN2@CL_PushPMS
	jmp	SHORT $LN1@CL_PushPMS
$LN2@CL_PushPMS:

; 52   : 	clgame.oldphyscount = clgame.pmove->numphysent;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR _clgame+1356, ecx

; 53   : 	clgame.oldviscount  = clgame.pmove->numvisent;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+149332]
	mov	DWORD PTR _clgame+1352, ecx

; 54   : 	clgame.pushed = true;

	mov	DWORD PTR _clgame+1348, 1
$LN1@CL_PushPMS:

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PushPMStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_ClearPhysEnts
_TEXT	SEGMENT
_CL_ClearPhysEnts PROC					; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	clgame.pmove->numtouch = 0;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+283792], 0

; 38   : 	clgame.pmove->numvisent = 0;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+149332], 0

; 39   : 	clgame.pmove->nummoveent = 0;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+134992], 0

; 40   : 	clgame.pmove->numphysent = 0;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+588], 0

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearPhysEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_RedoPrediction
_TEXT	SEGMENT
_CL_RedoPrediction PROC					; COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 129  : 	if ( cls.netchan.incoming_sequence != cls.lastupdate_sequence )

	mov	eax, DWORD PTR _cls+26864
	cmp	eax, DWORD PTR _cls+290596
	je	SHORT $LN1@CL_RedoPre

; 130  : 	{
; 131  : 		CL_PredictMovement( true );

	push	1
	call	_CL_PredictMovement
	add	esp, 4

; 132  : 		CL_CheckPredictionError();

	call	_CL_CheckPredictionError
$LN1@CL_RedoPre:

; 133  : 	}
; 134  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RedoPrediction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetLastUpdate
_TEXT	SEGMENT
_CL_SetLastUpdate PROC					; COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 119  : 	cls.lastupdate_sequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _cls+290596, eax

; 120  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetLastUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_MoveSpectatorCamera
_TEXT	SEGMENT
_time$ = -8						; size = 8
_CL_MoveSpectatorCamera PROC				; COMDAT

; 1204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1205 : 	double	time = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _time$[ebp], xmm0

; 1206 : 
; 1207 : 	if( !cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	jne	SHORT $LN2@CL_MoveSpe

; 1208 : 		return;

	jmp	$LN1@CL_MoveSpe
$LN2@CL_MoveSpe:

; 1209 : 
; 1210 : 	CL_SetUpPlayerPrediction( false, true );

	push	1
	push	0
	call	_CL_SetUpPlayerPrediction
	add	esp, 8

; 1211 : 	CL_SetSolidPlayers( cl.playernum );

	mov	eax, DWORD PTR _cl+2213000
	push	eax
	call	_CL_SetSolidPlayers
	add	esp, 4

; 1212 : 	CL_RunUsercmd( &cls.spectator_state, &cls.spectator_state, cl.cmd, true, &time, (uint)( time * 100.0 ));

	movsd	xmm0, QWORD PTR _time$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	call	__dtol3
	push	eax
	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _cl+2212776
	push	ecx
	push	OFFSET _cls+156
	push	OFFSET _cls+156
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1213 : 
; 1214 : 	VectorCopy( cls.spectator_state.client.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+620]
	mov	DWORD PTR _cl[eax+2212988], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+620]
	mov	DWORD PTR _cl[eax+2212988], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+620]
	mov	DWORD PTR _cl[eax+2212988], ecx

; 1215 : 	VectorCopy( cls.spectator_state.client.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+608]
	mov	DWORD PTR _cl[eax+2212976], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+608]
	mov	DWORD PTR _cl[eax+2212976], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+608]
	mov	DWORD PTR _cl[eax+2212976], ecx

; 1216 : 	VectorCopy( cls.spectator_state.client.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+640]
	mov	DWORD PTR _cl[eax+2212808], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+640]
	mov	DWORD PTR _cl[eax+2212808], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+640]
	mov	DWORD PTR _cl[eax+2212808], ecx

; 1217 : 	VectorCopy( cls.spectator_state.client.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+664]
	mov	DWORD PTR _cl[eax+2212796], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+664]
	mov	DWORD PTR _cl[eax+2212796], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+664]
	mov	DWORD PTR _cl[eax+2212796], ecx
$LN1@CL_MoveSpe:

; 1218 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_MoveSpectatorCamera ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PopTraceBounds
_TEXT	SEGMENT
_CL_PopTraceBounds PROC					; COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 92   : 	memcpy( clgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 324856				; 0004f4f8H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 93   : 	memcpy( clgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 324904				; 0004f528H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PopTraceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PushTraceBounds
_TEXT	SEGMENT
tv67 = -72						; size = 4
tv66 = -68						; size = 4
_hullnum$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_CL_PushTraceBounds PROC				; COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 79   : 	hullnum = bound( 0, hullnum, 3 );

	cmp	DWORD PTR _hullnum$[ebp], 0
	jl	SHORT $LN5@CL_PushTra
	cmp	DWORD PTR _hullnum$[ebp], 3
	jge	SHORT $LN3@CL_PushTra
	mov	eax, DWORD PTR _hullnum$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_PushTra
$LN3@CL_PushTra:
	mov	DWORD PTR tv66[ebp], 3
$LN4@CL_PushTra:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_PushTra
$LN5@CL_PushTra:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_PushTra:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _hullnum$[ebp], edx

; 80   : 	VectorCopy( mins, clgame.pmove->player_mins[hullnum] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _hullnum$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [eax+edx+324856]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _hullnum$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [ecx+eax+324856]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _hullnum$[ebp], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [edx+ecx+324856]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 81   : 	VectorCopy( maxs, clgame.pmove->player_maxs[hullnum] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _hullnum$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [eax+edx+324904]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _hullnum$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [ecx+eax+324904]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _hullnum$[ebp], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [edx+ecx+324904]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PushTraceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_TraceLine
_TEXT	SEGMENT
$T1 = -208						; size = 68
_tr$ = -76						; size = 68
_old_usehull$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_flags$ = 20						; size = 4
_CL_TraceLine PROC					; COMDAT

; 714  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 715  : 	int	old_usehull;
; 716  : 	pmtrace_t	tr;
; 717  : 
; 718  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 719  : 	clgame.pmove->usehull = 2;	

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+188], 2

; 720  : 	tr = PM_PlayerTraceExt( clgame.pmove, start, end, flags, clgame.pmove->numphysent, clgame.pmove->physents, -1, NULL );

	push	0
	push	-1
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 721  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 722  : 
; 723  : 	return tr;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _tr$[ebp]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 724  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_VisTraceLine
_TEXT	SEGMENT
$T1 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_CL_VisTraceLine PROC					; COMDAT

; 734  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 735  : 	int		old_usehull;
; 736  : 	static pmtrace_t	tr;
; 737  : 
; 738  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 739  : 	clgame.pmove->usehull = 2;	

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+188], 2

; 740  : 	tr = PM_PlayerTraceExt( clgame.pmove, start, end, flags, clgame.pmove->numvisent, clgame.pmove->visents, -1, NULL );

	push	0
	push	-1
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 149336				; 00024758H
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [ecx+149332]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??CL_VisTraceLine@@9@9
	rep movsd

; 741  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 742  : 
; 743  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??CL_VisTraceLine@@9@9

; 744  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_VisTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_TestLine
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_CL_TestLine PROC					; COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 765  : 	return PM_TestLineExt( clgame.pmove, clgame.pmove->physents, clgame.pmove->numphysent, start, end, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	add	edx, 592				; 00000250H
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	call	_PM_TestLineExt
	add	esp, 24					; 00000018H

; 766  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TestLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetupPMove
_TEXT	SEGMENT
tv288 = -76						; size = 4
tv283 = -76						; size = 4
tv71 = -76						; size = 4
_cd$ = -8						; size = 4
_ps$ = -4						; size = 4
_pmove$ = 8						; size = 4
_from$ = 12						; size = 4
_ucmd$ = 16						; size = 4
_runfuncs$ = 20						; size = 4
_time$ = 24						; size = 8
_CL_SetupPMove PROC					; COMDAT

; 1039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1040 : 	entity_state_t	*ps;
; 1041 : 	clientdata_t	*cd;
; 1042 : 
; 1043 : 	ps = &from->playerstate;

	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR _ps$[ebp], eax

; 1044 : 	cd = &from->client;

	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _cd$[ebp], eax

; 1045 : 
; 1046 : 	pmove->player_index = ps->number - 1;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [edx], ecx

; 1047 : 	pmove->multiplayer = (cl.maxclients > 1);

	cmp	DWORD PTR _cl+2213004, 1
	jle	SHORT $LN3@CL_SetupPM
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CL_SetupPM
$LN3@CL_SetupPM:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CL_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1048 : 	pmove->runfuncs = runfuncs;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _runfuncs$[ebp]
	mov	DWORD PTR [eax+325044], ecx

; 1049 : 	pmove->time = time * 1000.0f;

	movsd	xmm0, QWORD PTR _time$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 1050 : 	pmove->frametime = ucmd->msec / 1000.0f;

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 1051 : 	VectorCopy( ps->origin, pmove->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+56], eax

; 1052 : 	VectorCopy( ps->angles, pmove->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+68], eax

; 1053 : 	VectorCopy( pmove->angles, pmove->oldangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [edx+eax+80], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+80], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [edx+ecx+80], eax

; 1054 : 	VectorCopy( cd->velocity, pmove->velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+12]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [edx+ecx+92], eax

; 1055 : 	VectorCopy( ps->basevelocity, pmove->basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+300]
	mov	DWORD PTR [edx+eax+116], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+300]
	mov	DWORD PTR [ecx+eax+116], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+300]
	mov	DWORD PTR [edx+ecx+116], eax

; 1056 : 	VectorCopy( cd->view_ofs, pmove->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [edx+eax+128], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [ecx+eax+128], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [edx+ecx+128], eax

; 1057 : 	VectorClear( pmove->movedir );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+104], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+104], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+104], xmm0

; 1058 : 	pmove->flDuckTime = cd->flDuckTime;

	mov	eax, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+140], xmm0

; 1059 : 	pmove->bInDuck = cd->bInDuck;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax+144], edx

; 1060 : 	pmove->usehull = ps->usehull;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+188], edx

; 1061 : 	pmove->flTimeStepSound = cd->flTimeStepSound;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+148], edx

; 1062 : 	pmove->iStepLeft = ps->iStepLeft;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+324]
	mov	DWORD PTR [eax+152], edx

; 1063 : 	pmove->flFallVelocity = ps->flFallVelocity;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+156], edx

; 1064 : 	pmove->flSwimTime = cd->flSwimTime;

	mov	eax, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+156]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+172], xmm0

; 1065 : 	VectorCopy( cd->punchangle, pmove->punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+32]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+32]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+160], eax

; 1066 : 	pmove->flSwimTime = cd->flSwimTime;

	mov	eax, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+156]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+172], xmm0

; 1067 : 	pmove->flNextPrimaryAttack = 0.0f; // not used by PM_ code

	mov	eax, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+176], xmm0

; 1068 : 	pmove->effects = ps->effects;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+180], edx

; 1069 : 	pmove->flags = cd->flags;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+184], edx

; 1070 : 	pmove->gravity = ps->gravity;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR [eax+192], edx

; 1071 : 	pmove->friction = ps->friction;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+196], edx

; 1072 : 	pmove->oldbuttons = ps->oldbuttons;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+316]
	mov	DWORD PTR [eax+200], edx

; 1073 : 	pmove->waterjumptime = cd->waterjumptime;

	mov	eax, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+204], xmm0

; 1074 : 	pmove->dead = (cl.local.health <= 0);

	cmp	DWORD PTR _cl+2212656, 0
	jg	SHORT $LN5@CL_SetupPM
	mov	DWORD PTR tv283[ebp], 1
	jmp	SHORT $LN6@CL_SetupPM
$LN5@CL_SetupPM:
	mov	DWORD PTR tv283[ebp], 0
$LN6@CL_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv283[ebp]
	mov	DWORD PTR [eax+208], ecx

; 1075 : 	pmove->deadflag = cd->deadflag;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+212], edx

; 1076 : 	pmove->spectator = (cls.spectator != 0);

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN7@CL_SetupPM
	mov	DWORD PTR tv288[ebp], 1
	jmp	SHORT $LN8@CL_SetupPM
$LN7@CL_SetupPM:
	mov	DWORD PTR tv288[ebp], 0
$LN8@CL_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv288[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1077 : 	pmove->movetype = ps->movetype;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+220], edx

; 1078 : 	pmove->onground = ps->onground;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+224], edx

; 1079 : 	pmove->waterlevel = cd->waterlevel;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+228], edx

; 1080 : 	pmove->watertype = cd->watertype;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+232], edx

; 1081 : 	pmove->maxspeed = clgame.movevars.maxspeed;

	mov	eax, DWORD PTR _pmove$[ebp]
	movss	xmm0, DWORD PTR _clgame+1032
	movss	DWORD PTR [eax+500], xmm0

; 1082 : 	pmove->clientmaxspeed = cd->maxspeed;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR [eax+504], edx

; 1083 : 	pmove->iuser1 = cd->iuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	DWORD PTR [eax+508], edx

; 1084 : 	pmove->iuser2 = cd->iuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	mov	DWORD PTR [eax+512], edx

; 1085 : 	pmove->iuser3 = cd->iuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+496]
	mov	DWORD PTR [eax+516], edx

; 1086 : 	pmove->iuser4 = cd->iuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+500]
	mov	DWORD PTR [eax+520], edx

; 1087 : 	pmove->fuser1 = cd->fuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR [eax+524], edx

; 1088 : 	pmove->fuser2 = cd->fuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	mov	DWORD PTR [eax+528], edx

; 1089 : 	pmove->fuser3 = cd->fuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	mov	DWORD PTR [eax+532], edx

; 1090 : 	pmove->fuser4 = cd->fuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [eax+536], edx

; 1091 : 	VectorCopy( cd->vuser1, pmove->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+520]
	mov	DWORD PTR [edx+eax+540], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+520]
	mov	DWORD PTR [ecx+eax+540], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+520]
	mov	DWORD PTR [edx+ecx+540], eax

; 1092 : 	VectorCopy( cd->vuser2, pmove->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+532]
	mov	DWORD PTR [edx+eax+552], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+532]
	mov	DWORD PTR [ecx+eax+552], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+532]
	mov	DWORD PTR [edx+ecx+552], eax

; 1093 : 	VectorCopy( cd->vuser3, pmove->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+544]
	mov	DWORD PTR [edx+eax+564], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+544]
	mov	DWORD PTR [ecx+eax+564], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+544]
	mov	DWORD PTR [edx+ecx+564], eax

; 1094 : 	VectorCopy( cd->vuser4, pmove->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+556]
	mov	DWORD PTR [edx+eax+576], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+556]
	mov	DWORD PTR [ecx+eax+576], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+556]
	mov	DWORD PTR [edx+ecx+576], eax

; 1095 : 	pmove->cmd = *ucmd;	// copy current cmds	

	mov	edi, DWORD PTR _pmove$[ebp]
	add	edi, 283736				; 00045458H
	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR _ucmd$[ebp]
	rep movsd

; 1096 : 
; 1097 : 	Q_strncpy( pmove->physinfo, cls.physinfo, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _cls+10136
	mov	eax, DWORD PTR _pmove$[ebp]
	add	eax, 324596				; 0004f3f4H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1098 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetupPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_GetWaterEntity
_TEXT	SEGMENT
_entnum$ = -4						; size = 4
_rgflPos$ = 8						; size = 4
_CL_GetWaterEntity PROC					; COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 755  : 	int	entnum;
; 756  : 
; 757  : 	entnum = CL_WaterEntity( rgflPos );

	mov	eax, DWORD PTR _rgflPos$[ebp]
	push	eax
	call	_CL_WaterEntity
	add	esp, 4
	mov	DWORD PTR _entnum$[ebp], eax

; 758  : 	if( entnum <= 0 ) return NULL; // world or not water

	cmp	DWORD PTR _entnum$[ebp], 0
	jg	SHORT $LN2@CL_GetWate
	xor	eax, eax
	jmp	SHORT $LN1@CL_GetWate
$LN2@CL_GetWate:

; 759  : 
; 760  : 	return CL_GetEntityByIndex( entnum );

	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
$LN1@CL_GetWate:

; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetWaterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_WaterEntity
_TEXT	SEGMENT
tv137 = -176						; size = 4
_matrix$1 = -108					; size = 64
_oldhull$ = -44						; size = 4
_i$ = -40						; size = 4
_offset$ = -36						; size = 12
_test$ = -24						; size = 12
_hull$ = -12						; size = 4
_pe$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_rgflPos$ = 8						; size = 4
_CL_WaterEntity PROC					; COMDAT

; 659  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 660  : 	physent_t		*pe;
; 661  : 	hull_t		*hull;
; 662  : 	vec3_t		test, offset;
; 663  : 	int		i, oldhull;
; 664  : 
; 665  : 	if( !rgflPos ) return -1;

	cmp	DWORD PTR _rgflPos$[ebp], 0
	jne	SHORT $LN5@CL_WaterEn
	or	eax, -1
	jmp	$LN1@CL_WaterEn
$LN5@CL_WaterEn:

; 666  : 
; 667  : 	oldhull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _oldhull$[ebp], ecx

; 668  : 
; 669  : 	for( i = 0; i < clgame.pmove->nummoveent; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_WaterEn
$LN2@CL_WaterEn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_WaterEn:
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+134992]
	jge	$LN3@CL_WaterEn

; 670  : 	{
; 671  : 		pe = &clgame.pmove->moveents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+134996]
	mov	DWORD PTR _pe$[ebp], edx

; 672  : 
; 673  : 		if( pe->solid != SOLID_NOT ) // disabled ?

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN6@CL_WaterEn

; 674  : 			continue;

	jmp	SHORT $LN2@CL_WaterEn
$LN6@CL_WaterEn:

; 675  : 
; 676  : 		// only brushes can have special contents
; 677  : 		if( !pe->model || pe->model->type != mod_brush )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN8@CL_WaterEn
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN7@CL_WaterEn
$LN8@CL_WaterEn:

; 678  : 			continue;

	jmp	SHORT $LN2@CL_WaterEn
$LN7@CL_WaterEn:

; 679  : 
; 680  : 		// check water brushes accuracy
; 681  : 		clgame.pmove->usehull = 2;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+188], 2

; 682  : 		hull = PM_HullForBsp( pe, clgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 683  : 		clgame.pmove->usehull = oldhull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _oldhull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 684  : 
; 685  : 		// offset the test point appropriately for this hull.
; 686  : 		VectorSubtract( rgflPos, offset, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _test$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv137[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR _test$[ebp+eax], xmm0

; 687  : 
; 688  : 		if( FBitSet( pe->model->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 2
	je	$LN9@CL_WaterEn
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_WaterEn
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_WaterEn
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@CL_WaterEn
$LN10@CL_WaterEn:

; 689  : 		{
; 690  : 			matrix4x4	matrix;
; 691  : 	
; 692  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 693  : 			Matrix4x4_VectorITransform( matrix, rgflPos, test );

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rgflPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN9@CL_WaterEn:

; 694  : 		}
; 695  : 
; 696  : 		// test hull for intersection with this model
; 697  : 		if( PM_HullPointContents( hull, hull->firstclipnode, test ) == CONTENTS_EMPTY )

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN11@CL_WaterEn

; 698  : 			continue;

	jmp	$LN2@CL_WaterEn
$LN11@CL_WaterEn:

; 699  : 
; 700  : 		// found water entity
; 701  : 		return pe->info;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [eax+80]
	jmp	SHORT $LN1@CL_WaterEn

; 702  : 	}

	jmp	$LN2@CL_WaterEn
$LN3@CL_WaterEn:

; 703  : 	return -1;

	or	eax, -1
$LN1@CL_WaterEn:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WaterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_TruePointContents
_TEXT	SEGMENT
tv144 = -180						; size = 4
_matrix$1 = -112					; size = 64
_pe$ = -48						; size = 4
_offset$ = -44						; size = 12
_test$ = -32						; size = 12
_hull$ = -20						; size = 4
_oldhull$ = -16						; size = 4
_contents$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_CL_TruePointContents PROC				; COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 599  : 	int	i, contents;
; 600  : 	int	oldhull;
; 601  : 	hull_t	*hull;
; 602  : 	vec3_t	test, offset;
; 603  : 	physent_t	*pe;
; 604  : 
; 605  : 	// sanity check
; 606  : 	if( !p ) return CONTENTS_NONE;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN5@CL_TruePoi
	xor	eax, eax
	jmp	$LN1@CL_TruePoi
$LN5@CL_TruePoi:

; 607  : 
; 608  : 	oldhull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _oldhull$[ebp], ecx

; 609  : 
; 610  : 	// get base contents from world
; 611  : 	contents = PM_HullPointContents( &cl.worldmodel->hulls[0], 0, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	0
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cl+4579004
	lea	ecx, DWORD PTR [eax+edx+208]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _contents$[ebp], eax

; 612  : 
; 613  : 	for( i = 0; i < clgame.pmove->nummoveent; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_TruePoi
$LN2@CL_TruePoi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_TruePoi:
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+134992]
	jge	$LN3@CL_TruePoi

; 614  : 	{
; 615  : 		pe = &clgame.pmove->moveents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+134996]
	mov	DWORD PTR _pe$[ebp], edx

; 616  : 
; 617  : 		if( pe->solid != SOLID_NOT ) // disabled ?

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN6@CL_TruePoi

; 618  : 			continue;

	jmp	SHORT $LN2@CL_TruePoi
$LN6@CL_TruePoi:

; 619  : 
; 620  : 		// only brushes can have special contents
; 621  : 		if( !pe->model || pe->model->type != mod_brush )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN8@CL_TruePoi
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN7@CL_TruePoi
$LN8@CL_TruePoi:

; 622  : 			continue;

	jmp	SHORT $LN2@CL_TruePoi
$LN7@CL_TruePoi:

; 623  : 
; 624  : 		// check water brushes accuracy
; 625  : 		clgame.pmove->usehull = 2;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+188], 2

; 626  : 		hull = PM_HullForBsp( pe, clgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 627  : 		clgame.pmove->usehull = oldhull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _oldhull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 628  : 
; 629  : 		// offset the test point appropriately for this hull.
; 630  : 		VectorSubtract( p, offset, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _test$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv144[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR _test$[ebp+eax], xmm0

; 631  : 
; 632  : 		if( FBitSet( pe->model->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 2
	je	$LN9@CL_TruePoi
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_TruePoi
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_TruePoi
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@CL_TruePoi
$LN10@CL_TruePoi:

; 633  : 		{
; 634  : 			matrix4x4	matrix;
; 635  : 	
; 636  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 637  : 			Matrix4x4_VectorITransform( matrix, p, test );

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN9@CL_TruePoi:

; 638  : 		}
; 639  : 
; 640  : 		// test hull for intersection with this model
; 641  : 		if( PM_HullPointContents( hull, hull->firstclipnode, test ) == CONTENTS_EMPTY )

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN11@CL_TruePoi

; 642  : 			continue;

	jmp	$LN2@CL_TruePoi
$LN11@CL_TruePoi:

; 643  : 
; 644  : 		// compare contents ranking
; 645  : 		if( RankForContents( pe->skin ) > RankForContents( contents ))

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	call	_RankForContents
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _contents$[ebp]
	push	edx
	call	_RankForContents
	add	esp, 4
	cmp	esi, eax
	jle	SHORT $LN12@CL_TruePoi

; 646  : 			contents = pe->skin; // new content has more priority

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _contents$[ebp], ecx
$LN12@CL_TruePoi:

; 647  : 	}

	jmp	$LN2@CL_TruePoi
$LN3@CL_TruePoi:

; 648  : 
; 649  : 	return contents;

	mov	eax, DWORD PTR _contents$[ebp]
$LN1@CL_TruePoi:

; 650  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_IsPredicted
_TEXT	SEGMENT
_CL_IsPredicted PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 103  : 	if( cl_nopred->value || cl.intermission )

	mov	eax, DWORD PTR _cl_nopred
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_IsPredi
	cmp	DWORD PTR _cl+2212820, 0
	je	SHORT $LN2@CL_IsPredi
$LN3@CL_IsPredi:

; 104  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_IsPredi
$LN2@CL_IsPredi:

; 105  : 
; 106  : 	// never predict the quake demos
; 107  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN4@CL_IsPredi

; 108  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_IsPredi
$LN4@CL_IsPredi:

; 109  : 	return true;

	mov	eax, 1
$LN1@CL_IsPredi:

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsPredicted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_CheckPredictionError
_TEXT	SEGMENT
tv144 = -96						; size = 4
_dist$ = -28						; size = 4
_delta$ = -24						; size = 12
_cmd$ = -12						; size = 4
_frame$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_CheckPredictionError PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 232  : 	int		frame, cmd;
; 233  : 	static int	pos = 0;
; 234  : 	vec3_t		delta;
; 235  : 	float		dist;
; 236  : 
; 237  : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	SHORT $LN2@CL_CheckPr

; 238  : 		return;

	jmp	$LN7@CL_CheckPr
$LN2@CL_CheckPr:

; 239  : 
; 240  : 	// calculate the last usercmd_t we sent that the server has processed
; 241  : 	frame = ( cls.netchan.incoming_acknowledged ) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26868
	mov	DWORD PTR _frame$[ebp], eax

; 242  : 	cmd = cl.parsecountmod;

	mov	eax, DWORD PTR _cl+12
	mov	DWORD PTR _cmd$[ebp], eax

; 243  : 
; 244  : 	// compare what the server returned with what we had predicted it to be
; 245  : 	VectorSubtract( cl.frames[cmd].playerstate[cl.playernum].origin, cl.local.predicted_origins[frame], delta );

	imul	eax, DWORD PTR _cmd$[ebp], 24056
	imul	ecx, DWORD PTR _cl+2213000, 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR _cl[eax+esi+2211832]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	imul	eax, DWORD PTR _cmd$[ebp], 24056
	imul	ecx, DWORD PTR _cl+2213000, 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _cl[ecx+esi+2211832]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	imul	eax, DWORD PTR _cmd$[ebp], 24056
	imul	ecx, DWORD PTR _cl+2213000, 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _cl[ecx+esi+2211832]
	movss	DWORD PTR tv144[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 246  : 	dist = VectorLength( delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 247  : 
; 248  : 	// save the prediction error for interpolation
; 249  : 	if( dist > MAX_PREDICTION_ERROR )

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@42800000
	jbe	$LN3@CL_CheckPr

; 250  : 	{
; 251  : 		if( cl_showerror->value && host_developer.value )

	mov	eax, DWORD PTR _cl_showerror
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_CheckPr
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_CheckPr

; 252  : 			Con_NPrintf( 10 + ( ++pos & 3 ), "^3player teleported:^7 %.3f units\n", dist );

	mov	eax, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	add	eax, 1
	mov	DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9, eax
	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CD@HNDKBLNP@?$FO3player?5teleported?3?$FO7?5?$CF?43f?5uni@
	mov	ecx, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	and	ecx, 3
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_Con_NPrintf
	add	esp, 16					; 00000010H
$LN5@CL_CheckPr:

; 253  : 
; 254  : 		// a teleport or something or gamepaused
; 255  : 		VectorClear( cl.local.prediction_error );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[eax+2212600], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212600], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[eax+2212600], xmm0

; 256  : 	}

	jmp	$LN7@CL_CheckPr
$LN3@CL_CheckPr:

; 257  : 	else
; 258  : 	{
; 259  : 		if( cl_showerror->value && dist > MIN_PREDICTION_EPSILON && host_developer.value )

	mov	eax, DWORD PTR _cl_showerror
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_CheckPr
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN6@CL_CheckPr
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_CheckPr

; 260  : 			Con_NPrintf( 10 + ( ++pos & 3 ), "^1prediction error:^7 %.3f units\n", dist );

	mov	eax, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	add	eax, 1
	mov	DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9, eax
	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CC@CCPCEFNP@?$FO1prediction?5error?3?$FO7?5?$CF?43f?5unit@
	mov	ecx, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	and	ecx, 3
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_Con_NPrintf
	add	esp, 16					; 00000010H
$LN6@CL_CheckPr:

; 261  : 
; 262  : 		VectorCopy( cl.frames[cmd].playerstate[cl.playernum].origin, cl.local.predicted_origins[frame] );

	imul	eax, DWORD PTR _cmd$[ebp], 24056
	imul	ecx, DWORD PTR _cl+2213000, 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _cl[eax+esi+2211832], ecx
	imul	edx, DWORD PTR _cmd$[ebp], 24056
	imul	eax, DWORD PTR _cl+2213000, 452
	lea	ecx, DWORD PTR _cl[edx+eax+2736]
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _cl[eax+esi+2211832], ecx
	imul	edx, DWORD PTR _cmd$[ebp], 24056
	imul	eax, DWORD PTR _cl+2213000, 452
	lea	ecx, DWORD PTR _cl[edx+eax+2736]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _cl[eax+esi+2211832], ecx

; 263  : 
; 264  : 		// save for error interpolation
; 265  : 		VectorCopy( delta, cl.local.prediction_error );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _delta$[ebp+ecx]
	mov	DWORD PTR _cl[eax+2212600], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _delta$[ebp+edx]
	mov	DWORD PTR _cl[eax+2212600], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _delta$[ebp+edx]
	mov	DWORD PTR _cl[eax+2212600], ecx

; 266  : 
; 267  : 		if( dist > MIN_CORRECTION_DISTANCE )

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN7@CL_CheckPr

; 268  : 			cls.correction_time = cl_smoothtime->value;

	mov	eax, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	QWORD PTR _cls+296296, xmm0
$LN7@CL_CheckPr:

; 269  : 	}
; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckPredictionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_PredictMovement
_TEXT	SEGMENT
tv707 = -172						; size = 8
tv328 = -172						; size = 8
tv1169 = -164						; size = 8
tv706 = -164						; size = 8
tv327 = -164						; size = 8
tv769 = -160						; size = 4
tv748 = -160						; size = 4
tv733 = -160						; size = 4
tv633 = -160						; size = 4
tv611 = -160						; size = 4
tv554 = -160						; size = 4
tv500 = -160						; size = 4
tv446 = -160						; size = 4
tv321 = -160						; size = 4
tv259 = -160						; size = 4
tv206 = -160						; size = 4
_frac$1 = -92						; size = 4
_delta$2 = -88						; size = 12
_delta$3 = -76						; size = 12
_time$ = -64						; size = 8
_ent$ = -56						; size = 4
_f$ = -52						; size = 8
_runfuncs$ = -44					; size = 4
_stoppoint$ = -40					; size = 4
_i$ = -36						; size = 4
_frame$ = -32						; size = 4
_current_command_mod$ = -28				; size = 4
_current_command$ = -24					; size = 4
_to$ = -20						; size = 4
_from$ = -16						; size = 4
_from_cmd$ = -12					; size = 4
_to_cmd$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_repredicting$ = 8					; size = 4
_CL_PredictMovement PROC				; COMDAT

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1229 : 	runcmd_t		*to_cmd, *from_cmd;
; 1230 : 	local_state_t	*from = NULL, *to = NULL;

	mov	DWORD PTR _from$[ebp], 0
	mov	DWORD PTR _to$[ebp], 0

; 1231 : 	int		current_command;
; 1232 : 	int		current_command_mod;
; 1233 : 	frame_t		*frame = NULL;

	mov	DWORD PTR _frame$[ebp], 0

; 1234 : 	int		i, stoppoint;
; 1235 : 	qboolean		runfuncs;
; 1236 : 	double		f = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _f$[ebp], xmm0

; 1237 : 	cl_entity_t	*ent;
; 1238 : 	double		time;
; 1239 : 
; 1240 : 	if( cls.state != ca_active || cls.spectator )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN6@CL_Predict
	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN5@CL_Predict
$LN6@CL_Predict:

; 1241 : 		return;

	jmp	$LN1@CL_Predict
$LN5@CL_Predict:

; 1242 : 
; 1243 : 	if( cls.demoplayback && !repredicting )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN7@CL_Predict
	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN7@CL_Predict

; 1244 : 		CL_DemoInterpolateAngles();

	call	_CL_DemoInterpolateAngles
$LN7@CL_Predict:

; 1245 : 
; 1246 : 	CL_SetUpPlayerPrediction( false, false );

	push	0
	push	0
	call	_CL_SetUpPlayerPrediction
	add	esp, 8

; 1247 : 
; 1248 : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_Predict
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN8@CL_Predict
$LN9@CL_Predict:

; 1249 : 		return;

	jmp	$LN1@CL_Predict
$LN8@CL_Predict:

; 1250 : 
; 1251 : 	if(( cls.netchan.outgoing_sequence - cls.netchan.incoming_acknowledged ) >= CL_UPDATE_MASK )

	mov	eax, DWORD PTR _cls+26880
	sub	eax, DWORD PTR _cls+26868
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	cmp	eax, ecx
	jl	SHORT $LN10@CL_Predict

; 1252 : 		return;

	jmp	$LN1@CL_Predict
$LN10@CL_Predict:

; 1253 : 
; 1254 : 	// this is the last frame received from the server
; 1255 : 	frame = &cl.frames[cl.parsecountmod];

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], eax

; 1256 : 
; 1257 : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	$LN13@CL_Predict

; 1258 : 	{
; 1259 : 		VectorCopy( frame->clientdata.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+44]
	mov	DWORD PTR _cl[eax+2212988], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _cl[eax+2212988], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+44]
	mov	DWORD PTR _cl[ecx+2212988], eax

; 1260 : 		VectorCopy( frame->clientdata.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	mov	DWORD PTR _cl[eax+2212976], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR _cl[eax+2212976], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _cl[ecx+2212976], eax

; 1261 : 		VectorCopy( frame->clientdata.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	DWORD PTR _cl[eax+2212808], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR _cl[eax+2212808], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+64]
	mov	DWORD PTR _cl[ecx+2212808], eax

; 1262 : 		VectorCopy( frame->clientdata.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+88]
	mov	DWORD PTR _cl[eax+2212796], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+88]
	mov	DWORD PTR _cl[eax+2212796], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+88]
	mov	DWORD PTR _cl[ecx+2212796], eax

; 1263 : 		cl.local.usehull = frame->playerstate[cl.playernum].usehull;

	imul	eax, DWORD PTR _cl+2213000, 452
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2960]
	mov	DWORD PTR _cl+2212740, edx

; 1264 : 		cl.local.waterlevel = frame->clientdata.waterlevel;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _cl+2212736, ecx

; 1265 : 
; 1266 : 		if( FBitSet( frame->clientdata.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	and	ecx, 512				; 00000200H
	je	SHORT $LN12@CL_Predict

; 1267 : 			cl.local.onground = frame->playerstate[cl.playernum].onground;

	imul	eax, DWORD PTR _cl+2213000, 452
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2968]
	mov	DWORD PTR _cl+2212728, edx
	jmp	SHORT $LN13@CL_Predict
$LN12@CL_Predict:

; 1268 : 		else cl.local.onground = -1;

	mov	DWORD PTR _cl+2212728, -1
$LN13@CL_Predict:

; 1269 : 	}
; 1270 : 
; 1271 : 	from = &cl.predicted_frames[cl.parsecountmod];

	imul	eax, DWORD PTR _cl+12, 9724
	add	eax, OFFSET _cl+1545304
	mov	DWORD PTR _from$[ebp], eax

; 1272 : 	from_cmd = &cl.commands[cls.netchan.incoming_acknowledged & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26868
	imul	ecx, eax, 88
	add	ecx, OFFSET _cl+1539672
	mov	DWORD PTR _from_cmd$[ebp], ecx

; 1273 : 	memcpy( from->weapondata, frame->weapondata, sizeof( from->weapondata ));

	push	6656					; 00001a00H
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 17112				; 000042d8H
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	add	ecx, 3068				; 00000bfcH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1274 : 	from->playerstate = frame->playerstate[cl.playernum];

	imul	eax, DWORD PTR _cl+2213000, 452
	mov	ecx, DWORD PTR _frame$[ebp]
	lea	esi, DWORD PTR [ecx+eax+2648]
	mov	ecx, 113				; 00000071H
	mov	edi, DWORD PTR _from$[ebp]
	rep movsd

; 1275 : 	from->client = frame->clientdata;

	mov	esi, DWORD PTR _frame$[ebp]
	add	esi, 32					; 00000020H
	mov	edi, DWORD PTR _from$[ebp]
	add	edi, 452				; 000001c4H
	mov	ecx, 654				; 0000028eH
	rep movsd

; 1276 : 	if( !frame->valid ) return;

	mov	eax, DWORD PTR _frame$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@CL_Predict
	jmp	$LN1@CL_Predict
$LN14@CL_Predict:

; 1277 : 
; 1278 : 	time = frame->time;

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR _time$[ebp], xmm0

; 1279 : 	stoppoint = ( repredicting ) ? 0 : 1;

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN39@CL_Predict
	mov	DWORD PTR tv206[ebp], 0
	jmp	SHORT $LN40@CL_Predict
$LN39@CL_Predict:
	mov	DWORD PTR tv206[ebp], 1
$LN40@CL_Predict:
	mov	eax, DWORD PTR tv206[ebp]
	mov	DWORD PTR _stoppoint$[ebp], eax

; 1280 : 	cl.local.repredicting = repredicting;

	mov	eax, DWORD PTR _repredicting$[ebp]
	mov	DWORD PTR _cl+2212632, eax

; 1281 : 	cl.local.onground = -1;

	mov	DWORD PTR _cl+2212728, -1

; 1282 : 
; 1283 : 	// predict forward until cl.time <= to->senttime
; 1284 : 	CL_PushPMStates();

	call	_CL_PushPMStates

; 1285 : 	CL_SetSolidPlayers( cl.playernum );

	mov	eax, DWORD PTR _cl+2213000
	push	eax
	call	_CL_SetSolidPlayers
	add	esp, 4

; 1286 : 
; 1287 : 	for( i = 1; i < CL_UPDATE_MASK && cls.netchan.incoming_acknowledged + i < cls.netchan.outgoing_sequence + stoppoint; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_Predict
$LN2@CL_Predict:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Predict:
	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@CL_Predict
	mov	eax, DWORD PTR _cls+26868
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cls+26880
	add	ecx, DWORD PTR _stoppoint$[ebp]
	cmp	eax, ecx
	jge	$LN3@CL_Predict

; 1288 : 	{
; 1289 : 		current_command = cls.netchan.incoming_acknowledged + i;

	mov	eax, DWORD PTR _cls+26868
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _current_command$[ebp], eax

; 1290 : 		current_command_mod = current_command & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _current_command$[ebp]
	mov	DWORD PTR _current_command_mod$[ebp], eax

; 1291 : 
; 1292 : 		to = &cl.predicted_frames[(cl.parsecountmod + i) & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _cl+12
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	imul	edx, eax, 9724
	add	edx, OFFSET _cl+1545304
	mov	DWORD PTR _to$[ebp], edx

; 1293 : 		to_cmd = &cl.commands[current_command_mod];

	imul	eax, DWORD PTR _current_command_mod$[ebp], 88
	add	eax, OFFSET _cl+1539672
	mov	DWORD PTR _to_cmd$[ebp], eax

; 1294 : 		runfuncs = ( !repredicting && !to_cmd->processedfuncs );

	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN41@CL_Predict
	mov	eax, DWORD PTR _to_cmd$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN41@CL_Predict
	mov	DWORD PTR tv259[ebp], 1
	jmp	SHORT $LN42@CL_Predict
$LN41@CL_Predict:
	mov	DWORD PTR tv259[ebp], 0
$LN42@CL_Predict:
	mov	ecx, DWORD PTR tv259[ebp]
	mov	DWORD PTR _runfuncs$[ebp], ecx

; 1295 : 
; 1296 : 		CL_RunUsercmd( from, to, &to_cmd->cmd, runfuncs, &time, current_command );

	mov	eax, DWORD PTR _current_command$[ebp]
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	mov	eax, DWORD PTR _to_cmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1297 : 		VectorCopy( to->playerstate.origin, cl.local.predicted_origins[current_command_mod] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _current_command_mod$[ebp], 12
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR _cl[edx+eax+2211832], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _current_command_mod$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR _cl[eax+ecx+2211832], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _current_command_mod$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR _cl[ecx+edx+2211832], eax

; 1298 : 		to_cmd->processedfuncs = true;

	mov	eax, DWORD PTR _to_cmd$[ebp]
	mov	DWORD PTR [eax+76], 1

; 1299 : 
; 1300 : 		if( to_cmd->senttime >= host.realtime )

	mov	eax, DWORD PTR _to_cmd$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	comisd	xmm0, QWORD PTR _host+1440
	jb	SHORT $LN15@CL_Predict

; 1301 : 			break;

	jmp	SHORT $LN3@CL_Predict
$LN15@CL_Predict:

; 1302 : 
; 1303 : 		// now interpolate some fraction of the final frame
; 1304 : 		if( to_cmd->senttime != from_cmd->senttime )

	mov	eax, DWORD PTR _to_cmd$[ebp]
	mov	ecx, DWORD PTR _from_cmd$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@CL_Predict

; 1305 : 			f = (host.realtime - from_cmd->senttime) / (to_cmd->senttime - from_cmd->senttime) * 0.1;

	mov	eax, DWORD PTR _from_cmd$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR _to_cmd$[ebp]
	mov	edx, DWORD PTR _from_cmd$[ebp]
	movsd	xmm1, QWORD PTR [ecx]
	subsd	xmm1, QWORD PTR [edx]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR _f$[ebp], xmm0
$LN16@CL_Predict:

; 1306 : 
; 1307 : 		from = to;

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 1308 : 		from_cmd = to_cmd;

	mov	eax, DWORD PTR _to_cmd$[ebp]
	mov	DWORD PTR _from_cmd$[ebp], eax

; 1309 : 	}

	jmp	$LN2@CL_Predict
$LN3@CL_Predict:

; 1310 : 
; 1311 : 	CL_PopPMStates();

	call	_CL_PopPMStates

; 1312 : 
; 1313 : 	if(( i == CL_UPDATE_MASK ) || ( !to && !repredicting ))

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $LN18@CL_Predict
	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN17@CL_Predict
	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN17@CL_Predict
$LN18@CL_Predict:

; 1314 : 	{
; 1315 : 		cl.local.repredicting = false;

	mov	DWORD PTR _cl+2212632, 0

; 1316 : 		return; // net hasn't deliver packets in a long time...

	jmp	$LN1@CL_Predict
$LN17@CL_Predict:

; 1317 : 	}
; 1318 : 
; 1319 : 	if( !to )

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN19@CL_Predict

; 1320 : 	{
; 1321 : 		to = from;

	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR _to$[ebp], eax

; 1322 : 		to_cmd = from_cmd;

	mov	eax, DWORD PTR _from_cmd$[ebp]
	mov	DWORD PTR _to_cmd$[ebp], eax
$LN19@CL_Predict:

; 1323 : 	}
; 1324 : 
; 1325 : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	$LN20@CL_Predict

; 1326 : 	{
; 1327 : 		// keep onground actual
; 1328 : 		if( FBitSet( frame->clientdata.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	and	ecx, 512				; 00000200H
	je	SHORT $LN21@CL_Predict

; 1329 : 			cl.local.onground = frame->playerstate[cl.playernum].onground;

	imul	eax, DWORD PTR _cl+2213000, 452
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2968]
	mov	DWORD PTR _cl+2212728, edx
	jmp	SHORT $LN22@CL_Predict
$LN21@CL_Predict:

; 1330 : 		else cl.local.onground = -1;

	mov	DWORD PTR _cl+2212728, -1
$LN22@CL_Predict:

; 1331 : 
; 1332 : 		if (!repredicting || !CVAR_TO_BOOL(cl_lw))

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN24@CL_Predict
	cmp	DWORD PTR _cl_lw, 0
	je	SHORT $LN43@CL_Predict
	mov	eax, DWORD PTR _cl_lw
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN43@CL_Predict
	mov	DWORD PTR tv321[ebp], 1
	jmp	SHORT $LN44@CL_Predict
$LN43@CL_Predict:
	mov	DWORD PTR tv321[ebp], 0
$LN44@CL_Predict:
	cmp	DWORD PTR tv321[ebp], 0
	jne	SHORT $LN23@CL_Predict
$LN24@CL_Predict:

; 1333 : 		{
; 1334 : 			cl.local.viewmodel = to->client.viewmodel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	mov	DWORD PTR _cl+2212648, ecx

; 1335 : 			cl.local.armmodel = to->client.armmodel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	mov	DWORD PTR _cl+2212652, ecx
$LN23@CL_Predict:

; 1336 : 		}
; 1337 : 		cl.local.repredicting = false;

	mov	DWORD PTR _cl+2212632, 0

; 1338 : 		cl.local.moving = false;

	mov	DWORD PTR _cl+2212744, 0

; 1339 : 		return;

	jmp	$LN1@CL_Predict
$LN20@CL_Predict:

; 1340 : 	}
; 1341 : 
; 1342 : 	f = bound( 0.0f, f, 1.0f );

	movsd	xmm0, QWORD PTR _f$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN47@CL_Predict
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR _f$[ebp]
	jbe	SHORT $LN45@CL_Predict
	movsd	xmm0, QWORD PTR _f$[ebp]
	movsd	QWORD PTR tv327[ebp], xmm0
	jmp	SHORT $LN46@CL_Predict
$LN45@CL_Predict:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv327[ebp], xmm0
$LN46@CL_Predict:
	movsd	xmm0, QWORD PTR tv327[ebp]
	movsd	QWORD PTR tv328[ebp], xmm0
	jmp	SHORT $LN48@CL_Predict
$LN47@CL_Predict:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv328[ebp], xmm0
$LN48@CL_Predict:
	movsd	xmm0, QWORD PTR tv328[ebp]
	movsd	QWORD PTR _f$[ebp], xmm0

; 1343 : 	f = 0.0;	// FIXME: make work, do revision

	xorps	xmm0, xmm0
	movsd	QWORD PTR _f$[ebp], xmm0

; 1344 : 
; 1345 : 	if( CL_PlayerTeleported( from, to ))

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	call	_CL_PlayerTeleported
	add	esp, 8
	test	eax, eax
	je	$LN25@CL_Predict

; 1346 : 	{
; 1347 : 		VectorCopy( to->client.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+464]
	mov	DWORD PTR _cl[eax+2212988], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+464]
	mov	DWORD PTR _cl[eax+2212988], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+464]
	mov	DWORD PTR _cl[ecx+2212988], eax

; 1348 : 		VectorCopy( to->playerstate.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _cl[eax+2212976], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _cl[eax+2212976], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _cl[ecx+2212976], eax

; 1349 : 		VectorCopy( to->client.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+484]
	mov	DWORD PTR _cl[eax+2212808], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+484]
	mov	DWORD PTR _cl[eax+2212808], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+484]
	mov	DWORD PTR _cl[ecx+2212808], eax

; 1350 : 		VectorCopy( to->client.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+508]
	mov	DWORD PTR _cl[eax+2212796], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+508]
	mov	DWORD PTR _cl[eax+2212796], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+508]
	mov	DWORD PTR _cl[ecx+2212796], eax

; 1351 : 	}

	jmp	$LN28@CL_Predict
$LN25@CL_Predict:

; 1352 : 	else
; 1353 : 	{
; 1354 : 		VectorLerp( from->playerstate.origin, f, to->playerstate.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx+16]
	subss	xmm1, DWORD PTR [esi+eax+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212976], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+16]
	subss	xmm1, DWORD PTR [esi+edx+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212976], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+16]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+16]
	subss	xmm1, DWORD PTR [esi+edx+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv446[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv446[ebp]
	movss	DWORD PTR _cl[ecx+2212976], xmm0

; 1355 : 		VectorLerp( from->client.velocity, f, to->client.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+464]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx+464]
	subss	xmm1, DWORD PTR [esi+eax+464]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212988], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+464]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+464]
	subss	xmm1, DWORD PTR [esi+edx+464]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212988], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+464]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+464]
	subss	xmm1, DWORD PTR [esi+edx+464]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv500[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv500[ebp]
	movss	DWORD PTR _cl[ecx+2212988], xmm0

; 1356 : 		VectorLerp( from->client.punchangle, f, to->client.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+484]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx+484]
	subss	xmm1, DWORD PTR [esi+eax+484]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212808], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+484]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+484]
	subss	xmm1, DWORD PTR [esi+edx+484]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212808], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+484]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+484]
	subss	xmm1, DWORD PTR [esi+edx+484]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv554[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv554[ebp]
	movss	DWORD PTR _cl[ecx+2212808], xmm0

; 1357 : 
; 1358 : 		if( from->playerstate.usehull == to->playerstate.usehull )

	mov	eax, DWORD PTR _from$[ebp]
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [eax+312]
	cmp	edx, DWORD PTR [ecx+312]
	jne	$LN27@CL_Predict

; 1359 : 			VectorLerp( from->client.view_ofs, f, to->client.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+508]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx+508]
	subss	xmm1, DWORD PTR [esi+eax+508]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212796], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+508]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+508]
	subss	xmm1, DWORD PTR [esi+edx+508]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+2212796], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+508]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+508]
	subss	xmm1, DWORD PTR [esi+edx+508]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv611[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv611[ebp]
	movss	DWORD PTR _cl[ecx+2212796], xmm0
	jmp	SHORT $LN28@CL_Predict
$LN27@CL_Predict:

; 1360 : 		else VectorCopy( to->client.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+508]
	mov	DWORD PTR _cl[eax+2212796], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+508]
	mov	DWORD PTR _cl[eax+2212796], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+508]
	mov	DWORD PTR _cl[ecx+2212796], eax
$LN28@CL_Predict:

; 1361 : 	}
; 1362 : 
; 1363 : 	cl.local.waterlevel = to->client.waterlevel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+500]
	mov	DWORD PTR _cl+2212736, ecx

; 1364 : 	cl.local.usehull = to->playerstate.usehull;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	mov	DWORD PTR _cl+2212740, ecx

; 1365 : 	if (!repredicting || !CVAR_TO_BOOL(cl_lw))

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN30@CL_Predict
	cmp	DWORD PTR _cl_lw, 0
	je	SHORT $LN49@CL_Predict
	mov	eax, DWORD PTR _cl_lw
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN49@CL_Predict
	mov	DWORD PTR tv633[ebp], 1
	jmp	SHORT $LN50@CL_Predict
$LN49@CL_Predict:
	mov	DWORD PTR tv633[ebp], 0
$LN50@CL_Predict:
	cmp	DWORD PTR tv633[ebp], 0
	jne	SHORT $LN29@CL_Predict
$LN30@CL_Predict:

; 1366 : 	{
; 1367 : 		cl.local.viewmodel = to->client.viewmodel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	mov	DWORD PTR _cl+2212648, ecx

; 1368 : 		cl.local.armmodel = to->client.armmodel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	mov	DWORD PTR _cl+2212652, ecx
$LN29@CL_Predict:

; 1369 : 	}
; 1370 : 
; 1371 : 	if( FBitSet( to->client.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+496]
	and	ecx, 512				; 00000200H
	je	$LN31@CL_Predict

; 1372 : 	{
; 1373 : 		ent = CL_GetEntityByIndex( cl.local.lastground );

	mov	eax, DWORD PTR _cl+2212624
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1374 : 		cl.local.onground = cl.local.lastground;

	mov	eax, DWORD PTR _cl+2212624
	mov	DWORD PTR _cl+2212728, eax

; 1375 : 		cl.local.moving = false;

	mov	DWORD PTR _cl+2212744, 0

; 1376 : 
; 1377 : 		if( ent )

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN34@CL_Predict

; 1378 : 		{
; 1379 : 			vec3_t delta;
; 1380 : 
; 1381 : 			delta[0] = ent->curstate.origin[0] - ent->prevstate.origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+928]
	subss	xmm0, DWORD PTR [esi+eax+476]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$3[ebp+ecx], xmm0

; 1382 : 			delta[1] = ent->curstate.origin[1] - ent->prevstate.origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+928]
	subss	xmm0, DWORD PTR [esi+ecx+476]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _delta$3[ebp+eax], xmm0

; 1383 : 			delta[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _delta$3[ebp+eax], xmm0

; 1384 : 
; 1385 : 			if( VectorLength( delta ) > 0.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$3[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$3[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$3[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$3[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$3[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$3[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv1169[ebp]
	movsd	xmm0, QWORD PTR tv1169[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN34@CL_Predict

; 1386 : 			{
; 1387 : 				cls.correction_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+296296, xmm0

; 1388 : 				cl.local.moving = true;

	mov	DWORD PTR _cl+2212744, 1
$LN34@CL_Predict:

; 1389 : 			}
; 1390 : 		}
; 1391 : 	}

	jmp	SHORT $LN32@CL_Predict
$LN31@CL_Predict:

; 1392 : 	else
; 1393 : 	{
; 1394 : 		cl.local.onground = -1;

	mov	DWORD PTR _cl+2212728, -1

; 1395 : 		cl.local.moving = 0;

	mov	DWORD PTR _cl+2212744, 0
$LN32@CL_Predict:

; 1396 : 	}
; 1397 : 
; 1398 : 	if( cls.correction_time > 0 && !cl_nosmooth->value && cl_smoothtime->value )

	movsd	xmm0, QWORD PTR _cls+296296
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN35@CL_Predict
	mov	eax, DWORD PTR _cl_nosmooth
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN35@CL_Predict
	mov	eax, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN35@CL_Predict

; 1399 : 	{
; 1400 : 		vec3_t	delta;
; 1401 : 		float	frac;
; 1402 : 
; 1403 : 		// only decay timer once per frame
; 1404 : 		if( !repredicting )

	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN36@CL_Predict

; 1405 : 			cls.correction_time -= host.frametime;

	movsd	xmm0, QWORD PTR _cls+296296
	subsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cls+296296, xmm0
$LN36@CL_Predict:

; 1406 : 
; 1407 : 		// Make sure smoothtime is postive
; 1408 : 		if( cl_smoothtime->value <= 0.0 )

	mov	eax, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	jb	SHORT $LN37@CL_Predict

; 1409 : 			Cvar_DirectSet( cl_smoothtime, "0.1" );

	push	OFFSET ??_C@_03NKBOLEBK@0?41@
	mov	eax, DWORD PTR _cl_smoothtime
	push	eax
	call	_Cvar_DirectSet
	add	esp, 8
$LN37@CL_Predict:

; 1410 : 
; 1411 : 		// Clamp from 0 to cl_smoothtime.value
; 1412 : 		cls.correction_time = bound( 0.0, cls.correction_time, cl_smoothtime->value );

	movsd	xmm0, QWORD PTR _cls+296296
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN53@CL_Predict
	mov	eax, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [eax+12]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _cls+296296
	jbe	SHORT $LN51@CL_Predict
	movsd	xmm0, QWORD PTR _cls+296296
	movsd	QWORD PTR tv706[ebp], xmm0
	jmp	SHORT $LN52@CL_Predict
$LN51@CL_Predict:
	mov	ecx, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [ecx+12]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv706[ebp], xmm0
$LN52@CL_Predict:
	movsd	xmm0, QWORD PTR tv706[ebp]
	movsd	QWORD PTR tv707[ebp], xmm0
	jmp	SHORT $LN54@CL_Predict
$LN53@CL_Predict:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv707[ebp], xmm0
$LN54@CL_Predict:
	movsd	xmm0, QWORD PTR tv707[ebp]
	movsd	QWORD PTR _cls+296296, xmm0

; 1413 : 
; 1414 : 		// Compute backward interpolation fraction along full correction
; 1415 : 		frac = 1.0 - cls.correction_time / cl_smoothtime->value;

	mov	eax, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _cls+296296
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _frac$1[ebp], xmm0

; 1416 : 
; 1417 : 		// Determine how much error we still have to make up for
; 1418 : 		VectorSubtract( cl.simorg, cl.local.lastorigin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _cl[ecx+2212976]
	subss	xmm0, DWORD PTR _cl[eax+2212612]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _cl[eax+2212976]
	subss	xmm0, DWORD PTR _cl[ecx+2212612]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _cl[eax+2212976]
	subss	xmm0, DWORD PTR _cl[ecx+2212612]
	movss	DWORD PTR tv733[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv733[ebp]
	movss	DWORD PTR _delta$2[ebp+edx], xmm0

; 1419 : 
; 1420 : 		// Scale the error by the backlerp fraction
; 1421 : 		VectorScale( delta, frac, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$2[ebp+ecx]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$2[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _delta$2[ebp+ecx]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _delta$2[ebp+eax]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	movss	DWORD PTR tv748[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv748[ebp]
	movss	DWORD PTR _delta$2[ebp+ecx], xmm0

; 1422 : 
; 1423 : 		// Go some fraction of the way
; 1424 : 		// FIXME, Probably can't do this any more
; 1425 : 		VectorAdd( cl.local.lastorigin, delta, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _cl[ecx+2212612]
	addss	xmm0, DWORD PTR _delta$2[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+2212976], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _cl[eax+2212612]
	addss	xmm0, DWORD PTR _delta$2[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _cl[edx+2212976], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _cl[eax+2212612]
	addss	xmm0, DWORD PTR _delta$2[ebp+ecx]
	movss	DWORD PTR tv769[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv769[ebp]
	movss	DWORD PTR _cl[edx+2212976], xmm0
$LN35@CL_Predict:

; 1426 : 	}
; 1427 : 
; 1428 : 	VectorCopy( cl.simorg, cl.local.lastorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212976]
	mov	DWORD PTR _cl[eax+2212612], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212976]
	mov	DWORD PTR _cl[eax+2212612], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212976]
	mov	DWORD PTR _cl[eax+2212612], ecx

; 1429 : 	cl.local.repredicting = false;

	mov	DWORD PTR _cl+2212632, 0
$LN1@CL_Predict:

; 1430 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PredictMovement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_InitClientMove
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_InitClientMove PROC					; COMDAT

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 971  : 	int	i;
; 972  : 
; 973  : 	Pmove_Init ();

	call	_Pmove_Init

; 974  : 
; 975  : 	clgame.pmove->server = false;	// running at client

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+4], 0

; 976  : 	clgame.pmove->movevars = &clgame.movevars;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324852], OFFSET _clgame+1024

; 977  : 	clgame.pmove->runfuncs = false;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325044], 0

; 978  : 
; 979  : 	// enumerate client hulls
; 980  : 	for( i = 0; i < MAX_MAP_HULLS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_InitCli
$LN2@CL_InitCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_InitCli:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@CL_InitCli

; 981  : 	{
; 982  : 		if( clgame.dllFuncs.pfnGetHullBounds( i, host.player_mins[i], host.player_maxs[i] ))

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _host+34284
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, OFFSET _host+34236
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	DWORD PTR _clgame+132
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@CL_InitCli

; 983  : 			Con_Reportf( "CL: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g\n", i,

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+eax+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm0, DWORD PTR _host[ecx+eax+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+ecx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@EEFEJKGH@CL?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@
	call	_Con_Reportf
	add	esp, 56					; 00000038H
$LN5@CL_InitCli:

; 984  : 			host.player_mins[i][0], host.player_mins[i][1], host.player_mins[i][2],
; 985  : 			host.player_maxs[i][0], host.player_maxs[i][1], host.player_maxs[i][2] );
; 986  : 	}

	jmp	$LN2@CL_InitCli
$LN3@CL_InitCli:

; 987  : 
; 988  : 	memcpy( clgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 324856				; 0004f4f8H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 989  : 	memcpy( clgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 324904				; 0004f528H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 990  : 
; 991  : 	// common utilities
; 992  : 	clgame.pmove->PM_Info_ValueForKey = Info_ValueForKey;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324952], OFFSET _Info_ValueForKey

; 993  : 	clgame.pmove->PM_Particle = CL_Particle;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324956], OFFSET _CL_Particle

; 994  : 	clgame.pmove->PM_TestPlayerPosition = pfnTestPlayerPosition;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324960], OFFSET _pfnTestPlayerPosition

; 995  : 	clgame.pmove->Con_NPrintf = Con_NPrintf;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324964], OFFSET _Con_NPrintf

; 996  : 	clgame.pmove->Con_DPrintf = Con_DPrintf;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324968], OFFSET _Con_DPrintf

; 997  : 	clgame.pmove->Con_Printf = Con_Printf;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324972], OFFSET _Con_Printf

; 998  : 	clgame.pmove->Sys_FloatTime = Sys_DoubleTime;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324976], OFFSET _Sys_DoubleTime

; 999  : 	clgame.pmove->PM_StuckTouch = pfnStuckTouch;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324980], OFFSET _pfnStuckTouch

; 1000 : 	clgame.pmove->PM_PointContents = pfnPointContents;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324984], OFFSET _pfnPointContents

; 1001 : 	clgame.pmove->PM_TruePointContents = pfnTruePointContents;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324988], OFFSET _pfnTruePointContents

; 1002 : 	clgame.pmove->PM_HullPointContents = pfnHullPointContents; 

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324992], OFFSET _pfnHullPointContents

; 1003 : 	clgame.pmove->PM_PlayerTrace = pfnPlayerTrace;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+324996], OFFSET _pfnPlayerTrace

; 1004 : 	clgame.pmove->PM_TraceLine = pfnTraceLine;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325000], OFFSET _pfnTraceLine

; 1005 : 	clgame.pmove->RandomLong = COM_RandomLong;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325004], OFFSET _COM_RandomLong

; 1006 : 	clgame.pmove->RandomFloat = COM_RandomFloat;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325008], OFFSET _COM_RandomFloat

; 1007 : 	clgame.pmove->PM_GetModelType = pfnGetModelType;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325012], OFFSET _pfnGetModelType

; 1008 : 	clgame.pmove->PM_GetModelBounds = pfnGetModelBounds;	

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325016], OFFSET _pfnGetModelBounds

; 1009 : 	clgame.pmove->PM_HullForBsp = pfnHullForBsp;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325020], OFFSET _pfnHullForBsp

; 1010 : 	clgame.pmove->PM_TraceModel = pfnTraceModel;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325024], OFFSET _pfnTraceModel

; 1011 : 	clgame.pmove->COM_FileSize = COM_FileSize;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325028], OFFSET _COM_FileSize

; 1012 : 	clgame.pmove->COM_LoadFile = COM_LoadFile;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325032], OFFSET _COM_LoadFile

; 1013 : 	clgame.pmove->COM_FreeFile = COM_FreeFile;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325036], OFFSET _COM_FreeFile

; 1014 : 	clgame.pmove->memfgets = COM_MemFgets;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325040], OFFSET _COM_MemFgets

; 1015 : 	clgame.pmove->PM_PlaySound = pfnPlaySound;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325048], OFFSET _pfnPlaySound

; 1016 : 	clgame.pmove->PM_TraceTexture = pfnTraceTexture;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325052], OFFSET _pfnTraceTexture

; 1017 : 	clgame.pmove->PM_PlaybackEventFull = pfnPlaybackEventFull;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325056], OFFSET _pfnPlaybackEventFull

; 1018 : 	clgame.pmove->PM_PlayerTraceEx = pfnPlayerTraceEx;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325060], OFFSET _pfnPlayerTraceEx

; 1019 : 	clgame.pmove->PM_TestPlayerPositionEx = pfnTestPlayerPositionEx;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325064], OFFSET _pfnTestPlayerPositionEx

; 1020 : 	clgame.pmove->PM_TraceLineEx = pfnTraceLineEx;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325068], OFFSET _pfnTraceLineEx

; 1021 : 	clgame.pmove->PM_TraceSurface = pfnTraceSurface;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+325072], OFFSET _pfnTraceSurface

; 1022 : 
; 1023 : 	// initalize pmove
; 1024 : 	clgame.dllFuncs.pfnPlayerMoveInit( clgame.pmove );

	mov	eax, DWORD PTR _clgame+1344
	push	eax
	call	DWORD PTR _clgame+32
	add	esp, 4

; 1025 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetSolidPlayers
_TEXT	SEGMENT
_i$ = -16						; size = 4
_pe$ = -12						; size = 4
_player$ = -8						; size = 4
_state$ = -4						; size = 4
_playernum$ = 8						; size = 4
_CL_SetSolidPlayers PROC				; COMDAT

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 543  : 	entity_state_t	*state;
; 544  : 	predicted_player_t	*player;
; 545  : 	physent_t		*pe;
; 546  : 	int		i;
; 547  : 
; 548  : 	if( !cl_solid_players->value )

	mov	eax, DWORD PTR _cl_solid_players
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_SetSoli

; 549  : 		return;

	jmp	$LN3@CL_SetSoli
$LN5@CL_SetSoli:

; 550  : 
; 551  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetSoli
$LN2@CL_SetSoli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetSoli:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_SetSoli

; 552  : 	{
; 553  : 		state = &cl.frames[cl.parsecountmod].playerstate[i];

	imul	eax, DWORD PTR _cl+12, 24056
	imul	ecx, DWORD PTR _i$[ebp], 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	DWORD PTR _state$[ebp], edx

; 554  : 		player = &cls.predicted_players[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _cls+295016
	mov	DWORD PTR _player$[ebp], eax

; 555  : 
; 556  : 		if( playernum == -1 )

	cmp	DWORD PTR _playernum$[ebp], -1
	jne	SHORT $LN6@CL_SetSoli

; 557  : 		{
; 558  : 			if( i != cl.playernum && !player->active )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	je	SHORT $LN8@CL_SetSoli
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN8@CL_SetSoli

; 559  : 				continue;

	jmp	SHORT $LN2@CL_SetSoli
$LN8@CL_SetSoli:

; 560  : 		}

	jmp	SHORT $LN10@CL_SetSoli
$LN6@CL_SetSoli:

; 561  : 		else
; 562  : 		{
; 563  : 			if( !player->active )

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@CL_SetSoli

; 564  : 				continue;	// not present this frame

	jmp	SHORT $LN2@CL_SetSoli
$LN9@CL_SetSoli:

; 565  : 
; 566  : 			// the player object never gets added
; 567  : 			if( playernum == i )

	mov	eax, DWORD PTR _playernum$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN10@CL_SetSoli

; 568  : 				continue;

	jmp	SHORT $LN2@CL_SetSoli
$LN10@CL_SetSoli:

; 569  : 		}
; 570  : 
; 571  : 		if( player->solid == SOLID_NOT )

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@CL_SetSoli

; 572  : 			continue;	// dead body

	jmp	SHORT $LN2@CL_SetSoli
$LN11@CL_SetSoli:

; 573  : 
; 574  : 		if( clgame.pmove->numphysent >= MAX_PHYSENTS )

	mov	eax, DWORD PTR _clgame+1344
	cmp	DWORD PTR [eax+588], 600		; 00000258H
	jl	SHORT $LN12@CL_SetSoli

; 575  : 			break;

	jmp	$LN3@CL_SetSoli
$LN12@CL_SetSoli:

; 576  : 
; 577  : 		pe = &clgame.pmove->physents[clgame.pmove->numphysent];

	mov	eax, DWORD PTR _clgame+1344
	imul	ecx, DWORD PTR [eax+588], 224
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+592]
	mov	DWORD PTR _pe$[ebp], eax

; 578  : 		CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 579  : 		clgame.pmove->numphysent++;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1344
	mov	DWORD PTR [edx+588], ecx

; 580  : 
; 581  : 		// some fields needs to be override from cls.predicted_players
; 582  : 		VectorCopy( player->origin, pe->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+36], eax

; 583  : 		VectorCopy( player->angles, pe->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+84], eax

; 584  : 		VectorCopy( clgame.pmove->player_mins[player->usehull], pe->mins );

	mov	eax, DWORD PTR _player$[ebp]
	imul	ecx, DWORD PTR [eax+8], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [esi+ecx+56], edx
	mov	eax, DWORD PTR _player$[ebp]
	imul	ecx, DWORD PTR [eax+8], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx+56], eax
	mov	ecx, DWORD PTR _player$[ebp]
	imul	edx, DWORD PTR [ecx+8], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+56], ecx

; 585  : 		VectorCopy( clgame.pmove->player_maxs[player->usehull], pe->maxs );

	mov	eax, DWORD PTR _player$[ebp]
	imul	ecx, DWORD PTR [eax+8], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [esi+ecx+68], edx
	mov	eax, DWORD PTR _player$[ebp]
	imul	ecx, DWORD PTR [eax+8], 12
	mov	edx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx+68], eax
	mov	ecx, DWORD PTR _player$[ebp]
	imul	edx, DWORD PTR [ecx+8], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+68], ecx

; 586  : 		pe->movetype = player->movetype;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+124], edx

; 587  : 		pe->solid = player->solid;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+96], edx

; 588  : 	}

	jmp	$LN2@CL_SetSoli
$LN3@CL_SetSoli:

; 589  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetSolidPlayers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_SetSolidEntities
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_CL_SetSolidEntities PROC				; COMDAT

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 509  : 	physent_t	*pe = clgame.pmove->physents;

	mov	eax, DWORD PTR _clgame+1344
	add	eax, 592				; 00000250H
	mov	DWORD PTR _pe$[ebp], eax

; 510  : 
; 511  : 	// setup physents
; 512  : 	clgame.pmove->numvisent = 1;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+149332], 1

; 513  : 	clgame.pmove->numphysent = 1;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+588], 1

; 514  : 	clgame.pmove->nummoveent = 0;

	mov	eax, DWORD PTR _clgame+1344
	mov	DWORD PTR [eax+134992], 0

; 515  : 
; 516  : 	memset( clgame.pmove->physents, 0, sizeof( physent_t ));

	push	224					; 000000e0H
	push	0
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 592				; 00000250H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 517  : 	memset( clgame.pmove->visents, 0, sizeof( physent_t ));

	push	224					; 000000e0H
	push	0
	mov	eax, DWORD PTR _clgame+1344
	add	eax, 149336				; 00024758H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 518  : 
; 519  : 	pe->model = cl.worldmodel;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _cl+4579004
	mov	DWORD PTR [eax+48], ecx

; 520  : 	if( pe->model ) Q_strncpy( pe->name, pe->model->name, sizeof( pe->name ));

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN2@CL_SetSoli
	push	32					; 00000020H
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN2@CL_SetSoli:

; 521  : 	pe->takedamage = DAMAGE_YES;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+128], 1

; 522  : 	pe->solid = SOLID_BSP;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+96], 4

; 523  : 
; 524  : 	// share to visents
; 525  : 	clgame.pmove->visents[0] = clgame.pmove->physents[0];

	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clgame+1344
	lea	esi, DWORD PTR [edx+ecx+592]
	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clgame+1344
	lea	edi, DWORD PTR [edx+ecx+149336]
	mov	ecx, 56					; 00000038H
	rep movsd

; 526  : 
; 527  : 	// add all other entities exlucde players
; 528  : 	CL_AddLinksToPmove( &cl.frames[cl.parsecountmod] );

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_AddLinksToPmove
	add	esp, 4

; 529  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetSolidEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_pmove.c
;	COMDAT _CL_ClipPMoveToEntity
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_tr$ = 28						; size = 4
_CL_ClipPMoveToEntity PROC				; COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 332  : 	Assert( tr != NULL );

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN5@CL_ClipPMo
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@CL_ClipPMo
$LN5@CL_ClipPMo:
	mov	DWORD PTR tv70[ebp], 0
$LN6@CL_ClipPMo:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ClipPMoveToEntity@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@EDEEDIAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 333  : 
; 334  : 	if( clgame.dllFuncs.pfnClipMoveToEntity != NULL )

	cmp	DWORD PTR _clgame+172, 0
	je	SHORT $LN2@CL_ClipPMo

; 335  : 	{
; 336  : 		// do custom sweep test
; 337  : 		clgame.dllFuncs.pfnClipMoveToEntity( pe, start, mins, maxs, end, tr );

	mov	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	DWORD PTR _clgame+172
	add	esp, 24					; 00000018H

; 338  : 	}

	jmp	SHORT $LN1@CL_ClipPMo
$LN2@CL_ClipPMo:

; 339  : 	else
; 340  : 	{
; 341  : 		// function is missed, so we didn't hit anything
; 342  : 		tr->allsolid = false;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@CL_ClipPMo:

; 343  : 	}
; 344  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClipPMoveToEntity ENDP
_TEXT	ENDS
END
