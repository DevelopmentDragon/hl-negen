; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_remap.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_CL_GetRemapInfoForEntity
PUBLIC	_CL_AllocRemapInfo
PUBLIC	_CL_FreeRemapInfo
PUBLIC	_CL_UpdateRemapInfo
PUBLIC	_CL_ClearAllRemaps
PUBLIC	_CL_CmpStudioTextures
PUBLIC	_CL_CreateRawTextureFromPixels
PUBLIC	_CL_DuplicateTexture
PUBLIC	_CL_UpdateStudioTexture
PUBLIC	_CL_UpdateAliasTexture
PUBLIC	?__LINE__Var@?0??CL_CreateRawTextureFromPixels@@9@9 ; `CL_CreateRawTextureFromPixels'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0N@COGEHGDH@size?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0BF@PKDBDOEA@?$CDraw_remap_image?4mdl@	; `string'
PUBLIC	?__LINE__Var@?0??CL_DuplicateTexture@@9@9	; `CL_DuplicateTexture'::`1'::__LINE__Var
PUBLIC	??_C@_06PGHPDDPD@?$CD?$CFi_?$CFs@		; `string'
PUBLIC	??_C@_0L@HIHEOGNE@tx?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??CL_UpdateStudioTexture@@9@9	; `CL_UpdateStudioTexture'::`1'::__LINE__Var
PUBLIC	??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@	; `string'
PUBLIC	??_C@_0CH@KNKKFMPB@?$FO1Error?3?$FO7?5Couldn?8t?5update?5text@ ; `string'
PUBLIC	??_C@_0BJ@OCLHGLMK@index?5?$DN?$DN?5ptexture?9?$DOindex@ ; `string'
PUBLIC	??_C@_0O@IILCKGPB@?$CFs?3remap?$CFi_?$CFi@	; `string'
PUBLIC	?__LINE__Var@?0??CL_AllocRemapInfo@@9@9		; `CL_AllocRemapInfo'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CL_FreeRemapInfo@@9@9		; `CL_FreeRemapInfo'::`1'::__LINE__Var
PUBLIC	??_C@_0N@GHGKJJIB@info?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??CL_ClearAllRemaps@@9@9		; `CL_ClearAllRemaps'::`1'::__LINE__Var
PUBLIC	__real@bf800000
EXTRN	_memcpy:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_CopyImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_PaletteHueReplace:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Mod_AliasExtradata:PROC
EXTRN	_Mod_StudioExtradata:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_GL_ProcessTexture:PROC
EXTRN	_GL_FindTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_clgame:BYTE
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?pin@?1??CL_CreateRawTextureFromPixels@@9@9 DB 050H DUP (?) ; `CL_CreateRawTextureFromPixels'::`2'::pin
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ClearAllRemaps@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ClearAllRemaps@@9@9 DD 01a4H	; `CL_ClearAllRemaps'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@GHGKJJIB@info?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@GHGKJJIB@info?5?$CB?$DN?5NULL@ DB 'info != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_FreeRemapInfo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_FreeRemapInfo@@9@9 DD 0187H		; `CL_FreeRemapInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CL_AllocRemapInfo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_AllocRemapInfo@@9@9 DD 0f3H		; `CL_AllocRemapInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@IILCKGPB@?$CFs?3remap?$CFi_?$CFi@
CONST	SEGMENT
??_C@_0O@IILCKGPB@?$CFs?3remap?$CFi_?$CFi@ DB '%s:remap%i_%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OCLHGLMK@index?5?$DN?$DN?5ptexture?9?$DOindex@
CONST	SEGMENT
??_C@_0BJ@OCLHGLMK@index?5?$DN?$DN?5ptexture?9?$DOindex@ DB 'index == pte'
	DB	'xture->index', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KNKKFMPB@?$FO1Error?3?$FO7?5Couldn?8t?5update?5text@
CONST	SEGMENT
??_C@_0CH@KNKKFMPB@?$FO1Error?3?$FO7?5Couldn?8t?5update?5text@ DB '^1Erro'
	DB	'r:^7 Couldn''t update texture %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@
CONST	SEGMENT
??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@ DB '#%s/%s.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_UpdateStudioTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_UpdateStudioTexture@@9@9 DD 08fH	; `CL_UpdateStudioTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@HIHEOGNE@tx?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@HIHEOGNE@tx?5?$CB?$DN?5NULL@ DB 'tx != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGHPDDPD@?$CD?$CFi_?$CFs@
CONST	SEGMENT
??_C@_06PGHPDDPD@?$CD?$CFi_?$CFs@ DB '#%i_%s', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_DuplicateTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_DuplicateTexture@@9@9 DD 065H	; `CL_DuplicateTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@PKDBDOEA@?$CDraw_remap_image?4mdl@
CONST	SEGMENT
??_C@_0BF@PKDBDOEA@?$CDraw_remap_image?4mdl@ DB '#raw_remap_image.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COGEHGDH@size?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@COGEHGDH@size?5?$CB?$DN?5NULL@ DB 'size != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_remap.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_CreateRawTextureFromPixels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_CreateRawTextureFromPixels@@9@9 DD 046H ; `CL_CreateRawTextureFromPixels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	012bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0268H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	019bH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_UpdateAliasTexture
_TEXT	SEGMENT
_tx$ = -112						; size = 4
_pic$ = -108						; size = 4
_skin$ = -104						; size = 36
_texname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_texture$ = 8						; size = 4
_skinnum$ = 12						; size = 4
_topcolor$ = 16						; size = 4
_bottomcolor$ = 20					; size = 4
_CL_UpdateAliasTexture PROC				; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 204  : 	char	texname[MAX_QPATH];
; 205  : 	rgbdata_t	skin, *pic;
; 206  : 	texture_t	*tx;
; 207  : 
; 208  : 	if( !texture || !RI.currentmodel->textures )

	cmp	DWORD PTR _texture$[ebp], 0
	je	SHORT $LN3@CL_UpdateA
	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+372], 0
	jne	SHORT $LN2@CL_UpdateA
$LN3@CL_UpdateA:

; 209  : 		return; // no remapinfo in model

	jmp	$LN1@CL_UpdateA
$LN2@CL_UpdateA:

; 210  : 
; 211  : 	tx = RI.currentmodel->textures[skinnum];

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 212  : 	if( !tx ) return; // missing texture ?

	cmp	DWORD PTR _tx$[ebp], 0
	jne	SHORT $LN4@CL_UpdateA
	jmp	$LN1@CL_UpdateA
$LN4@CL_UpdateA:

; 213  : 
; 214  : 	if( *texture == 0 )

	mov	eax, DWORD PTR _texture$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	$LN5@CL_UpdateA

; 215  : 	{
; 216  : 		Q_snprintf( texname, sizeof( texname ), "%s:remap%i_%i", RI.currentmodel->name, skinnum, RI.currententity->index );

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _skinnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _RI+32
	push	eax
	push	OFFSET ??_C@_0O@IILCKGPB@?$CFs?3remap?$CFi_?$CFi@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 217  : 		skin.width = tx->width;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR _skin$[ebp], cx

; 218  : 		skin.height = tx->height;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	cx, WORD PTR [eax+20]
	mov	WORD PTR _skin$[ebp+2], cx

; 219  : 		skin.depth = skin.numMips = 1;

	mov	BYTE PTR _skin$[ebp+18], 1
	movzx	ax, BYTE PTR _skin$[ebp+18]
	mov	WORD PTR _skin$[ebp+4], ax

; 220  : 		skin.size = tx->width * tx->height;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _skin$[ebp+32], edx

; 221  : 		skin.type = PF_INDEXED_24;

	mov	DWORD PTR _skin$[ebp+8], 1

; 222  : 		skin.flags = IMAGE_HAS_COLOR|IMAGE_QUAKEPAL;

	mov	DWORD PTR _skin$[ebp+12], 1028		; 00000404H

; 223  : 		skin.encode = DXT_ENCODE_DEFAULT;

	xor	eax, eax
	mov	WORD PTR _skin$[ebp+16], ax

; 224  : 		skin.buffer = (byte *)(tx + 1);

	mov	eax, DWORD PTR _tx$[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR _skin$[ebp+24], eax

; 225  : 		skin.palette = skin.buffer + skin.size;

	mov	eax, DWORD PTR _skin$[ebp+24]
	add	eax, DWORD PTR _skin$[ebp+32]
	mov	DWORD PTR _skin$[ebp+20], eax

; 226  : 		pic = FS_CopyImage( &skin ); // because GL_LoadTextureInternal will freed a rgbdata_t at end

	lea	eax, DWORD PTR _skin$[ebp]
	push	eax
	call	_FS_CopyImage
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax

; 227  : 		*texture = GL_LoadTextureInternal( texname, pic, TF_KEEP_SOURCE );

	push	0
	push	2
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _texture$[ebp]
	mov	WORD PTR [edx], ax
$LN5@CL_UpdateA:

; 228  : 	}
; 229  : 
; 230  : 	// and now we can remap with internal routines
; 231  : 	GL_ProcessTexture( *texture, -1.0f, topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _texture$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_GL_ProcessTexture
	add	esp, 16					; 00000010H
$LN1@CL_UpdateA:

; 232  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateAliasTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_UpdateStudioTexture
_TEXT	SEGMENT
tv170 = -1384						; size = 4
tv129 = -1384						; size = 4
_pal$ = -1188						; size = 4
_raw$ = -1184						; size = 4
_paletteBackup$ = -1180					; size = 768
_index$ = -412						; size = 4
_size$ = -408						; size = 4
_i$ = -404						; size = 4
_mdlname$ = -400					; size = 128
_name$ = -272						; size = 128
_texname$ = -144					; size = 128
_tx$ = -16						; size = 4
_pic$ = -12						; size = 4
_glt$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ptexture$ = 8						; size = 4
_topcolor$ = 12						; size = 4
_bottomcolor$ = 16					; size = 4
_CL_UpdateStudioTexture PROC				; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1384				; 00000568H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 144  : 	gl_texture_t	*glt;
; 145  : 	rgbdata_t		*pic;
; 146  : 	texture_t		*tx = NULL;

	mov	DWORD PTR _tx$[ebp], 0

; 147  : 	char		texname[128], name[128], mdlname[128];
; 148  : 	int		i, size, index;
; 149  : 	byte		paletteBackup[768];
; 150  : 	byte		*raw, *pal;
; 151  : 
; 152  : 	// save off the real texture index
; 153  : 	glt = R_GetTexture( ptexture->index );

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 154  : 
; 155  : 	// build name of original texture
; 156  : 	Q_strncpy( mdlname, RI.currentmodel->name, sizeof( mdlname ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _RI+32
	push	eax
	lea	ecx, DWORD PTR _mdlname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 157  : 	COM_FileBase( ptexture->name, name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptexture$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 158  : 	COM_StripExtension( mdlname );

	lea	eax, DWORD PTR _mdlname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 159  : 
; 160  : 	Q_snprintf( texname, sizeof( texname ), "#%s/%s.mdl", mdlname, name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mdlname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@
	push	128					; 00000080H
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 161  : 	index = GL_FindTexture( texname );

	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_GL_FindTexture
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax

; 162  : 	if( !index ) return; // couldn't find texture

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN5@CL_UpdateS
	jmp	$LN1@CL_UpdateS
$LN5@CL_UpdateS:

; 163  : 
; 164  : 	// search for pixels
; 165  : 	for( i = 0; i < RI.currentmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_UpdateS
$LN2@CL_UpdateS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_UpdateS:
	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@CL_UpdateS

; 166  : 	{
; 167  : 		tx = RI.currentmodel->textures[i];

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 168  : 		if( tx->gl_texturenum == index )

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _index$[ebp]
	jne	SHORT $LN6@CL_UpdateS

; 169  : 			break; // found

	jmp	SHORT $LN3@CL_UpdateS
$LN6@CL_UpdateS:

; 170  : 	}

	jmp	SHORT $LN2@CL_UpdateS
$LN3@CL_UpdateS:

; 171  : 
; 172  : 	Assert( tx != NULL );

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN9@CL_UpdateS
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN10@CL_UpdateS
$LN9@CL_UpdateS:
	mov	DWORD PTR tv129[ebp], 0
$LN10@CL_UpdateS:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_UpdateStudioTexture@@9@9
	add	eax, 29					; 0000001dH
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@HIHEOGNE@tx?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 173  : 
; 174  : 	// backup original palette
; 175  : 	pal = (byte *)(tx + 1) + (tx->width * tx->height);

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _tx$[ebp]
	lea	ecx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR _pal$[ebp], ecx

; 176  : 	memcpy( paletteBackup, pal, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _paletteBackup$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 177  : 
; 178  : 	raw = CL_CreateRawTextureFromPixels( tx, &size, topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	call	_CL_CreateRawTextureFromPixels
	add	esp, 16					; 00000010H
	mov	DWORD PTR _raw$[ebp], eax

; 179  : 	pic = FS_LoadImage( glt->name, raw, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glt$[ebp]
	push	edx
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax

; 180  : 	if( !pic )

	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN7@CL_UpdateS

; 181  : 	{
; 182  : 		Con_DPrintf( S_ERROR "Couldn't update texture %s\n", glt->name );

	mov	eax, DWORD PTR _glt$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@KNKKFMPB@?$FO1Error?3?$FO7?5Couldn?8t?5update?5text@
	call	_Con_DPrintf
	add	esp, 8

; 183  : 		return;

	jmp	$LN1@CL_UpdateS
$LN7@CL_UpdateS:

; 184  : 	}
; 185  : 
; 186  : 	index = GL_UpdateTextureInternal( glt->name, pic, 0 );

	push	1
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _glt$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _index$[ebp], eax

; 187  : 	FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 188  : 
; 189  : 	// restore original palette
; 190  : 	memcpy( pal, paletteBackup, 768 );

	push	768					; 00000300H
	lea	eax, DWORD PTR _paletteBackup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pal$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 191  : 
; 192  : 	Assert( index == ptexture->index );

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	jne	SHORT $LN11@CL_UpdateS
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN12@CL_UpdateS
$LN11@CL_UpdateS:
	mov	DWORD PTR tv170[ebp], 0
$LN12@CL_UpdateS:
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??CL_UpdateStudioTexture@@9@9
	add	edx, 49					; 00000031H
	push	edx
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@OCLHGLMK@index?5?$DN?$DN?5ptexture?9?$DOindex@
	mov	eax, DWORD PTR tv170[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H
$LN1@CL_UpdateS:

; 193  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateStudioTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_DuplicateTexture
_TEXT	SEGMENT
tv89 = -1060						; size = 4
_pal$ = -928						; size = 4
_raw$ = -924						; size = 4
_paletteBackup$ = -920					; size = 768
_index$ = -152						; size = 4
_size$ = -148						; size = 4
_i$ = -144						; size = 4
_texname$ = -140					; size = 128
_tx$ = -12						; size = 4
_glt$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ptexture$ = 8						; size = 4
_topcolor$ = 12						; size = 4
_bottomcolor$ = 16					; size = 4
_CL_DuplicateTexture PROC				; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 102  : 	gl_texture_t	*glt;
; 103  : 	texture_t		*tx = NULL;

	mov	DWORD PTR _tx$[ebp], 0

; 104  : 	char		texname[128];
; 105  : 	int		i, size, index;
; 106  : 	byte		paletteBackup[768];
; 107  : 	byte		*raw, *pal;
; 108  : 
; 109  : 	// save off the real texture index
; 110  : 	index = ptexture->index;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _index$[ebp], ecx

; 111  : 	glt = R_GetTexture( index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 112  : 	Q_snprintf( texname, sizeof( texname ), "#%i_%s", RI.currententity->curstate.number, glt->name + 1 );

	mov	eax, DWORD PTR _glt$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+916]
	push	edx
	push	OFFSET ??_C@_06PGHPDDPD@?$CD?$CFi_?$CFs@
	push	128					; 00000080H
	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 113  : 
; 114  : 	// search for pixels
; 115  : 	for( i = 0; i < RI.currentmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_Duplica
$LN2@CL_Duplica:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Duplica:
	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@CL_Duplica

; 116  : 	{
; 117  : 		tx = RI.currentmodel->textures[i];

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 118  : 		if( tx->gl_texturenum == index )

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _index$[ebp]
	jne	SHORT $LN5@CL_Duplica

; 119  : 			break; // found

	jmp	SHORT $LN3@CL_Duplica
$LN5@CL_Duplica:

; 120  : 	}

	jmp	SHORT $LN2@CL_Duplica
$LN3@CL_Duplica:

; 121  : 
; 122  : 	Assert( tx != NULL );

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN7@CL_Duplica
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN8@CL_Duplica
$LN7@CL_Duplica:
	mov	DWORD PTR tv89[ebp], 0
$LN8@CL_Duplica:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_DuplicateTexture@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@HIHEOGNE@tx?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 123  : 
; 124  : 	// backup original palette
; 125  : 	pal = (byte *)(tx + 1) + (tx->width * tx->height);

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _tx$[ebp]
	lea	ecx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR _pal$[ebp], ecx

; 126  : 	memcpy( paletteBackup, pal, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _paletteBackup$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 127  : 
; 128  : 	raw = CL_CreateRawTextureFromPixels( tx, &size, topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	call	_CL_CreateRawTextureFromPixels
	add	esp, 16					; 00000010H
	mov	DWORD PTR _raw$[ebp], eax

; 129  : 	ptexture->index = GL_LoadTexture( texname, raw, size, TF_FORCE_COLOR ); // do copy

	push	131072					; 00020000H
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 130  : 
; 131  : 	// restore original palette
; 132  : 	memcpy( pal, paletteBackup, 768 );

	push	768					; 00000300H
	lea	eax, DWORD PTR _paletteBackup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pal$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DuplicateTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_CreateRawTextureFromPixels
_TEXT	SEGMENT
tv70 = -72						; size = 4
_pal$ = -4						; size = 4
_tx$ = 8						; size = 4
_size$ = 12						; size = 4
_topcolor$ = 16						; size = 4
_bottomcolor$ = 20					; size = 4
_CL_CreateRawTextureFromPixels PROC			; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 71   : 	static mstudiotexture_t	pin;
; 72   : 	byte			*pal;
; 73   : 
; 74   : 	Assert( size != NULL );

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN4@CL_CreateR
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@CL_CreateR
$LN4@CL_CreateR:
	mov	DWORD PTR tv70[ebp], 0
$LN5@CL_CreateR:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_CreateRawTextureFromPixels@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@COGEHGDH@size?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 75   : 
; 76   : 	*size = sizeof( pin ) + (tx->width * tx->height) + 768;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	add	edx, 848				; 00000350H
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], edx

; 77   : 
; 78   : 	// fill header
; 79   : 	if( !pin.name[0] ) Q_strncpy( pin.name, "#raw_remap_image.mdl", sizeof( pin.name ));

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR ?pin@?1??CL_CreateRawTextureFromPixels@@9@9[ecx]
	test	edx, edx
	jne	SHORT $LN2@CL_CreateR
	push	64					; 00000040H
	push	OFFSET ??_C@_0BF@PKDBDOEA@?$CDraw_remap_image?4mdl@
	push	OFFSET ?pin@?1??CL_CreateRawTextureFromPixels@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN2@CL_CreateR:

; 80   : 	pin.flags = STUDIO_NF_COLORMAP; // just in case :-)

	mov	DWORD PTR ?pin@?1??CL_CreateRawTextureFromPixels@@9@9+64, 1073741824 ; 40000000H

; 81   : 	pin.index = (int)(tx + 1); // pointer to pixels

	mov	eax, DWORD PTR _tx$[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR ?pin@?1??CL_CreateRawTextureFromPixels@@9@9+76, eax

; 82   : 	pin.width = tx->width;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR ?pin@?1??CL_CreateRawTextureFromPixels@@9@9+68, ecx

; 83   : 	pin.height = tx->height;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR ?pin@?1??CL_CreateRawTextureFromPixels@@9@9+72, ecx

; 84   : 
; 85   : 	// update palette
; 86   : 	pal = (byte *)(tx + 1) + (tx->width * tx->height);

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _tx$[ebp]
	lea	ecx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR _pal$[ebp], ecx

; 87   : 	Image_PaletteHueReplace( pal, topcolor, tx->anim_min, tx->anim_max, 3 );

	push	3
	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pal$[ebp]
	push	edx
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H

; 88   : 	Image_PaletteHueReplace( pal, bottomcolor, tx->anim_max + 1, tx->anim_total, 3 );

	push	3
	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _bottomcolor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pal$[ebp]
	push	edx
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H

; 89   : 
; 90   : 	return (byte *)&pin;

	mov	eax, OFFSET ?pin@?1??CL_CreateRawTextureFromPixels@@9@9

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateRawTextureFromPixels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_CmpStudioTextures
_TEXT	SEGMENT
_i$ = -4						; size = 4
_numtexs$ = 8						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
_CL_CmpStudioTextures PROC				; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 47   : 	int	i;
; 48   : 
; 49   : 	if( !p1 || !p2 ) return false;

	cmp	DWORD PTR _p1$[ebp], 0
	je	SHORT $LN6@CL_CmpStud
	cmp	DWORD PTR _p2$[ebp], 0
	jne	SHORT $LN5@CL_CmpStud
$LN6@CL_CmpStud:
	xor	eax, eax
	jmp	SHORT $LN1@CL_CmpStud
$LN5@CL_CmpStud:

; 50   : 
; 51   : 	for( i = 0; i < numtexs; i++, p1++, p2++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_CmpStud
$LN2@CL_CmpStud:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p1$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _p1$[ebp], ecx
	mov	edx, DWORD PTR _p2$[ebp]
	add	edx, 80					; 00000050H
	mov	DWORD PTR _p2$[ebp], edx
$LN4@CL_CmpStud:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numtexs$[ebp]
	jge	SHORT $LN3@CL_CmpStud

; 52   : 	{
; 53   : 		if( p1->flags & STUDIO_NF_COLORMAP )

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN7@CL_CmpStud

; 54   : 			continue;	// colormaps always has different indexes

	jmp	SHORT $LN2@CL_CmpStud
$LN7@CL_CmpStud:

; 55   : 
; 56   : 		if( p1->index != p2->index )

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+76]
	je	SHORT $LN8@CL_CmpStud

; 57   : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_CmpStud
$LN8@CL_CmpStud:

; 58   : 	} 

	jmp	SHORT $LN2@CL_CmpStud
$LN3@CL_CmpStud:

; 59   : 	return true;

	mov	eax, 1
$LN1@CL_CmpStud:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CmpStudioTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_ClearAllRemaps
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearAllRemaps PROC					; COMDAT

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 421  : 	int	i;
; 422  : 
; 423  : 	if( clgame.remap_info )

	cmp	DWORD PTR _clgame+1004, 0
	je	SHORT $LN5@CL_ClearAl

; 424  : 	{
; 425  : 		for( i = 0; i < clgame.maxRemapInfos; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearAl
$LN2@CL_ClearAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearAl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jge	SHORT $LN3@CL_ClearAl

; 426  : 		{
; 427  : 			if( clgame.remap_info[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN6@CL_ClearAl

; 428  : 				CL_FreeRemapInfo( clgame.remap_info[i] ); 

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_FreeRemapInfo
	add	esp, 4
$LN6@CL_ClearAl:

; 429  : 		}

	jmp	SHORT $LN2@CL_ClearAl
$LN3@CL_ClearAl:

; 430  : 		Mem_Free( clgame.remap_info );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ClearAllRemaps@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clgame+1004
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@CL_ClearAl:

; 431  : 	}
; 432  : 	clgame.remap_info = NULL;

	mov	DWORD PTR _clgame+1004, 0

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearAllRemaps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_UpdateRemapInfo
_TEXT	SEGMENT
tv66 = -76						; size = 4
_i$ = -8						; size = 4
_info$ = -4						; size = 4
_topcolor$ = 8						; size = 4
_bottomcolor$ = 12					; size = 4
_CL_UpdateRemapInfo PROC				; COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 359  : 	remap_info_t	*info;
; 360  : 	int		i;
; 361  : 
; 362  : 	i = ( RI.currententity == &clgame.viewent ) ? clgame.maxEntities : RI.currententity->curstate.number;

	cmp	DWORD PTR _RI+28, OFFSET _clgame+260432
	jne	SHORT $LN11@CL_UpdateR
	mov	eax, DWORD PTR _clgame+1008
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN12@CL_UpdateR
$LN11@CL_UpdateR:
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+916]
	mov	DWORD PTR tv66[ebp], edx
$LN12@CL_UpdateR:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 363  : 	info = clgame.remap_info[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _info$[ebp], edx

; 364  : 	if( !info ) return; // no remap info

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN5@CL_UpdateR
	jmp	$LN1@CL_UpdateR
$LN5@CL_UpdateR:

; 365  : 
; 366  : 	if( info->topcolor == topcolor && info->bottomcolor == bottomcolor )

	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+70]
	cmp	ecx, DWORD PTR _topcolor$[ebp]
	jne	SHORT $LN6@CL_UpdateR
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+72]
	cmp	ecx, DWORD PTR _bottomcolor$[ebp]
	jne	SHORT $LN6@CL_UpdateR

; 367  : 		return; // values is valid

	jmp	$LN1@CL_UpdateR
$LN6@CL_UpdateR:

; 368  : 
; 369  : 	for( i = 0; i < info->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_UpdateR
$LN2@CL_UpdateR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_UpdateR:
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+68]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@CL_UpdateR

; 370  : 	{
; 371  : 		if( info->ptexture != NULL )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN7@CL_UpdateR

; 372  : 		{
; 373  : 			if( FBitSet( info->ptexture[i].flags, STUDIO_NF_COLORMAP ))

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [edx+eax+64]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN9@CL_UpdateR

; 374  : 				CL_UpdateStudioTexture( &info->ptexture[i], topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _info$[ebp]
	add	edx, DWORD PTR [eax+64]
	push	edx
	call	_CL_UpdateStudioTexture
	add	esp, 12					; 0000000cH
$LN9@CL_UpdateR:

; 375  : 		}

	jmp	SHORT $LN8@CL_UpdateR
$LN7@CL_UpdateR:

; 376  : 		else CL_UpdateAliasTexture( &info->textures[i], i, topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	push	edx
	call	_CL_UpdateAliasTexture
	add	esp, 16					; 00000010H
$LN8@CL_UpdateR:

; 377  : 	}

	jmp	SHORT $LN2@CL_UpdateR
$LN3@CL_UpdateR:

; 378  : 
; 379  : 	info->topcolor = topcolor;

	mov	eax, DWORD PTR _info$[ebp]
	mov	cx, WORD PTR _topcolor$[ebp]
	mov	WORD PTR [eax+70], cx

; 380  : 	info->bottomcolor = bottomcolor;

	mov	eax, DWORD PTR _info$[ebp]
	mov	cx, WORD PTR _bottomcolor$[ebp]
	mov	WORD PTR [eax+72], cx
$LN1@CL_UpdateR:

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateRemapInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_FreeRemapInfo
_TEXT	SEGMENT
tv70 = -72						; size = 4
_i$ = -4						; size = 4
_info$ = 8						; size = 4
_CL_FreeRemapInfo PROC					; COMDAT

; 391  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 392  : 	int	i;
; 393  : 
; 394  : 	Assert( info != NULL );

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN9@CL_FreeRem
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@CL_FreeRem
$LN9@CL_FreeRem:
	mov	DWORD PTR tv70[ebp], 0
$LN10@CL_FreeRem:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeRemapInfo@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@GHGKJJIB@info?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 395  : 
; 396  : 	// release all colormap texture copies
; 397  : 	for( i = 0; i < info->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FreeRem
$LN2@CL_FreeRem:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FreeRem:
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+68]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@CL_FreeRem

; 398  : 	{
; 399  : 		if( info->ptexture != NULL )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN5@CL_FreeRem

; 400  : 		{
; 401  : 			if( FBitSet( info->ptexture[i].flags, STUDIO_NF_COLORMAP ))

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [edx+eax+64]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN5@CL_FreeRem

; 402  : 				GL_FreeTexture( info->ptexture[i].index );

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [edx+eax+76]
	push	eax
	call	_GL_FreeTexture
	add	esp, 4
$LN5@CL_FreeRem:

; 403  : 		}
; 404  : 
; 405  : 		if( info->textures[i] != 0 )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN7@CL_FreeRem

; 406  : 			GL_FreeTexture( info->textures[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	call	_GL_FreeTexture
	add	esp, 4
$LN7@CL_FreeRem:

; 407  : 	}

	jmp	SHORT $LN2@CL_FreeRem
$LN3@CL_FreeRem:

; 408  : 
; 409  : 	Mem_Free( info ); // release struct	

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeRemapInfo@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 410  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeRemapInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_AllocRemapInfo
_TEXT	SEGMENT
tv213 = -96						; size = 4
tv158 = -96						; size = 4
tv136 = -96						; size = 4
tv67 = -96						; size = 4
_size$ = -28						; size = 4
_i$ = -24						; size = 4
_dst$ = -20						; size = 4
_src$ = -16						; size = 4
_ahdr$ = -12						; size = 4
_phdr$ = -8						; size = 4
_info$ = -4						; size = 4
_topcolor$ = 8						; size = 4
_bottomcolor$ = 12					; size = 4
_CL_AllocRemapInfo PROC					; COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 244  : 	remap_info_t	*info;
; 245  : 	studiohdr_t	*phdr;
; 246  : 	aliashdr_t	*ahdr;
; 247  : 	mstudiotexture_t	*src, *dst;
; 248  : 	int		i, size;
; 249  : 
; 250  : 	if( !RI.currententity ) return;

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN5@CL_AllocRe
	jmp	$LN1@CL_AllocRe
$LN5@CL_AllocRe:

; 251  : 	i = ( RI.currententity == &clgame.viewent ) ? clgame.maxEntities : RI.currententity->curstate.number;

	cmp	DWORD PTR _RI+28, OFFSET _clgame+260432
	jne	SHORT $LN27@CL_AllocRe
	mov	eax, DWORD PTR _clgame+1008
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN28@CL_AllocRe
$LN27@CL_AllocRe:
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+916]
	mov	DWORD PTR tv67[ebp], edx
$LN28@CL_AllocRe:
	mov	eax, DWORD PTR tv67[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 252  : 
; 253  : 	if( !RI.currentmodel || ( RI.currentmodel->type != mod_alias && RI.currentmodel->type != mod_studio ))

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN7@CL_AllocRe
	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+68], 2
	je	SHORT $LN6@CL_AllocRe
	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+68], 3
	je	SHORT $LN6@CL_AllocRe
$LN7@CL_AllocRe:

; 254  : 	{
; 255  : 		// entity has changed model by another type, release remap info
; 256  : 		if( clgame.remap_info[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN8@CL_AllocRe

; 257  : 		{
; 258  : 			CL_FreeRemapInfo( clgame.remap_info[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_FreeRemapInfo
	add	esp, 4

; 259  : 			clgame.remap_info[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	DWORD PTR [ecx+eax*4], 0
$LN8@CL_AllocRe:

; 260  : 		}
; 261  : 		return; // missed or hide model, ignore it

	jmp	$LN1@CL_AllocRe
$LN6@CL_AllocRe:

; 262  : 	}
; 263  : 
; 264  : 	// model doesn't contains remap textures
; 265  : 	if( RI.currentmodel->numtextures <= 0 )

	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+368], 0
	jg	SHORT $LN9@CL_AllocRe

; 266  : 	{
; 267  : 		// entity has changed model with no remap textures
; 268  : 		if( clgame.remap_info[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN10@CL_AllocRe

; 269  : 		{
; 270  : 			CL_FreeRemapInfo( clgame.remap_info[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_FreeRemapInfo
	add	esp, 4

; 271  : 			clgame.remap_info[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	DWORD PTR [ecx+eax*4], 0
$LN10@CL_AllocRe:

; 272  : 		}
; 273  : 		return;

	jmp	$LN1@CL_AllocRe
$LN9@CL_AllocRe:

; 274  : 	}
; 275  : 
; 276  : 	if( RI.currentmodel->type == mod_studio )

	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+68], 3
	jne	$LN11@CL_AllocRe

; 277  : 	{
; 278  : 		phdr = (studiohdr_t *)Mod_StudioExtradata( RI.currentmodel );

	mov	eax, DWORD PTR _RI+32
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _phdr$[ebp], eax

; 279  : 		if( !phdr ) return;	// bad model?

	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $LN13@CL_AllocRe
	jmp	$LN1@CL_AllocRe
$LN13@CL_AllocRe:

; 280  : 
; 281  : 		src = (mstudiotexture_t *)(((byte *)phdr) + phdr->textureindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _src$[ebp], ecx

; 282  : 		dst = (clgame.remap_info[i] ? clgame.remap_info[i]->ptexture : NULL); 

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN29@CL_AllocRe
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _clgame+1004
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR tv136[ebp], edx
	jmp	SHORT $LN30@CL_AllocRe
$LN29@CL_AllocRe:
	mov	DWORD PTR tv136[ebp], 0
$LN30@CL_AllocRe:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR _dst$[ebp], eax

; 283  : 
; 284  : 		// NOTE: we must copy all the structures 'mstudiotexture_t' for easy access when model is rendering
; 285  : 		if( !CL_CmpStudioTextures( phdr->numtextures, src, dst ) || clgame.remap_info[i]->model != RI.currentmodel )

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	_CL_CmpStudioTextures
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@CL_AllocRe
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR _RI+32
	je	SHORT $LN14@CL_AllocRe
$LN16@CL_AllocRe:

; 286  : 		{
; 287  : 			// this code catches studiomodel change with another studiomodel with remap textures
; 288  : 			// e.g. playermodel 'barney' with playermodel 'gordon'
; 289  : 			if( clgame.remap_info[i] ) CL_FreeRemapInfo( clgame.remap_info[i] ); // free old info

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN17@CL_AllocRe
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_FreeRemapInfo
	add	esp, 4
$LN17@CL_AllocRe:

; 290  : 			size = sizeof( remap_info_t ) + ( sizeof( mstudiotexture_t ) * phdr->numtextures );

	mov	eax, DWORD PTR _phdr$[ebp]
	imul	ecx, DWORD PTR [eax+180], 80
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _size$[ebp], ecx

; 291  : 			info = clgame.remap_info[i] = Mem_Calloc( clgame.mempool, size );	

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_AllocRemapInfo@@9@9
	add	eax, 48					; 00000030H
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+224
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv158[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR tv158[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 292  : 			info->ptexture = (mstudiotexture_t *)(info + 1); // textures are immediately comes after remap_info

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 293  : 		}

	jmp	SHORT $LN15@CL_AllocRe
$LN14@CL_AllocRe:

; 294  : 		else
; 295  : 		{
; 296  : 			// studiomodel is valid, nothing to change
; 297  : 			return;

	jmp	$LN1@CL_AllocRe
$LN15@CL_AllocRe:

; 298  : 		}
; 299  : 
; 300  : 		info->numtextures = phdr->numtextures;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	dx, WORD PTR [ecx+180]
	mov	WORD PTR [eax+68], dx

; 301  : 		info->topcolor = topcolor;

	mov	eax, DWORD PTR _info$[ebp]
	mov	cx, WORD PTR _topcolor$[ebp]
	mov	WORD PTR [eax+70], cx

; 302  : 		info->bottomcolor = bottomcolor;

	mov	eax, DWORD PTR _info$[ebp]
	mov	cx, WORD PTR _bottomcolor$[ebp]
	mov	WORD PTR [eax+72], cx

; 303  : 
; 304  : 		src = (mstudiotexture_t *)(((byte *)phdr) + phdr->textureindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _src$[ebp], ecx

; 305  : 		dst = info->ptexture;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _dst$[ebp], ecx

; 306  : 
; 307  : 		// copy unchanged first
; 308  : 		memcpy( dst, src, sizeof( mstudiotexture_t ) * phdr->numtextures );

	mov	eax, DWORD PTR _phdr$[ebp]
	imul	ecx, DWORD PTR [eax+180], 80
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 309  : 
; 310  : 		// make local copies for remap textures
; 311  : 		for( i = 0; i < info->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_AllocRe
$LN2@CL_AllocRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_AllocRe:
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+68]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@CL_AllocRe

; 312  : 		{
; 313  : 			if( dst[i].flags & STUDIO_NF_COLORMAP )

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+eax+64]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN18@CL_AllocRe

; 314  : 				CL_DuplicateTexture( &dst[i], topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	add	edx, DWORD PTR _dst$[ebp]
	push	edx
	call	_CL_DuplicateTexture
	add	esp, 12					; 0000000cH
$LN18@CL_AllocRe:

; 315  : 		}

	jmp	SHORT $LN2@CL_AllocRe
$LN3@CL_AllocRe:

; 316  : 	}

	jmp	$LN12@CL_AllocRe
$LN11@CL_AllocRe:

; 317  : 	else if( RI.currentmodel->type == mod_alias )

	mov	eax, DWORD PTR _RI+32
	cmp	DWORD PTR [eax+68], 2
	jne	$LN19@CL_AllocRe

; 318  : 	{
; 319  : 		ahdr = (aliashdr_t *)Mod_AliasExtradata( RI.currentmodel );

	mov	eax, DWORD PTR _RI+32
	push	eax
	call	_Mod_AliasExtradata
	add	esp, 4
	mov	DWORD PTR _ahdr$[ebp], eax

; 320  : 		if( !ahdr ) return;	// bad model?

	cmp	DWORD PTR _ahdr$[ebp], 0
	jne	SHORT $LN21@CL_AllocRe
	jmp	$LN1@CL_AllocRe
$LN21@CL_AllocRe:

; 321  : 
; 322  : 		// NOTE: we must copy all the structures 'mstudiotexture_t' for easy access when model is rendering
; 323  : 		if( !clgame.remap_info[i] || clgame.remap_info[i]->model != RI.currentmodel )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN24@CL_AllocRe
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR _RI+32
	je	SHORT $LN22@CL_AllocRe
$LN24@CL_AllocRe:

; 324  : 		{
; 325  : 			// this code catches studiomodel change with another studiomodel with remap textures
; 326  : 			// e.g. playermodel 'barney' with playermodel 'gordon'
; 327  : 			if( clgame.remap_info[i] ) CL_FreeRemapInfo( clgame.remap_info[i] ); // free old info

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN25@CL_AllocRe
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame+1004
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_FreeRemapInfo
	add	esp, 4
$LN25@CL_AllocRe:

; 328  : 			info = clgame.remap_info[i] = Mem_Calloc( clgame.mempool, sizeof( remap_info_t ));	

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_AllocRemapInfo@@9@9
	add	eax, 85					; 00000055H
	push	eax
	push	OFFSET ??_C@_0DF@MKEBDMCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	80					; 00000050H
	mov	ecx, DWORD PTR _clgame+224
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv213[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _clgame+1004
	mov	ecx, DWORD PTR tv213[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR tv213[ebp]
	mov	DWORD PTR _info$[ebp], edx

; 329  : 		}

	jmp	SHORT $LN23@CL_AllocRe
$LN22@CL_AllocRe:

; 330  : 		else
; 331  : 		{
; 332  : 			// aliasmodel is valid, nothing to change
; 333  : 			return;

	jmp	SHORT $LN1@CL_AllocRe
$LN23@CL_AllocRe:

; 334  : 		}
; 335  : 
; 336  : 		info->numtextures = RI.currentmodel->numtextures;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _RI+32
	mov	dx, WORD PTR [ecx+368]
	mov	WORD PTR [eax+68], dx

; 337  : 
; 338  : 		// alias remapping is easy
; 339  : 		CL_UpdateRemapInfo( topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$[ebp]
	push	ecx
	call	_CL_UpdateRemapInfo
	add	esp, 8

; 340  : 	}

	jmp	SHORT $LN12@CL_AllocRe
$LN19@CL_AllocRe:

; 341  : 	else
; 342  : 	{
; 343  : 		// only alias & studio models are supposed for remapping
; 344  : 		return;

	jmp	SHORT $LN1@CL_AllocRe
$LN12@CL_AllocRe:

; 345  : 	}
; 346  : 
; 347  : 	info->model = RI.currentmodel;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _RI+32
	mov	DWORD PTR [eax+76], ecx
$LN1@CL_AllocRe:

; 348  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AllocRemapInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_remap.c
;	COMDAT _CL_GetRemapInfoForEntity
_TEXT	SEGMENT
_e$ = 8							; size = 4
_CL_GetRemapInfoForEntity PROC				; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 30   : 	if( !e ) return NULL;

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN2@CL_GetRema
	xor	eax, eax
	jmp	SHORT $LN1@CL_GetRema
$LN2@CL_GetRema:

; 31   : 
; 32   : 	if( e == &clgame.viewent )

	cmp	DWORD PTR _e$[ebp], OFFSET _clgame+260432
	jne	SHORT $LN3@CL_GetRema

; 33   : 		return clgame.remap_info[clgame.maxEntities];

	mov	eax, DWORD PTR _clgame+1008
	mov	ecx, DWORD PTR _clgame+1004
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN1@CL_GetRema
$LN3@CL_GetRema:

; 34   : 
; 35   : 	return clgame.remap_info[e->curstate.number];

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	mov	edx, DWORD PTR _clgame+1004
	mov	eax, DWORD PTR [edx+ecx*4]
$LN1@CL_GetRema:

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetRemapInfoForEntity ENDP
_TEXT	ENDS
END
