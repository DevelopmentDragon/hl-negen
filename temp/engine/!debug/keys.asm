; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\keys.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_keynames
PUBLIC	??_C@_03CJMDHCGG@TAB@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05EMNIMLKD@ENTER@				; `string'
PUBLIC	??_C@_06CDPDIIDH@ESCAPE@			; `string'
PUBLIC	??_C@_06CHNIFGOF@escape@			; `string'
PUBLIC	??_C@_05CAEOFMEP@SPACE@				; `string'
PUBLIC	??_C@_05MDAFLFGO@?$CLjump@			; `string'
PUBLIC	??_C@_09MALOLBMO@BACKSPACE@			; `string'
PUBLIC	??_C@_07MNCBLHKG@UPARROW@			; `string'
PUBLIC	??_C@_08KKEOHAPB@?$CLforward@			; `string'
PUBLIC	??_C@_09KIDHILFL@DOWNARROW@			; `string'
PUBLIC	??_C@_05IPKGNIPH@?$CLback@			; `string'
PUBLIC	??_C@_09FNHBLDAE@LEFTARROW@			; `string'
PUBLIC	??_C@_05HEGFDNLE@?$CLleft@			; `string'
PUBLIC	??_C@_0L@CIPLPPIL@RIGHTARROW@			; `string'
PUBLIC	??_C@_06NGIHBNMB@?$CLright@			; `string'
PUBLIC	??_C@_03FKEEPDEP@ALT@				; `string'
PUBLIC	??_C@_07CHKKNAEO@?$CLstrafe@			; `string'
PUBLIC	??_C@_04FBBFEIFJ@CTRL@				; `string'
PUBLIC	??_C@_07MAODEHGM@?$CLattack@			; `string'
PUBLIC	??_C@_05OAHIEJBI@SHIFT@				; `string'
PUBLIC	??_C@_06JIDIHCBO@?$CLspeed@			; `string'
PUBLIC	??_C@_08INDENNHK@CAPSLOCK@			; `string'
PUBLIC	??_C@_09ELLGPGEI@SCROLLOCK@			; `string'
PUBLIC	??_C@_02LCPENACN@F1@				; `string'
PUBLIC	??_C@_08IEOLPOJF@cmd?5help@			; `string'
PUBLIC	??_C@_02JJNJIDOO@F2@				; `string'
PUBLIC	??_C@_0O@PCFFFEAC@menu_savegame@		; `string'
PUBLIC	??_C@_02IAMCLCKP@F3@				; `string'
PUBLIC	??_C@_0O@PNIDLKHF@menu_loadgame@		; `string'
PUBLIC	??_C@_02MPIDCEGI@F4@				; `string'
PUBLIC	??_C@_0O@ICCBLHPH@menu_controls@		; `string'
PUBLIC	??_C@_02NGJIBFCJ@F5@				; `string'
PUBLIC	??_C@_0BA@HNKIAHHG@menu_creategame@		; `string'
PUBLIC	??_C@_02PNLFEGOK@F6@				; `string'
PUBLIC	??_C@_09ICFIAJOH@savequick@			; `string'
PUBLIC	??_C@_02OEKOHHKL@F7@				; `string'
PUBLIC	??_C@_09EMDGDLJG@loadquick@			; `string'
PUBLIC	??_C@_02GDDGGLGE@F8@				; `string'
PUBLIC	??_C@_04PEGFANN@stop@				; `string'
PUBLIC	??_C@_02HKCNFKCF@F9@				; `string'
PUBLIC	??_C@_03JKCLJOFG@F10@				; `string'
PUBLIC	??_C@_09PGDBLOJJ@menu_main@			; `string'
PUBLIC	??_C@_03IDDAKPBH@F11@				; `string'
PUBLIC	??_C@_03KIBNPMNE@F12@				; `string'
PUBLIC	??_C@_08HLGCJJEE@snapshot@			; `string'
PUBLIC	??_C@_03NDDFJJAJ@INS@				; `string'
PUBLIC	??_C@_03OAFAKAKL@DEL@				; `string'
PUBLIC	??_C@_09KCKOGCLI@?$CLlookdown@			; `string'
PUBLIC	??_C@_04BOGEOADK@PGDN@				; `string'
PUBLIC	??_C@_07BDFIGFL@?$CLlookup@			; `string'
PUBLIC	??_C@_04NHMBBGKC@PGUP@				; `string'
PUBLIC	??_C@_04GHGFPGNC@HOME@				; `string'
PUBLIC	??_C@_03JMGAKCCH@END@				; `string'
PUBLIC	??_C@_0L@FHIBDANG@centerview@			; `string'
PUBLIC	??_C@_06CAAGCEOP@MOUSE1@			; `string'
PUBLIC	??_C@_06LCLHHCM@MOUSE2@				; `string'
PUBLIC	??_C@_08KJLEJKEF@?$CLattack2@			; `string'
PUBLIC	??_C@_06BCDAEGGN@MOUSE3@			; `string'
PUBLIC	??_C@_08LAKPKLAE@?$CLattack3@			; `string'
PUBLIC	??_C@_06FNHBNAKK@MOUSE4@			; `string'
PUBLIC	??_C@_08PPOODNMD@?$CLattack4@			; `string'
PUBLIC	??_C@_06EEGKOBOL@MOUSE5@			; `string'
PUBLIC	??_C@_08OGPFAMIC@?$CLattack5@			; `string'
PUBLIC	??_C@_08NAKENEKM@MWHEELUP@			; `string'
PUBLIC	??_C@_0L@NBPPJGMJ@MWHEELDOWN@			; `string'
PUBLIC	??_C@_07GOJPFDII@KP_HOME@			; `string'
PUBLIC	??_C@_0L@CCBCEPGH@KP_UPARROW@			; `string'
PUBLIC	??_C@_07NODLLDPI@KP_PGUP@			; `string'
PUBLIC	??_C@_0N@DMPGMABG@KP_LEFTARROW@			; `string'
PUBLIC	??_C@_04BICCMFCD@KP_5@				; `string'
PUBLIC	??_C@_0O@NLCDAJLA@KP_RIGHTARROW@		; `string'
PUBLIC	??_C@_06NAIJNDCL@KP_END@			; `string'
PUBLIC	??_C@_0N@MJLAPIEJ@KP_DOWNARROW@			; `string'
PUBLIC	??_C@_07BHJOEFGA@KP_PGDN@			; `string'
PUBLIC	??_C@_08MHGPIJOM@KP_ENTER@			; `string'
PUBLIC	??_C@_06JPNMOIAF@KP_INS@			; `string'
PUBLIC	??_C@_06KMLJNBKH@KP_DEL@			; `string'
PUBLIC	??_C@_08KHGBLJLO@KP_SLASH@			; `string'
PUBLIC	??_C@_08KDIFPCFL@KP_MINUS@			; `string'
PUBLIC	??_C@_07CCBHGHDK@KP_PLUS@			; `string'
PUBLIC	??_C@_05DIAHPDGL@PAUSE@				; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_09COMJPDLF@SEMICOLON@			; `string'
_DATA	SEGMENT
COMM	_keys:BYTE:01000H
_DATA	ENDS
;	COMDAT ??_C@_09COMJPDLF@SEMICOLON@
CONST	SEGMENT
??_C@_09COMJPDLF@SEMICOLON@ DB 'SEMICOLON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIAHPDGL@PAUSE@
CONST	SEGMENT
??_C@_05DIAHPDGL@PAUSE@ DB 'PAUSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCBHGHDK@KP_PLUS@
CONST	SEGMENT
??_C@_07CCBHGHDK@KP_PLUS@ DB 'KP_PLUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDIFPCFL@KP_MINUS@
CONST	SEGMENT
??_C@_08KDIFPCFL@KP_MINUS@ DB 'KP_MINUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KHGBLJLO@KP_SLASH@
CONST	SEGMENT
??_C@_08KHGBLJLO@KP_SLASH@ DB 'KP_SLASH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMLJNBKH@KP_DEL@
CONST	SEGMENT
??_C@_06KMLJNBKH@KP_DEL@ DB 'KP_DEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPNMOIAF@KP_INS@
CONST	SEGMENT
??_C@_06JPNMOIAF@KP_INS@ DB 'KP_INS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHGPIJOM@KP_ENTER@
CONST	SEGMENT
??_C@_08MHGPIJOM@KP_ENTER@ DB 'KP_ENTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHJOEFGA@KP_PGDN@
CONST	SEGMENT
??_C@_07BHJOEFGA@KP_PGDN@ DB 'KP_PGDN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MJLAPIEJ@KP_DOWNARROW@
CONST	SEGMENT
??_C@_0N@MJLAPIEJ@KP_DOWNARROW@ DB 'KP_DOWNARROW', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NAIJNDCL@KP_END@
CONST	SEGMENT
??_C@_06NAIJNDCL@KP_END@ DB 'KP_END', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLCDAJLA@KP_RIGHTARROW@
CONST	SEGMENT
??_C@_0O@NLCDAJLA@KP_RIGHTARROW@ DB 'KP_RIGHTARROW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BICCMFCD@KP_5@
CONST	SEGMENT
??_C@_04BICCMFCD@KP_5@ DB 'KP_5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMPGMABG@KP_LEFTARROW@
CONST	SEGMENT
??_C@_0N@DMPGMABG@KP_LEFTARROW@ DB 'KP_LEFTARROW', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NODLLDPI@KP_PGUP@
CONST	SEGMENT
??_C@_07NODLLDPI@KP_PGUP@ DB 'KP_PGUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCBCEPGH@KP_UPARROW@
CONST	SEGMENT
??_C@_0L@CCBCEPGH@KP_UPARROW@ DB 'KP_UPARROW', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOJPFDII@KP_HOME@
CONST	SEGMENT
??_C@_07GOJPFDII@KP_HOME@ DB 'KP_HOME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBPPJGMJ@MWHEELDOWN@
CONST	SEGMENT
??_C@_0L@NBPPJGMJ@MWHEELDOWN@ DB 'MWHEELDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAKENEKM@MWHEELUP@
CONST	SEGMENT
??_C@_08NAKENEKM@MWHEELUP@ DB 'MWHEELUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGPFAMIC@?$CLattack5@
CONST	SEGMENT
??_C@_08OGPFAMIC@?$CLattack5@ DB '+attack5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EEGKOBOL@MOUSE5@
CONST	SEGMENT
??_C@_06EEGKOBOL@MOUSE5@ DB 'MOUSE5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPOODNMD@?$CLattack4@
CONST	SEGMENT
??_C@_08PPOODNMD@?$CLattack4@ DB '+attack4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNHBNAKK@MOUSE4@
CONST	SEGMENT
??_C@_06FNHBNAKK@MOUSE4@ DB 'MOUSE4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LAKPKLAE@?$CLattack3@
CONST	SEGMENT
??_C@_08LAKPKLAE@?$CLattack3@ DB '+attack3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCDAEGGN@MOUSE3@
CONST	SEGMENT
??_C@_06BCDAEGGN@MOUSE3@ DB 'MOUSE3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KJLEJKEF@?$CLattack2@
CONST	SEGMENT
??_C@_08KJLEJKEF@?$CLattack2@ DB '+attack2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCLHHCM@MOUSE2@
CONST	SEGMENT
??_C@_06LCLHHCM@MOUSE2@ DB 'MOUSE2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAAGCEOP@MOUSE1@
CONST	SEGMENT
??_C@_06CAAGCEOP@MOUSE1@ DB 'MOUSE1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHIBDANG@centerview@
CONST	SEGMENT
??_C@_0L@FHIBDANG@centerview@ DB 'centerview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMGAKCCH@END@
CONST	SEGMENT
??_C@_03JMGAKCCH@END@ DB 'END', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHGFPGNC@HOME@
CONST	SEGMENT
??_C@_04GHGFPGNC@HOME@ DB 'HOME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHMBBGKC@PGUP@
CONST	SEGMENT
??_C@_04NHMBBGKC@PGUP@ DB 'PGUP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BDFIGFL@?$CLlookup@
CONST	SEGMENT
??_C@_07BDFIGFL@?$CLlookup@ DB '+lookup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BOGEOADK@PGDN@
CONST	SEGMENT
??_C@_04BOGEOADK@PGDN@ DB 'PGDN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCKOGCLI@?$CLlookdown@
CONST	SEGMENT
??_C@_09KCKOGCLI@?$CLlookdown@ DB '+lookdown', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAFAKAKL@DEL@
CONST	SEGMENT
??_C@_03OAFAKAKL@DEL@ DB 'DEL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDDFJJAJ@INS@
CONST	SEGMENT
??_C@_03NDDFJJAJ@INS@ DB 'INS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HLGCJJEE@snapshot@
CONST	SEGMENT
??_C@_08HLGCJJEE@snapshot@ DB 'snapshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KIBNPMNE@F12@
CONST	SEGMENT
??_C@_03KIBNPMNE@F12@ DB 'F12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDDAKPBH@F11@
CONST	SEGMENT
??_C@_03IDDAKPBH@F11@ DB 'F11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGDBLOJJ@menu_main@
CONST	SEGMENT
??_C@_09PGDBLOJJ@menu_main@ DB 'menu_main', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKCLJOFG@F10@
CONST	SEGMENT
??_C@_03JKCLJOFG@F10@ DB 'F10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HKCNFKCF@F9@
CONST	SEGMENT
??_C@_02HKCNFKCF@F9@ DB 'F9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEGFANN@stop@
CONST	SEGMENT
??_C@_04PEGFANN@stop@ DB 'stop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GDDGGLGE@F8@
CONST	SEGMENT
??_C@_02GDDGGLGE@F8@ DB 'F8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMDGDLJG@loadquick@
CONST	SEGMENT
??_C@_09EMDGDLJG@loadquick@ DB 'loadquick', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OEKOHHKL@F7@
CONST	SEGMENT
??_C@_02OEKOHHKL@F7@ DB 'F7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICFIAJOH@savequick@
CONST	SEGMENT
??_C@_09ICFIAJOH@savequick@ DB 'savequick', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PNLFEGOK@F6@
CONST	SEGMENT
??_C@_02PNLFEGOK@F6@ DB 'F6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HNKIAHHG@menu_creategame@
CONST	SEGMENT
??_C@_0BA@HNKIAHHG@menu_creategame@ DB 'menu_creategame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NGJIBFCJ@F5@
CONST	SEGMENT
??_C@_02NGJIBFCJ@F5@ DB 'F5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICCBLHPH@menu_controls@
CONST	SEGMENT
??_C@_0O@ICCBLHPH@menu_controls@ DB 'menu_controls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPIDCEGI@F4@
CONST	SEGMENT
??_C@_02MPIDCEGI@F4@ DB 'F4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PNIDLKHF@menu_loadgame@
CONST	SEGMENT
??_C@_0O@PNIDLKHF@menu_loadgame@ DB 'menu_loadgame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAMCLCKP@F3@
CONST	SEGMENT
??_C@_02IAMCLCKP@F3@ DB 'F3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PCFFFEAC@menu_savegame@
CONST	SEGMENT
??_C@_0O@PCFFFEAC@menu_savegame@ DB 'menu_savegame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJNJIDOO@F2@
CONST	SEGMENT
??_C@_02JJNJIDOO@F2@ DB 'F2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IEOLPOJF@cmd?5help@
CONST	SEGMENT
??_C@_08IEOLPOJF@cmd?5help@ DB 'cmd help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LCPENACN@F1@
CONST	SEGMENT
??_C@_02LCPENACN@F1@ DB 'F1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELLGPGEI@SCROLLOCK@
CONST	SEGMENT
??_C@_09ELLGPGEI@SCROLLOCK@ DB 'SCROLLOCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDENNHK@CAPSLOCK@
CONST	SEGMENT
??_C@_08INDENNHK@CAPSLOCK@ DB 'CAPSLOCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIDIHCBO@?$CLspeed@
CONST	SEGMENT
??_C@_06JIDIHCBO@?$CLspeed@ DB '+speed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAHIEJBI@SHIFT@
CONST	SEGMENT
??_C@_05OAHIEJBI@SHIFT@ DB 'SHIFT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAODEHGM@?$CLattack@
CONST	SEGMENT
??_C@_07MAODEHGM@?$CLattack@ DB '+attack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FBBFEIFJ@CTRL@
CONST	SEGMENT
??_C@_04FBBFEIFJ@CTRL@ DB 'CTRL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHKKNAEO@?$CLstrafe@
CONST	SEGMENT
??_C@_07CHKKNAEO@?$CLstrafe@ DB '+strafe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKEEPDEP@ALT@
CONST	SEGMENT
??_C@_03FKEEPDEP@ALT@ DB 'ALT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGIHBNMB@?$CLright@
CONST	SEGMENT
??_C@_06NGIHBNMB@?$CLright@ DB '+right', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIPLPPIL@RIGHTARROW@
CONST	SEGMENT
??_C@_0L@CIPLPPIL@RIGHTARROW@ DB 'RIGHTARROW', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HEGFDNLE@?$CLleft@
CONST	SEGMENT
??_C@_05HEGFDNLE@?$CLleft@ DB '+left', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FNHBLDAE@LEFTARROW@
CONST	SEGMENT
??_C@_09FNHBLDAE@LEFTARROW@ DB 'LEFTARROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPKGNIPH@?$CLback@
CONST	SEGMENT
??_C@_05IPKGNIPH@?$CLback@ DB '+back', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIDHILFL@DOWNARROW@
CONST	SEGMENT
??_C@_09KIDHILFL@DOWNARROW@ DB 'DOWNARROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKEOHAPB@?$CLforward@
CONST	SEGMENT
??_C@_08KKEOHAPB@?$CLforward@ DB '+forward', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNCBLHKG@UPARROW@
CONST	SEGMENT
??_C@_07MNCBLHKG@UPARROW@ DB 'UPARROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MALOLBMO@BACKSPACE@
CONST	SEGMENT
??_C@_09MALOLBMO@BACKSPACE@ DB 'BACKSPACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MDAFLFGO@?$CLjump@
CONST	SEGMENT
??_C@_05MDAFLFGO@?$CLjump@ DB '+jump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAEOFMEP@SPACE@
CONST	SEGMENT
??_C@_05CAEOFMEP@SPACE@ DB 'SPACE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHNIFGOF@escape@
CONST	SEGMENT
??_C@_06CHNIFGOF@escape@ DB 'escape', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDPDIIDH@ESCAPE@
CONST	SEGMENT
??_C@_06CDPDIIDH@ESCAPE@ DB 'ESCAPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMNIMLKD@ENTER@
CONST	SEGMENT
??_C@_05EMNIMLKD@ENTER@ DB 'ENTER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJMDHCGG@TAB@
CONST	SEGMENT
??_C@_03CJMDHCGG@TAB@ DB 'TAB', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_keynames DD	FLAT:??_C@_03CJMDHCGG@TAB@
	DD	09H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_05EMNIMLKD@ENTER@
	DD	0dH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_06CDPDIIDH@ESCAPE@
	DD	01bH
	DD	FLAT:??_C@_06CHNIFGOF@escape@
	DD	FLAT:??_C@_05CAEOFMEP@SPACE@
	DD	020H
	DD	FLAT:??_C@_05MDAFLFGO@?$CLjump@
	DD	FLAT:??_C@_09MALOLBMO@BACKSPACE@
	DD	07fH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_07MNCBLHKG@UPARROW@
	DD	080H
	DD	FLAT:??_C@_08KKEOHAPB@?$CLforward@
	DD	FLAT:??_C@_09KIDHILFL@DOWNARROW@
	DD	081H
	DD	FLAT:??_C@_05IPKGNIPH@?$CLback@
	DD	FLAT:??_C@_09FNHBLDAE@LEFTARROW@
	DD	082H
	DD	FLAT:??_C@_05HEGFDNLE@?$CLleft@
	DD	FLAT:??_C@_0L@CIPLPPIL@RIGHTARROW@
	DD	083H
	DD	FLAT:??_C@_06NGIHBNMB@?$CLright@
	DD	FLAT:??_C@_03FKEEPDEP@ALT@
	DD	084H
	DD	FLAT:??_C@_07CHKKNAEO@?$CLstrafe@
	DD	FLAT:??_C@_04FBBFEIFJ@CTRL@
	DD	085H
	DD	FLAT:??_C@_07MAODEHGM@?$CLattack@
	DD	FLAT:??_C@_05OAHIEJBI@SHIFT@
	DD	086H
	DD	FLAT:??_C@_06JIDIHCBO@?$CLspeed@
	DD	FLAT:??_C@_08INDENNHK@CAPSLOCK@
	DD	0afH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_09ELLGPGEI@SCROLLOCK@
	DD	046H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_02LCPENACN@F1@
	DD	087H
	DD	FLAT:??_C@_08IEOLPOJF@cmd?5help@
	DD	FLAT:??_C@_02JJNJIDOO@F2@
	DD	088H
	DD	FLAT:??_C@_0O@PCFFFEAC@menu_savegame@
	DD	FLAT:??_C@_02IAMCLCKP@F3@
	DD	089H
	DD	FLAT:??_C@_0O@PNIDLKHF@menu_loadgame@
	DD	FLAT:??_C@_02MPIDCEGI@F4@
	DD	08aH
	DD	FLAT:??_C@_0O@ICCBLHPH@menu_controls@
	DD	FLAT:??_C@_02NGJIBFCJ@F5@
	DD	08bH
	DD	FLAT:??_C@_0BA@HNKIAHHG@menu_creategame@
	DD	FLAT:??_C@_02PNLFEGOK@F6@
	DD	08cH
	DD	FLAT:??_C@_09ICFIAJOH@savequick@
	DD	FLAT:??_C@_02OEKOHHKL@F7@
	DD	08dH
	DD	FLAT:??_C@_09EMDGDLJG@loadquick@
	DD	FLAT:??_C@_02GDDGGLGE@F8@
	DD	08eH
	DD	FLAT:??_C@_04PEGFANN@stop@
	DD	FLAT:??_C@_02HKCNFKCF@F9@
	DD	08fH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_03JKCLJOFG@F10@
	DD	090H
	DD	FLAT:??_C@_09PGDBLOJJ@menu_main@
	DD	FLAT:??_C@_03IDDAKPBH@F11@
	DD	091H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_03KIBNPMNE@F12@
	DD	092H
	DD	FLAT:??_C@_08HLGCJJEE@snapshot@
	DD	FLAT:??_C@_03NDDFJJAJ@INS@
	DD	093H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_03OAFAKAKL@DEL@
	DD	094H
	DD	FLAT:??_C@_09KCKOGCLI@?$CLlookdown@
	DD	FLAT:??_C@_04BOGEOADK@PGDN@
	DD	095H
	DD	FLAT:??_C@_07BDFIGFL@?$CLlookup@
	DD	FLAT:??_C@_04NHMBBGKC@PGUP@
	DD	096H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_04GHGFPGNC@HOME@
	DD	097H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_03JMGAKCCH@END@
	DD	098H
	DD	FLAT:??_C@_0L@FHIBDANG@centerview@
	DD	FLAT:??_C@_06CAAGCEOP@MOUSE1@
	DD	0f1H
	DD	FLAT:??_C@_07MAODEHGM@?$CLattack@
	DD	FLAT:??_C@_06LCLHHCM@MOUSE2@
	DD	0f2H
	DD	FLAT:??_C@_08KJLEJKEF@?$CLattack2@
	DD	FLAT:??_C@_06BCDAEGGN@MOUSE3@
	DD	0f3H
	DD	FLAT:??_C@_08LAKPKLAE@?$CLattack3@
	DD	FLAT:??_C@_06FNHBNAKK@MOUSE4@
	DD	0f4H
	DD	FLAT:??_C@_08PPOODNMD@?$CLattack4@
	DD	FLAT:??_C@_06EEGKOBOL@MOUSE5@
	DD	0f5H
	DD	FLAT:??_C@_08OGPFAMIC@?$CLattack5@
	DD	FLAT:??_C@_08NAKENEKM@MWHEELUP@
	DD	0f0H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_0L@NBPPJGMJ@MWHEELDOWN@
	DD	0efH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_07GOJPFDII@KP_HOME@
	DD	0a0H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_0L@CCBCEPGH@KP_UPARROW@
	DD	0a1H
	DD	FLAT:??_C@_08KKEOHAPB@?$CLforward@
	DD	FLAT:??_C@_07NODLLDPI@KP_PGUP@
	DD	0a2H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_0N@DMPGMABG@KP_LEFTARROW@
	DD	0a3H
	DD	FLAT:??_C@_05HEGFDNLE@?$CLleft@
	DD	FLAT:??_C@_04BICCMFCD@KP_5@
	DD	0a4H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_0O@NLCDAJLA@KP_RIGHTARROW@
	DD	0a5H
	DD	FLAT:??_C@_06NGIHBNMB@?$CLright@
	DD	FLAT:??_C@_06NAIJNDCL@KP_END@
	DD	0a6H
	DD	FLAT:??_C@_0L@FHIBDANG@centerview@
	DD	FLAT:??_C@_0N@MJLAPIEJ@KP_DOWNARROW@
	DD	0a7H
	DD	FLAT:??_C@_05IPKGNIPH@?$CLback@
	DD	FLAT:??_C@_07BHJOEFGA@KP_PGDN@
	DD	0a8H
	DD	FLAT:??_C@_07BDFIGFL@?$CLlookup@
	DD	FLAT:??_C@_08MHGPIJOM@KP_ENTER@
	DD	0a9H
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_06JPNMOIAF@KP_INS@
	DD	0aaH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_06KMLJNBKH@KP_DEL@
	DD	0abH
	DD	FLAT:??_C@_09KCKOGCLI@?$CLlookdown@
	DD	FLAT:??_C@_08KHGBLJLO@KP_SLASH@
	DD	0acH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_08KDIFPCFL@KP_MINUS@
	DD	0adH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_07CCBHGHDK@KP_PLUS@
	DD	0aeH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_05DIAHPDGL@PAUSE@
	DD	0ffH
	DD	FLAT:??_C@_05PDJBBECF@pause@
	DD	FLAT:??_C@_09COMJPDLF@SEMICOLON@
	DD	03bH
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	_Key_IsDown
PUBLIC	_Key_IsBind
PUBLIC	_Key_Event
PUBLIC	_Key_Init
PUBLIC	_Key_WriteBindings
PUBLIC	_Key_GetBinding
PUBLIC	_Key_SetBinding
PUBLIC	_Key_ClearStates
PUBLIC	_Key_KeynumToString
PUBLIC	_Key_StringToKeynum
PUBLIC	_Key_GetKey
PUBLIC	_Key_SetKeyDest
PUBLIC	_CL_CharEvent
PUBLIC	_Key_Unbind_f
PUBLIC	_Key_Unbindall_f
PUBLIC	_Key_Reset_f
PUBLIC	_Key_Bind_f
PUBLIC	_Key_Bindlist_f
PUBLIC	_Key_AddKeyCommands
PUBLIC	_Key_IsAllowedAutoRepeat
PUBLIC	??_C@_0BA@FLLJDFDJ@?$DMKEY?5NOT?5FOUND?$DO@	; `string'
PUBLIC	??_C@_0P@IGICGKLH@?$DMOUT?5OF?5RANGE?$DO@	; `string'
PUBLIC	?__LINE__Var@?0??Key_SetBinding@@9@9		; `Key_SetBinding'::`1'::__LINE__Var
PUBLIC	??_C@_0DB@OJLJLBIO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0DC@NBNGKPIE@Usage?3?5unbind?5?$DMkey?$DO?5?3?5remove?5co@ ; `string'
PUBLIC	??_C@_0BI@PLEALGJH@?$CC?$CFs?$CC?5isn?8t?5a?5valid?5key?6@ ; `string'
PUBLIC	??_C@_0DJ@KAIPEAKG@Usage?3?5bind?5?$DMkey?$DO?5?$FLcommand?$FN?5?3?5a@ ; `string'
PUBLIC	??_C@_0N@CHDOIAJI@?$CC?$CFs?$CC?5?$DN?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BD@BAINEHPI@?$CC?$CFs?$CC?5is?5not?5bound?6@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0L@EPHOCAKP@unbindall?6@			; `string'
PUBLIC	??_C@_0O@HKEPFNEK@bind?5?$CFs?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0DA@IPNPGONM@binds?5a?5command?5to?5the?5specifie@ ; `string'
PUBLIC	??_C@_04NPNJNMMP@bind@				; `string'
PUBLIC	??_C@_0DC@CIJBOOGM@removes?5a?5command?5on?5the?5specif@ ; `string'
PUBLIC	??_C@_06IDJGFAK@unbind@				; `string'
PUBLIC	??_C@_0CO@PFIEIAME@removes?5all?5commands?5from?5all?5k@ ; `string'
PUBLIC	??_C@_09EBAHBELN@unbindall@			; `string'
PUBLIC	??_C@_0CH@KMOEMCFB@reset?5all?5keys?5to?5their?5default@ ; `string'
PUBLIC	??_C@_09COPHIEKG@resetkeys@			; `string'
PUBLIC	??_C@_0BN@FFCLJMNH@display?5current?5key?5bindings@ ; `string'
PUBLIC	??_C@_08OLCDMLCJ@bindlist@			; `string'
PUBLIC	??_C@_0DI@HPKGPNIJ@write?5help?4txt?5that?5contains?5al@ ; `string'
PUBLIC	??_C@_08LCFLNLHO@makehelp@			; `string'
PUBLIC	??_C@_06JJGECBPI@?$CFs?5?$CFi?6@		; `string'
PUBLIC	??_C@_07DFJFGGI@?9?$CFs?5?$CFi?6@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BA@JCCNOPOD@?$CFs?5is?5unbound?4?6@	; `string'
PUBLIC	??_C@_0P@MJMKNHCG@r_showtextures@		; `string'
PUBLIC	??_C@_0CI@KJEMJIIE@Key_SetKeyDest?3?5wrong?5destinati@ ; `string'
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_Key_EnumCmds_f:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_IN_ToggleClientMouse:PROC
EXTRN	_Con_Visible:PROC
EXTRN	_Con_ToggleConsole_f:PROC
EXTRN	_Con_CharEvent:PROC
EXTRN	_Key_Console:PROC
EXTRN	_Key_Message:PROC
EXTRN	_UI_KeyEvent:PROC
EXTRN	_UI_CharEvent:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gl_showtextures:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?tinystr@?1??Key_KeynumToString@@9@9 DB 05H DUP (?)	; `Key_KeynumToString'::`2'::tinystr
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CI@KJEMJIIE@Key_SetKeyDest?3?5wrong?5destinati@
CONST	SEGMENT
??_C@_0CI@KJEMJIIE@Key_SetKeyDest?3?5wrong?5destinati@ DB 'Key_SetKeyDest'
	DB	': wrong destination (%i)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJMKNHCG@r_showtextures@
CONST	SEGMENT
??_C@_0P@MJMKNHCG@r_showtextures@ DB 'r_showtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCCNOPOD@?$CFs?5is?5unbound?4?6@
CONST	SEGMENT
??_C@_0BA@JCCNOPOD@?$CFs?5is?5unbound?4?6@ DB '%s is unbound.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFJFGGI@?9?$CFs?5?$CFi?6@
CONST	SEGMENT
??_C@_07DFJFGGI@?9?$CFs?5?$CFi?6@ DB '-%s %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJGECBPI@?$CFs?5?$CFi?6@
CONST	SEGMENT
??_C@_06JJGECBPI@?$CFs?5?$CFi?6@ DB '%s %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCFLNLHO@makehelp@
CONST	SEGMENT
??_C@_08LCFLNLHO@makehelp@ DB 'makehelp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HPKGPNIJ@write?5help?4txt?5that?5contains?5al@
CONST	SEGMENT
??_C@_0DI@HPKGPNIJ@write?5help?4txt?5that?5contains?5al@ DB 'write help.t'
	DB	'xt that contains all console cvars and cmds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLCDMLCJ@bindlist@
CONST	SEGMENT
??_C@_08OLCDMLCJ@bindlist@ DB 'bindlist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FFCLJMNH@display?5current?5key?5bindings@
CONST	SEGMENT
??_C@_0BN@FFCLJMNH@display?5current?5key?5bindings@ DB 'display current k'
	DB	'ey bindings', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09COPHIEKG@resetkeys@
CONST	SEGMENT
??_C@_09COPHIEKG@resetkeys@ DB 'resetkeys', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KMOEMCFB@reset?5all?5keys?5to?5their?5default@
CONST	SEGMENT
??_C@_0CH@KMOEMCFB@reset?5all?5keys?5to?5their?5default@ DB 'reset all ke'
	DB	'ys to their default values', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EBAHBELN@unbindall@
CONST	SEGMENT
??_C@_09EBAHBELN@unbindall@ DB 'unbindall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PFIEIAME@removes?5all?5commands?5from?5all?5k@
CONST	SEGMENT
??_C@_0CO@PFIEIAME@removes?5all?5commands?5from?5all?5k@ DB 'removes all '
	DB	'commands from all keys in bindmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDJGFAK@unbind@
CONST	SEGMENT
??_C@_06IDJGFAK@unbind@ DB 'unbind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CIJBOOGM@removes?5a?5command?5on?5the?5specif@
CONST	SEGMENT
??_C@_0DC@CIJBOOGM@removes?5a?5command?5on?5the?5specif@ DB 'removes a co'
	DB	'mmand on the specified key in bindmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NPNJNMMP@bind@
CONST	SEGMENT
??_C@_04NPNJNMMP@bind@ DB 'bind', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IPNPGONM@binds?5a?5command?5to?5the?5specifie@
CONST	SEGMENT
??_C@_0DA@IPNPGONM@binds?5a?5command?5to?5the?5specifie@ DB 'binds a comm'
	DB	'and to the specified key in bindmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@ DB '%s "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKEPFNEK@bind?5?$CFs?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0O@HKEPFNEK@bind?5?$CFs?5?$CC?$CFs?$CC?6@ DB 'bind %s "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPHOCAKP@unbindall?6@
CONST	SEGMENT
??_C@_0L@EPHOCAKP@unbindall?6@ DB 'unbindall', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BAINEHPI@?$CC?$CFs?$CC?5is?5not?5bound?6@
CONST	SEGMENT
??_C@_0BD@BAINEHPI@?$CC?$CFs?$CC?5is?5not?5bound?6@ DB '"%s" is not bound'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHDOIAJI@?$CC?$CFs?$CC?5?$DN?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0N@CHDOIAJI@?$CC?$CFs?$CC?5?$DN?5?$CC?$CFs?$CC?6@ DB '"%s" = "%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KAIPEAKG@Usage?3?5bind?5?$DMkey?$DO?5?$FLcommand?$FN?5?3?5a@
CONST	SEGMENT
??_C@_0DJ@KAIPEAKG@Usage?3?5bind?5?$DMkey?$DO?5?$FLcommand?$FN?5?3?5a@ DB 'U'
	DB	'sage: bind <key> [command] : attach a command to a key', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLEALGJH@?$CC?$CFs?$CC?5isn?8t?5a?5valid?5key?6@
CONST	SEGMENT
??_C@_0BI@PLEALGJH@?$CC?$CFs?$CC?5isn?8t?5a?5valid?5key?6@ DB '"%s" isn'''
	DB	't a valid key', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NBNGKPIE@Usage?3?5unbind?5?$DMkey?$DO?5?3?5remove?5co@
CONST	SEGMENT
??_C@_0DC@NBNGKPIE@Usage?3?5unbind?5?$DMkey?$DO?5?3?5remove?5co@ DB 'Usag'
	DB	'e: unbind <key> : remove commands from a key', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OJLJLBIO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DB@OJLJLBIO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\keys.c', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Key_SetBinding@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Key_SetBinding@@9@9 DD 0efH		; `Key_SetBinding'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@IGICGKLH@?$DMOUT?5OF?5RANGE?$DO@
CONST	SEGMENT
??_C@_0P@IGICGKLH@?$DMOUT?5OF?5RANGE?$DO@ DB '<OUT OF RANGE>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLLJDFDJ@?$DMKEY?5NOT?5FOUND?$DO@
CONST	SEGMENT
??_C@_0BA@FLLJDFDJ@?$DMKEY?5NOT?5FOUND?$DO@ DB '<KEY NOT FOUND>', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	018fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	019eH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_IsAllowedAutoRepeat
_TEXT	SEGMENT
tv64 = -68						; size = 4
_key$ = 8						; size = 4
_Key_IsAllowedAutoRepeat PROC				; COMDAT

; 529  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 530  : 	switch( key )

	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 127				; 0000007fH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 128		; 00000080H
	ja	SHORT $LN10@Key_IsAllo
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN12@Key_IsAllo[edx]
	jmp	DWORD PTR $LN13@Key_IsAllo[eax*4]
$LN9@Key_IsAllo:

; 531  : 	{
; 532  : 	case K_BACKSPACE:
; 533  : 	case K_PAUSE:
; 534  : 	case K_PGUP:
; 535  : 	case K_KP_PGUP:
; 536  : 	case K_PGDN:
; 537  : 	case K_KP_PGDN:
; 538  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Key_IsAllo
$LN10@Key_IsAllo:

; 539  : 	default:
; 540  : 		return false;

	xor	eax, eax
$LN1@Key_IsAllo:

; 541  : 	} 
; 542  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@Key_IsAllo:
	DD	$LN9@Key_IsAllo
	DD	$LN10@Key_IsAllo
$LN12@Key_IsAllo:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_Key_IsAllowedAutoRepeat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_AddKeyCommands
_TEXT	SEGMENT
_i$ = -2060						; size = 4
_cmd$ = -2056						; size = 1024
_buttonPtr$ = -1032					; size = 4
_button$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_kb$ = 12						; size = 4
_down$ = 16						; size = 4
_Key_AddKeyCommands PROC				; COMDAT

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2380				; 0000094cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 484  : 	char	button[1024];
; 485  : 	char	*buttonPtr;
; 486  : 	char	cmd[1024];
; 487  : 	int	i;
; 488  : 
; 489  : 	if( !kb ) return;

	cmp	DWORD PTR _kb$[ebp], 0
	jne	SHORT $LN7@Key_AddKey
	jmp	$LN1@Key_AddKey
$LN7@Key_AddKey:

; 490  : 	buttonPtr = button;

	lea	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR _buttonPtr$[ebp], eax

; 491  : 
; 492  : 	for( i = 0; ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_AddKey
$LN2@Key_AddKey:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_AddKey:

; 493  : 	{
; 494  : 		if( kb[i] == ';' || !kb[i] )

	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN9@Key_AddKey
	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN8@Key_AddKey
$LN9@Key_AddKey:

; 495  : 		{
; 496  : 			*buttonPtr = '\0';

	mov	eax, DWORD PTR _buttonPtr$[ebp]
	mov	BYTE PTR [eax], 0

; 497  : 			if( button[0] == '+' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _button$[ebp+ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN10@Key_AddKey

; 498  : 			{
; 499  : 				// button commands add keynum as a parm
; 500  : 				if( down ) Q_sprintf( cmd, "%s %i\n", button, key );

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN12@Key_AddKey
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR _button$[ebp]
	push	ecx
	push	OFFSET ??_C@_06JJGECBPI@?$CFs?5?$CFi?6@
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN13@Key_AddKey
$LN12@Key_AddKey:

; 501  : 				else Q_sprintf( cmd, "-%s %i\n", button + 1, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR _button$[ebp+1]
	push	ecx
	push	OFFSET ??_C@_07DFJFGGI@?9?$CFs?5?$CFi?6@
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H
$LN13@Key_AddKey:

; 502  : 				Cbuf_AddText( cmd );

	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 503  : 			}

	jmp	SHORT $LN11@Key_AddKey
$LN10@Key_AddKey:

; 504  : 			else if( down )

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN11@Key_AddKey

; 505  : 			{
; 506  : 				// down-only command
; 507  : 				Cbuf_AddText( button );

	lea	eax, DWORD PTR _button$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 508  : 				Cbuf_AddText( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4
$LN11@Key_AddKey:

; 509  : 			}
; 510  : 
; 511  : 			buttonPtr = button;

	lea	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR _buttonPtr$[ebp], eax
$LN5@Key_AddKey:

; 512  : 			while(( kb[i] <= ' ' || kb[i] == ';' ) && kb[i] != 0 )

	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN15@Key_AddKey
	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN8@Key_AddKey
$LN15@Key_AddKey:
	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@Key_AddKey

; 513  : 				i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN5@Key_AddKey
$LN8@Key_AddKey:

; 514  : 		}
; 515  : 
; 516  : 		*buttonPtr++ = kb[i];

	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _buttonPtr$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _buttonPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _buttonPtr$[ebp], eax

; 517  : 		if( !kb[i] ) break;

	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN16@Key_AddKey
	jmp	SHORT $LN1@Key_AddKey
$LN16@Key_AddKey:

; 518  : 	}

	jmp	$LN2@Key_AddKey
$LN1@Key_AddKey:

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_AddKeyCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Bindlist_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_Bindlist_f PROC					; COMDAT

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 438  : 	int	i;
; 439  : 
; 440  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Bindli
$LN2@Key_Bindli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Bindli:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Key_Bindli

; 441  : 	{
; 442  : 		if( !COM_CheckString( keys[i].binding ))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Key_Bindli

; 443  : 			continue;

	jmp	SHORT $LN2@Key_Bindli
$LN5@Key_Bindli:

; 444  : 
; 445  : 		Con_Printf( "%s \"%s\"\n", Key_KeynumToString( i ), keys[i].binding );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 446  : 	}

	jmp	SHORT $LN2@Key_Bindli
$LN1@Key_Bindli:

; 447  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Bindlist_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Bind_f
_TEXT	SEGMENT
$T1 = -1236						; size = 4
_b$ = -1040						; size = 4
_c$ = -1036						; size = 4
_i$ = -1032						; size = 4
_cmd$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_Key_Bind_f PROC					; COMDAT

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1236				; 000004d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 367  : 	char	cmd[1024];
; 368  : 	int	i, c, b;
; 369  : 	
; 370  : 	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 371  : 
; 372  : 	if( c < 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jge	SHORT $LN5@Key_Bind_f

; 373  : 	{
; 374  : 		Con_Printf( S_USAGE "bind <key> [command] : attach a command to a key\n" );

	push	OFFSET ??_C@_0DJ@KAIPEAKG@Usage?3?5bind?5?$DMkey?$DO?5?$FLcommand?$FN?5?3?5a@
	call	_Con_Printf
	add	esp, 4

; 375  : 		return;

	jmp	$LN11@Key_Bind_f
$LN5@Key_Bind_f:

; 376  : 	}
; 377  : 
; 378  : 	b = Key_StringToKeynum( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Key_StringToKeynum
	add	esp, 4
	mov	DWORD PTR _b$[ebp], eax

; 379  : 
; 380  : 	if( b == -1 )

	cmp	DWORD PTR _b$[ebp], -1
	jne	SHORT $LN6@Key_Bind_f

; 381  : 	{
; 382  : 		Con_Printf( "\"%s\" isn't a valid key\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BI@PLEALGJH@?$CC?$CFs?$CC?5isn?8t?5a?5valid?5key?6@
	call	_Con_Printf
	add	esp, 8

; 383  : 		return;

	jmp	$LN11@Key_Bind_f
$LN6@Key_Bind_f:

; 384  : 	}
; 385  : 
; 386  : 	if( c == 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jne	SHORT $LN7@Key_Bind_f

; 387  : 	{
; 388  : 		if( keys[b].binding )

	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN8@Key_Bind_f

; 389  : 			Con_Printf( "\"%s\" = \"%s\"\n", Cmd_Argv( 1 ), keys[b].binding );

	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0N@CHDOIAJI@?$CC?$CFs?$CC?5?$DN?5?$CC?$CFs?$CC?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Key_Bind_f
$LN8@Key_Bind_f:

; 390  : 		else Con_Printf( "\"%s\" is not bound\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BD@BAINEHPI@?$CC?$CFs?$CC?5is?5not?5bound?6@
	call	_Con_Printf
	add	esp, 8
$LN9@Key_Bind_f:

; 391  : 		return;

	jmp	$LN11@Key_Bind_f
$LN7@Key_Bind_f:

; 392  : 	}
; 393  : 	
; 394  : 	// copy the rest of the command line
; 395  : 	cmd[0] = 0; // start out with a null string

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN12@Key_Bind_f
	jmp	SHORT $LN13@Key_Bind_f
$LN12@Key_Bind_f:
	call	___report_rangecheckfailure
$LN13@Key_Bind_f:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd$[ebp+edx], 0

; 396  : 
; 397  : 	for( i = 2; i < c; i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@Key_Bind_f
$LN2@Key_Bind_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Bind_f:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN3@Key_Bind_f

; 398  : 	{
; 399  : 		Q_strcat( cmd, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 400  : 		if( i != ( c - 1 )) Q_strcat( cmd, " " );

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $LN10@Key_Bind_f
	push	99999					; 0001869fH
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN10@Key_Bind_f:

; 401  : 	}

	jmp	SHORT $LN2@Key_Bind_f
$LN3@Key_Bind_f:

; 402  : 
; 403  : 	Key_SetBinding( b, cmd );

	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	_Key_SetBinding
	add	esp, 8
$LN11@Key_Bind_f:

; 404  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Bind_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Reset_f
_TEXT	SEGMENT
_i$ = -8						; size = 4
_kn$ = -4						; size = 4
_Key_Reset_f PROC					; COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 345  : 	keyname_t	*kn;
; 346  : 	int	i;
; 347  : 
; 348  : 	// clear all keys first	
; 349  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Reset_
$LN2@Key_Reset_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Reset_:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Key_Reset_

; 350  : 	{
; 351  : 		if( keys[i].binding )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN8@Key_Reset_

; 352  : 			Key_SetBinding( i, "" );

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
$LN8@Key_Reset_:

; 353  : 	}

	jmp	SHORT $LN2@Key_Reset_
$LN3@Key_Reset_:

; 354  : 
; 355  : 	// apply default values
; 356  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN7@Key_Reset_
$LN5@Key_Reset_:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN7@Key_Reset_:
	mov	eax, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Key_Reset_

; 357  : 		Key_SetBinding( kn->keynum, kn->binding ); 

	mov	eax, DWORD PTR _kn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
	jmp	SHORT $LN5@Key_Reset_
$LN1@Key_Reset_:

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Reset_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Unbindall_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_Unbindall_f PROC					; COMDAT

; 328  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 329  : 	int	i;
; 330  : 	
; 331  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Unbind
$LN2@Key_Unbind:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Unbind:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Key_Unbind

; 332  : 	{
; 333  : 		if( keys[i].binding )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN5@Key_Unbind

; 334  : 			Key_SetBinding( i, "" );

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
$LN5@Key_Unbind:

; 335  : 	}

	jmp	SHORT $LN2@Key_Unbind
$LN1@Key_Unbind:

; 336  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Unbindall_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Unbind_f
_TEXT	SEGMENT
_b$ = -4						; size = 4
_Key_Unbind_f PROC					; COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 303  : 	int	b;
; 304  : 
; 305  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@Key_Unbind

; 306  : 	{
; 307  : 		Con_Printf( S_USAGE "unbind <key> : remove commands from a key\n" );

	push	OFFSET ??_C@_0DC@NBNGKPIE@Usage?3?5unbind?5?$DMkey?$DO?5?3?5remove?5co@
	call	_Con_Printf
	add	esp, 4

; 308  : 		return;

	jmp	SHORT $LN1@Key_Unbind
$LN2@Key_Unbind:

; 309  : 	}
; 310  : 	
; 311  : 	b = Key_StringToKeynum( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Key_StringToKeynum
	add	esp, 4
	mov	DWORD PTR _b$[ebp], eax

; 312  : 
; 313  : 	if( b == -1 )

	cmp	DWORD PTR _b$[ebp], -1
	jne	SHORT $LN3@Key_Unbind

; 314  : 	{
; 315  : 		Con_Printf( "\"%s\" isn't a valid key\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BI@PLEALGJH@?$CC?$CFs?$CC?5isn?8t?5a?5valid?5key?6@
	call	_Con_Printf
	add	esp, 8

; 316  : 		return;

	jmp	SHORT $LN1@Key_Unbind
$LN3@Key_Unbind:

; 317  : 	}
; 318  : 
; 319  : 	Key_SetBinding( b, "" );

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
$LN1@Key_Unbind:

; 320  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Unbind_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _CL_CharEvent
_TEXT	SEGMENT
_key$ = 8						; size = 4
_CL_CharEvent PROC					; COMDAT

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 753  : 	// the console key should never be used as a char
; 754  : 	if( key == '`' || key == '~' ) return;

	cmp	DWORD PTR _key$[ebp], 96		; 00000060H
	je	SHORT $LN3@CL_CharEve
	cmp	DWORD PTR _key$[ebp], 126		; 0000007eH
	jne	SHORT $LN2@CL_CharEve
$LN3@CL_CharEve:
	jmp	SHORT $LN1@CL_CharEve
$LN2@CL_CharEve:

; 755  : 
; 756  : 	if( cls.key_dest == key_console && !Con_Visible( ))

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN4@CL_CharEve
	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN4@CL_CharEve

; 757  : 	{
; 758  : 		if((char)key == '¸' || (char)key == '¨' )

	movsx	eax, BYTE PTR _key$[ebp]
	cmp	eax, -72				; ffffffb8H
	je	SHORT $LN6@CL_CharEve
	movsx	eax, BYTE PTR _key$[ebp]
	cmp	eax, -88				; ffffffa8H
	jne	SHORT $LN4@CL_CharEve
$LN6@CL_CharEve:

; 759  : 			return; // don't pass '¸' when we open the console 

	jmp	SHORT $LN1@CL_CharEve
$LN4@CL_CharEve:

; 760  : 	}
; 761  : 
; 762  : 	// distribute the key down event to the apropriate handler
; 763  : 	if( cls.key_dest == key_console || cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 0
	je	SHORT $LN9@CL_CharEve
	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN7@CL_CharEve
$LN9@CL_CharEve:

; 764  : 	{
; 765  : 		Con_CharEvent( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Con_CharEvent
	add	esp, 4

; 766  : 	}

	jmp	SHORT $LN1@CL_CharEve
$LN7@CL_CharEve:

; 767  : 	else if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN1@CL_CharEve

; 768  : 	{
; 769  : 		UI_CharEvent( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_UI_CharEvent
	add	esp, 4
$LN1@CL_CharEve:

; 770  : 	}
; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_SetKeyDest
_TEXT	SEGMENT
tv66 = -68						; size = 4
_key_dest$ = 8						; size = 4
_Key_SetKeyDest PROC					; COMDAT

; 695  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 696  : 	IN_ToggleClientMouse( key_dest, cls.key_dest );

	mov	eax, DWORD PTR _cls+36
	push	eax
	mov	ecx, DWORD PTR _key_dest$[ebp]
	push	ecx
	call	_IN_ToggleClientMouse
	add	esp, 8

; 697  : 
; 698  : 	switch( key_dest )

	mov	eax, DWORD PTR _key_dest$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN8@Key_SetKey
	mov	ecx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN10@Key_SetKey[ecx*4]
$LN4@Key_SetKey:

; 699  : 	{
; 700  : 	case key_game:
; 701  : 		cls.key_dest = key_game;

	mov	DWORD PTR _cls+36, 1

; 702  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN5@Key_SetKey:

; 703  : 	case key_menu:
; 704  : 		cls.key_dest = key_menu;

	mov	DWORD PTR _cls+36, 2

; 705  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN6@Key_SetKey:

; 706  : 	case key_console:
; 707  : 		cls.key_dest = key_console;

	mov	DWORD PTR _cls+36, 0

; 708  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN7@Key_SetKey:

; 709  : 	case key_message:
; 710  : 		cls.key_dest = key_message;

	mov	DWORD PTR _cls+36, 3

; 711  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN8@Key_SetKey:

; 712  : 	default:
; 713  : 		Host_Error( "Key_SetKeyDest: wrong destination (%i)\n", key_dest );

	mov	eax, DWORD PTR _key_dest$[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@KJEMJIIE@Key_SetKeyDest?3?5wrong?5destinati@
	call	_Host_Error
	add	esp, 8
$LN1@Key_SetKey:

; 714  : 		break;
; 715  : 	}
; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Key_SetKey:
	DD	$LN6@Key_SetKey
	DD	$LN4@Key_SetKey
	DD	$LN5@Key_SetKey
	DD	$LN7@Key_SetKey
_Key_SetKeyDest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_GetKey
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pBinding$ = 8						; size = 4
_Key_GetKey PROC					; COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 272  : 	int	i;
; 273  : 
; 274  : 	if( !pBinding ) return -1;

	cmp	DWORD PTR _pBinding$[ebp], 0
	jne	SHORT $LN5@Key_GetKey
	or	eax, -1
	jmp	$LN1@Key_GetKey
$LN5@Key_GetKey:

; 275  : 
; 276  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_GetKey
$LN2@Key_GetKey:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_GetKey:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Key_GetKey

; 277  : 	{
; 278  : 		if( !keys[i].binding )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	jne	SHORT $LN6@Key_GetKey

; 279  : 			continue;

	jmp	SHORT $LN2@Key_GetKey
$LN6@Key_GetKey:

; 280  : 
; 281  : 		if( *keys[i].binding == '+' )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN7@Key_GetKey

; 282  :                     {
; 283  : 			if( !Q_strnicmp( keys[i].binding + 1, pBinding, Q_strlen( pBinding )))

	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pBinding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	add	eax, 1
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Key_GetKey

; 284  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@Key_GetKey
$LN9@Key_GetKey:

; 285  : 		}

	jmp	SHORT $LN8@Key_GetKey
$LN7@Key_GetKey:

; 286  : 		else
; 287  : 		{
; 288  : 			if( !Q_strnicmp( keys[i].binding, pBinding, Q_strlen( pBinding )))

	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pBinding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Key_GetKey

; 289  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@Key_GetKey
$LN8@Key_GetKey:

; 290  : 		}
; 291  : 	}

	jmp	$LN2@Key_GetKey
$LN3@Key_GetKey:

; 292  : 
; 293  : 	return -1;

	or	eax, -1
$LN1@Key_GetKey:

; 294  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_GetKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_StringToKeynum
_TEXT	SEGMENT
_n2$1 = -12						; size = 4
_n1$2 = -8						; size = 4
_kn$ = -4						; size = 4
_str$ = 8						; size = 4
_Key_StringToKeynum PROC				; COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 143  : 	keyname_t		*kn;
; 144  : 	
; 145  : 	if( !str || !str[0] ) return -1;

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN6@Key_String
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@Key_String
$LN6@Key_String:
	or	eax, -1
	jmp	$LN1@Key_String
$LN5@Key_String:

; 146  : 	if( !str[1] ) return str[0];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@Key_String
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	jmp	$LN1@Key_String
$LN7@Key_String:

; 147  : 
; 148  : 	// check for hex code
; 149  : 	if( str[0] == '0' && str[1] == 'x' && Q_strlen( str ) == 4 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jne	$LN8@Key_String
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN8@Key_String
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 4
	jne	$LN8@Key_String

; 150  : 	{
; 151  : 		int	n1, n2;
; 152  : 		
; 153  : 		n1 = str[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _n1$2[ebp], edx

; 154  : 		if( n1 >= '0' && n1 <= '9' )

	cmp	DWORD PTR _n1$2[ebp], 48		; 00000030H
	jl	SHORT $LN9@Key_String
	cmp	DWORD PTR _n1$2[ebp], 57		; 00000039H
	jg	SHORT $LN9@Key_String

; 155  : 		{
; 156  : 			n1 -= '0';

	mov	eax, DWORD PTR _n1$2[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _n1$2[ebp], eax

; 157  : 		}

	jmp	SHORT $LN10@Key_String
$LN9@Key_String:

; 158  : 		else if( n1 >= 'a' && n1 <= 'f' )

	cmp	DWORD PTR _n1$2[ebp], 97		; 00000061H
	jl	SHORT $LN11@Key_String
	cmp	DWORD PTR _n1$2[ebp], 102		; 00000066H
	jg	SHORT $LN11@Key_String

; 159  : 		{
; 160  : 			n1 = n1 - 'a' + 10;

	mov	eax, DWORD PTR _n1$2[ebp]
	sub	eax, 87					; 00000057H
	mov	DWORD PTR _n1$2[ebp], eax

; 161  : 		}

	jmp	SHORT $LN10@Key_String
$LN11@Key_String:

; 162  : 		else n1 = 0;

	mov	DWORD PTR _n1$2[ebp], 0
$LN10@Key_String:

; 163  : 
; 164  : 		n2 = str[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _n2$1[ebp], eax

; 165  : 		if( n2 >= '0' && n2 <= '9' )

	cmp	DWORD PTR _n2$1[ebp], 48		; 00000030H
	jl	SHORT $LN13@Key_String
	cmp	DWORD PTR _n2$1[ebp], 57		; 00000039H
	jg	SHORT $LN13@Key_String

; 166  : 		{
; 167  : 			n2 -= '0';

	mov	eax, DWORD PTR _n2$1[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _n2$1[ebp], eax

; 168  : 		}

	jmp	SHORT $LN14@Key_String
$LN13@Key_String:

; 169  : 		else if( n2 >= 'a' && n2 <= 'f' )

	cmp	DWORD PTR _n2$1[ebp], 97		; 00000061H
	jl	SHORT $LN15@Key_String
	cmp	DWORD PTR _n2$1[ebp], 102		; 00000066H
	jg	SHORT $LN15@Key_String

; 170  : 		{
; 171  : 			n2 = n2 - 'a' + 10;

	mov	eax, DWORD PTR _n2$1[ebp]
	sub	eax, 87					; 00000057H
	mov	DWORD PTR _n2$1[ebp], eax

; 172  : 		}

	jmp	SHORT $LN14@Key_String
$LN15@Key_String:

; 173  : 		else n2 = 0;

	mov	DWORD PTR _n2$1[ebp], 0
$LN14@Key_String:

; 174  : 
; 175  : 		return n1 * 16 + n2;

	mov	eax, DWORD PTR _n1$2[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _n2$1[ebp]
	jmp	SHORT $LN1@Key_String
$LN8@Key_String:

; 176  : 	}
; 177  : 
; 178  : 	// scan for a text match
; 179  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_String
$LN2@Key_String:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN4@Key_String:
	mov	eax, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Key_String

; 180  : 	{
; 181  : 		if( !Q_stricmp( str, kn->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _kn$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@Key_String

; 182  : 			return kn->keynum;

	mov	eax, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN1@Key_String
$LN17@Key_String:

; 183  : 	}

	jmp	SHORT $LN2@Key_String
$LN3@Key_String:

; 184  : 
; 185  : 	return -1;

	or	eax, -1
$LN1@Key_String:

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_StringToKeynum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_KeynumToString
_TEXT	SEGMENT
tv134 = -88						; size = 4
tv94 = -88						; size = 4
$T1 = -84						; size = 4
$T2 = -80						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_kn$ = -4						; size = 4
_keynum$ = 8						; size = 4
_Key_KeynumToString PROC				; COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 198  : 	keyname_t		*kn;	
; 199  : 	static char	tinystr[5];
; 200  : 	int		i, j;
; 201  : 
; 202  : 	if ( keynum == -1 ) return "<KEY NOT FOUND>";

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN5@Key_Keynum
	mov	eax, OFFSET ??_C@_0BA@FLLJDFDJ@?$DMKEY?5NOT?5FOUND?$DO@
	jmp	$LN10@Key_Keynum
$LN5@Key_Keynum:

; 203  : 	if ( keynum < 0 || keynum > 255 ) return "<OUT OF RANGE>";

	cmp	DWORD PTR _keynum$[ebp], 0
	jl	SHORT $LN7@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 255		; 000000ffH
	jle	SHORT $LN6@Key_Keynum
$LN7@Key_Keynum:
	mov	eax, OFFSET ??_C@_0P@IGICGKLH@?$DMOUT?5OF?5RANGE?$DO@
	jmp	$LN10@Key_Keynum
$LN6@Key_Keynum:

; 204  : 
; 205  : 	// check for printable ascii (don't use quote)
; 206  : 	if( keynum > 32 && keynum < 127 && keynum != '"' && keynum != ';' && keynum != K_SCROLLOCK )

	cmp	DWORD PTR _keynum$[ebp], 32		; 00000020H
	jle	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 127		; 0000007fH
	jge	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 34		; 00000022H
	je	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 59		; 0000003bH
	je	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 70		; 00000046H
	je	SHORT $LN8@Key_Keynum

; 207  : 	{
; 208  : 		tinystr[0] = keynum;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _keynum$[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], dl

; 209  : 		tinystr[1] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 5
	jae	SHORT $LN11@Key_Keynum
	jmp	SHORT $LN12@Key_Keynum
$LN11@Key_Keynum:
	call	___report_rangecheckfailure
$LN12@Key_Keynum:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], 0

; 210  : 		return tinystr;

	mov	eax, OFFSET ?tinystr@?1??Key_KeynumToString@@9@9
	jmp	$LN10@Key_Keynum
$LN8@Key_Keynum:

; 211  : 	}
; 212  : 
; 213  : 	// check for a key string
; 214  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_Keynum
$LN2@Key_Keynum:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN4@Key_Keynum:
	mov	eax, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Key_Keynum

; 215  : 	{
; 216  : 		if( keynum == kn->keynum )

	mov	eax, DWORD PTR _kn$[ebp]
	mov	ecx, DWORD PTR _keynum$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN9@Key_Keynum

; 217  : 			return kn->name;

	mov	eax, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN10@Key_Keynum
$LN9@Key_Keynum:

; 218  : 	}

	jmp	SHORT $LN2@Key_Keynum
$LN3@Key_Keynum:

; 219  : 
; 220  : 	// make a hex string
; 221  : 	i = keynum >> 4;

	mov	eax, DWORD PTR _keynum$[ebp]
	sar	eax, 4
	mov	DWORD PTR _i$[ebp], eax

; 222  : 	j = keynum & 15;

	mov	eax, DWORD PTR _keynum$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _j$[ebp], eax

; 223  : 
; 224  : 	tinystr[0] = '0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], 48 ; 00000030H

; 225  : 	tinystr[1] = 'x';

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], 120 ; 00000078H

; 226  : 	tinystr[2] = i > 9 ? i - 10 + 'a' : i + '0';

	cmp	DWORD PTR _i$[ebp], 9
	jle	SHORT $LN13@Key_Keynum
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 87					; 00000057H
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN14@Key_Keynum
$LN13@Key_Keynum:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv94[ebp], ecx
$LN14@Key_Keynum:
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR tv94[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[edx], al

; 227  : 	tinystr[3] = j > 9 ? j - 10 + 'a' : j + '0';

	cmp	DWORD PTR _j$[ebp], 9
	jle	SHORT $LN15@Key_Keynum
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 87					; 00000057H
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN16@Key_Keynum
$LN15@Key_Keynum:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv134[ebp], ecx
$LN16@Key_Keynum:
	mov	edx, 1
	imul	eax, edx, 3
	mov	cl, BYTE PTR tv134[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], cl

; 228  : 	tinystr[4] = 0;

	mov	eax, 1
	shl	eax, 2
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 5
	jae	SHORT $LN17@Key_Keynum
	jmp	SHORT $LN18@Key_Keynum
$LN17@Key_Keynum:
	call	___report_rangecheckfailure
$LN18@Key_Keynum:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], 0

; 229  : 
; 230  : 	return tinystr;

	mov	eax, OFFSET ?tinystr@?1??Key_KeynumToString@@9@9
$LN10@Key_Keynum:

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_KeynumToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_ClearStates
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_ClearStates PROC					; COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 725  : 	int	i;
; 726  : 
; 727  : 	// don't clear keys during changelevel
; 728  : 	if( cls.changelevel ) return;

	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN5@Key_ClearS
	jmp	SHORT $LN1@Key_ClearS
$LN5@Key_ClearS:

; 729  : 
; 730  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_ClearS
$LN2@Key_ClearS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_ClearS:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Key_ClearS

; 731  : 	{
; 732  : 		if( keys[i].down )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax], 0
	je	SHORT $LN6@Key_ClearS

; 733  : 			Key_Event( i, false );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Key_Event
	add	esp, 8
$LN6@Key_ClearS:

; 734  : 
; 735  : 		keys[i].down = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax], 0

; 736  : 		keys[i].repeats = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+8], 0

; 737  : 		keys[i].gamedown = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+4], 0

; 738  : 	}

	jmp	SHORT $LN2@Key_ClearS
$LN3@Key_ClearS:

; 739  : 
; 740  : 	if( clgame.hInstance )

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN1@Key_ClearS

; 741  : 		clgame.dllFuncs.IN_ClearStates();

	call	DWORD PTR _clgame+52
$LN1@Key_ClearS:

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_ClearStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_SetBinding
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_binding$ = 12						; size = 4
_Key_SetBinding PROC					; COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 240  : 	if( keynum == -1 ) return;

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_SetBin
	jmp	SHORT $LN1@Key_SetBin
$LN2@Key_SetBin:

; 241  : 
; 242  : 	// free old bindings
; 243  : 	if( keys[keynum].binding )

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN3@Key_SetBin

; 244  : 	{
; 245  : 		Mem_Free((char *)keys[keynum].binding );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Key_SetBinding@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DB@OJLJLBIO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _keynum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 246  : 		keys[keynum].binding = NULL;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+12], 0
$LN3@Key_SetBin:

; 247  : 	}
; 248  : 		
; 249  : 	// allocate memory for new binding
; 250  : 	keys[keynum].binding = copystring( binding );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Key_SetBinding@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DB@OJLJLBIO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _binding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _keynum$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _keys[ecx+12], eax
$LN1@Key_SetBin:

; 251  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_SetBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_GetBinding
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_GetBinding PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 261  : 	if( keynum == -1 ) return NULL;

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_GetBin
	xor	eax, eax
	jmp	SHORT $LN1@Key_GetBin
$LN2@Key_GetBin:

; 262  : 	return keys[keynum].binding;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _keys[eax+12]
$LN1@Key_GetBin:

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_GetBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_WriteBindings
_TEXT	SEGMENT
_i$ = -4						; size = 4
_f$ = 8							; size = 4
_Key_WriteBindings PROC					; COMDAT

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 415  : 	int	i;
; 416  : 
; 417  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN5@Key_WriteB
	jmp	SHORT $LN1@Key_WriteB
$LN5@Key_WriteB:

; 418  : 
; 419  : 	FS_Printf( f, "unbindall\n" );

	push	OFFSET ??_C@_0L@EPHOCAKP@unbindall?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 420  : 
; 421  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_WriteB
$LN2@Key_WriteB:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_WriteB:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Key_WriteB

; 422  : 	{
; 423  : 		if( !COM_CheckString( keys[i].binding ))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@Key_WriteB

; 424  : 			continue;

	jmp	SHORT $LN2@Key_WriteB
$LN6@Key_WriteB:

; 425  : 
; 426  : 		FS_Printf( f, "bind %s \"%s\"\n", Key_KeynumToString( i ), keys[i].binding );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0O@HKEPFNEK@bind?5?$CFs?5?$CC?$CFs?$CC?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 427  : 	}

	jmp	SHORT $LN2@Key_WriteB
$LN1@Key_WriteB:

; 428  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_WriteBindings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Init
_TEXT	SEGMENT
_kn$ = -4						; size = 4
_Key_Init PROC						; COMDAT

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 463  : 	keyname_t	*kn;
; 464  : 
; 465  : 	// register our functions
; 466  : 	Cmd_AddCommand( "bind", Key_Bind_f, "binds a command to the specified key in bindmap" );

	push	OFFSET ??_C@_0DA@IPNPGONM@binds?5a?5command?5to?5the?5specifie@
	push	OFFSET _Key_Bind_f
	push	OFFSET ??_C@_04NPNJNMMP@bind@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 467  : 	Cmd_AddCommand( "unbind", Key_Unbind_f, "removes a command on the specified key in bindmap" );

	push	OFFSET ??_C@_0DC@CIJBOOGM@removes?5a?5command?5on?5the?5specif@
	push	OFFSET _Key_Unbind_f
	push	OFFSET ??_C@_06IDJGFAK@unbind@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 468  : 	Cmd_AddCommand( "unbindall", Key_Unbindall_f, "removes all commands from all keys in bindmap" );

	push	OFFSET ??_C@_0CO@PFIEIAME@removes?5all?5commands?5from?5all?5k@
	push	OFFSET _Key_Unbindall_f
	push	OFFSET ??_C@_09EBAHBELN@unbindall@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 469  : 	Cmd_AddCommand( "resetkeys", Key_Reset_f, "reset all keys to their default values" );

	push	OFFSET ??_C@_0CH@KMOEMCFB@reset?5all?5keys?5to?5their?5default@
	push	OFFSET _Key_Reset_f
	push	OFFSET ??_C@_09COPHIEKG@resetkeys@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 470  : 	Cmd_AddCommand( "bindlist", Key_Bindlist_f, "display current key bindings" );

	push	OFFSET ??_C@_0BN@FFCLJMNH@display?5current?5key?5bindings@
	push	OFFSET _Key_Bindlist_f
	push	OFFSET ??_C@_08OLCDMLCJ@bindlist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 471  : 	Cmd_AddCommand( "makehelp", Key_EnumCmds_f, "write help.txt that contains all console cvars and cmds" ); 

	push	OFFSET ??_C@_0DI@HPKGPNIJ@write?5help?4txt?5that?5contains?5al@
	push	OFFSET _Key_EnumCmds_f
	push	OFFSET ??_C@_08LCFLNLHO@makehelp@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 472  : 
; 473  : 	// setup default binding. "unbindall" from config.cfg will be reset it
; 474  : 	for( kn = keynames; kn->name; kn++ ) Key_SetBinding( kn->keynum, kn->binding ); 

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_Init
$LN2@Key_Init:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN4@Key_Init:
	mov	eax, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Key_Init
	mov	eax, DWORD PTR _kn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
	jmp	SHORT $LN2@Key_Init
$LN1@Key_Init:

; 475  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_Event
_TEXT	SEGMENT
tv185 = -72						; size = 4
tv181 = -72						; size = 4
_kb$ = -4						; size = 4
_key$ = 8						; size = 4
_down$ = 12						; size = 4
_Key_Event PROC						; COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 553  : 	const char	*kb;
; 554  : 
; 555  : 	// key was pressed before engine was run
; 556  : 	if( !keys[key].down && !down )

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax], 0
	jne	SHORT $LN4@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN4@Key_Event

; 557  : 		return;

	jmp	$LN38@Key_Event
$LN4@Key_Event:

; 558  : 
; 559  : 	kb = keys[key].binding;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	mov	DWORD PTR _kb$[ebp], ecx

; 560  : 	keys[key].down = down;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _down$[ebp]
	mov	DWORD PTR _keys[eax], ecx

; 561  : 
; 562  : #ifdef HACKS_RELATED_HLMODS
; 563  : 	if(( cls.key_dest == key_game ) && ( cls.state == ca_cinematic ) && ( key != K_ESCAPE || !down ))

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN5@Key_Event
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN5@Key_Event
	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	SHORT $LN6@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN5@Key_Event
$LN6@Key_Event:

; 564  : 	{
; 565  : 		// only escape passed when cinematic is playing
; 566  : 		// HLFX 0.6 bug: crash in vgui3.dll while press +attack during movie playback
; 567  : 		return;

	jmp	$LN38@Key_Event
$LN5@Key_Event:

; 568  : 	}
; 569  : #endif
; 570  : 	// distribute the key down event to the apropriate handler
; 571  : 	if( cls.key_dest == key_game && ( down || keys[key].gamedown ))

	cmp	DWORD PTR _cls+36, 1
	jne	$LN9@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN8@Key_Event
	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+4], 0
	je	SHORT $LN9@Key_Event
$LN8@Key_Event:

; 572  : 	{
; 573  : 		if( !clgame.dllFuncs.pfnKey_Event( down, key, keys[key].binding ))

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	call	DWORD PTR _clgame+140
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Key_Event

; 574  : 		{
; 575  : 			if( keys[key].repeats == 0 && down )

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+8], 0
	jne	SHORT $LN10@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN10@Key_Event

; 576  : 			{
; 577  : 				keys[key].gamedown = true;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+4], 1
$LN10@Key_Event:

; 578  : 			}
; 579  : 
; 580  : 			if( !down )

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN11@Key_Event

; 581  : 			{
; 582  : 				keys[key].gamedown = false;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+4], 0

; 583  : 				keys[key].repeats = 0;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+8], 0
$LN11@Key_Event:

; 584  : 			}
; 585  : 			return; // handled in client.dll

	jmp	$LN38@Key_Event
$LN9@Key_Event:

; 586  : 		}
; 587  : 	}
; 588  : 
; 589  : 	// update auto-repeat status
; 590  : 	if( down )

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN12@Key_Event

; 591  : 	{
; 592  : 		keys[key].repeats++;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	mov	DWORD PTR _keys[edx+8], ecx

; 593  : 
; 594  : 		if( !Key_IsAllowedAutoRepeat( key ) && keys[key].repeats > 1 )

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_IsAllowedAutoRepeat
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@Key_Event
	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+8], 1
	jle	SHORT $LN14@Key_Event

; 595  : 		{
; 596  : 			// ignore most autorepeats
; 597  : 			return;

	jmp	$LN38@Key_Event
$LN14@Key_Event:

; 598  : 		}
; 599  : 
; 600  : 		if( key >= 200 && !kb )

	cmp	DWORD PTR _key$[ebp], 200		; 000000c8H
	jl	SHORT $LN15@Key_Event
	cmp	DWORD PTR _kb$[ebp], 0
	jne	SHORT $LN15@Key_Event

; 601  : 			Con_Printf( "%s is unbound.\n", Key_KeynumToString( key ));

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BA@JCCNOPOD@?$CFs?5is?5unbound?4?6@
	call	_Con_Printf
	add	esp, 8
$LN15@Key_Event:

; 602  : 	}

	jmp	SHORT $LN13@Key_Event
$LN12@Key_Event:

; 603  : 	else
; 604  : 	{
; 605  : 		keys[key].gamedown = false;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+4], 0

; 606  : 		keys[key].repeats = 0;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+8], 0
$LN13@Key_Event:

; 607  : 	}
; 608  : 
; 609  : 	// console key is hardcoded, so the user can never unbind it
; 610  : 	if( key == '`' || key == '~' )

	cmp	DWORD PTR _key$[ebp], 96		; 00000060H
	je	SHORT $LN17@Key_Event
	cmp	DWORD PTR _key$[ebp], 126		; 0000007eH
	jne	SHORT $LN16@Key_Event
$LN17@Key_Event:

; 611  : 	{
; 612  : 		// we are in typing mode. So don't switch to console
; 613  : 		if( (word)GetKeyboardLayout( 0 ) == (word)0x419 )

	push	0
	call	DWORD PTR __imp__GetKeyboardLayout@4
	movzx	eax, ax
	cmp	eax, 1049				; 00000419H
	jne	SHORT $LN19@Key_Event

; 614  : 		{
; 615  : 			if( cls.key_dest != key_game )

	cmp	DWORD PTR _cls+36, 1
	je	SHORT $LN19@Key_Event

; 616  : 				return;

	jmp	$LN38@Key_Event
$LN19@Key_Event:

; 617  :                     }
; 618  : 
; 619  : 		if( !down ) return;

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN20@Key_Event
	jmp	$LN38@Key_Event
$LN20@Key_Event:

; 620  :     		Con_ToggleConsole_f();

	call	_Con_ToggleConsole_f

; 621  : 		return;

	jmp	$LN38@Key_Event
$LN16@Key_Event:

; 622  : 	}
; 623  : 
; 624  : 	// escape is always handled special
; 625  : 	if( key == K_ESCAPE && down )

	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	$LN2@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	je	$LN2@Key_Event

; 626  : 	{
; 627  : 		switch( cls.key_dest )

	mov	eax, DWORD PTR _cls+36
	mov	DWORD PTR tv181[ebp], eax
	cmp	DWORD PTR tv181[ebp], 3
	ja	$LN31@Key_Event
	mov	ecx, DWORD PTR tv181[ebp]
	jmp	DWORD PTR $LN42@Key_Event[ecx*4]
$LN22@Key_Event:

; 628  : 		{
; 629  : 		case key_game:
; 630  : 			if( CVAR_TO_BOOL( gl_showtextures ))

	cmp	DWORD PTR _gl_showtextures, 0
	je	SHORT $LN40@Key_Event
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@Key_Event
	mov	DWORD PTR tv185[ebp], 1
	jmp	SHORT $LN41@Key_Event
$LN40@Key_Event:
	mov	DWORD PTR tv185[ebp], 0
$LN41@Key_Event:
	cmp	DWORD PTR tv185[ebp], 0
	je	SHORT $LN23@Key_Event

; 631  : 			{
; 632  : 				// close texture atlas
; 633  : 				Cvar_SetValue( "r_showtextures", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0P@MJMKNHCG@r_showtextures@
	call	_Cvar_SetValue
	add	esp, 8

; 634  : 				return;

	jmp	$LN38@Key_Event

; 635  : 			}

	jmp	SHORT $LN25@Key_Event
$LN23@Key_Event:

; 636  : 			else if( host.mouse_visible && cls.state != ca_cinematic )

	cmp	DWORD PTR _host+34372, 0
	je	SHORT $LN25@Key_Event
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN25@Key_Event

; 637  : 			{
; 638  : 				clgame.dllFuncs.pfnKey_Event( down, key, keys[key].binding );

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	call	DWORD PTR _clgame+140
	add	esp, 12					; 0000000cH

; 639  : 				return; // handled in client.dll

	jmp	$LN38@Key_Event
$LN25@Key_Event:

; 640  : 			}
; 641  : 			break;

	jmp	SHORT $LN2@Key_Event
$LN26@Key_Event:

; 642  : 		case key_message:
; 643  : 			Key_Message( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_Message
	add	esp, 4

; 644  : 			return;

	jmp	$LN38@Key_Event
$LN27@Key_Event:

; 645  : 		case key_console:
; 646  : 			if( cls.state == ca_active && !cl.background )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN28@Key_Event
	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN28@Key_Event

; 647  : 				Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4
	jmp	SHORT $LN29@Key_Event
$LN28@Key_Event:

; 648  : 			else UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN29@Key_Event:

; 649  : 			return;

	jmp	$LN38@Key_Event
$LN30@Key_Event:

; 650  : 		case key_menu:
; 651  : 			UI_KeyEvent( key, true );

	push	1
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_UI_KeyEvent
	add	esp, 8

; 652  : 			return;

	jmp	$LN38@Key_Event
$LN31@Key_Event:

; 653  : 		default:	return;

	jmp	$LN38@Key_Event
$LN2@Key_Event:

; 654  : 		}
; 655  : 	}
; 656  : 
; 657  : 	if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN32@Key_Event

; 658  : 	{
; 659  : 		// only non printable keys passed
; 660  : 		UI_KeyEvent( key, down );

	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_UI_KeyEvent
	add	esp, 8

; 661  : 		return;

	jmp	SHORT $LN38@Key_Event
$LN32@Key_Event:

; 662  : 	}
; 663  : 
; 664  : 	// key up events only perform actions if the game key binding is
; 665  : 	// a button command (leading + sign).  These will be processed even in
; 666  : 	// console mode and menu mode, to keep the character from continuing 
; 667  : 	// an action started before a mode switch.
; 668  : 	if( !down )

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN33@Key_Event

; 669  : 	{
; 670  : 		Key_AddKeyCommands( key, kb, down );

	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Key_AddKeyCommands
	add	esp, 12					; 0000000cH

; 671  : 		return;

	jmp	SHORT $LN38@Key_Event
$LN33@Key_Event:

; 672  : 	}
; 673  : 
; 674  : 	// distribute the key down event to the apropriate handler
; 675  : 	if( cls.key_dest == key_game )

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN34@Key_Event

; 676  : 	{
; 677  : 		Key_AddKeyCommands( key, kb, down );

	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Key_AddKeyCommands
	add	esp, 12					; 0000000cH

; 678  : 	}

	jmp	SHORT $LN38@Key_Event
$LN34@Key_Event:

; 679  : 	else if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN36@Key_Event

; 680  : 	{
; 681  : 		Key_Console( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_Console
	add	esp, 4

; 682  : 	}

	jmp	SHORT $LN38@Key_Event
$LN36@Key_Event:

; 683  : 	else if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN38@Key_Event

; 684  : 	{
; 685  : 		Key_Message( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_Message
	add	esp, 4
$LN38@Key_Event:

; 686  : 	}
; 687  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN42@Key_Event:
	DD	$LN27@Key_Event
	DD	$LN22@Key_Event
	DD	$LN30@Key_Event
	DD	$LN26@Key_Event
_Key_Event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_IsBind
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_IsBind PROC					; COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 123  : 	if( keynum == -1 || !keys[keynum].binding )

	cmp	DWORD PTR _keynum$[ebp], -1
	je	SHORT $LN3@Key_IsBind
	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	jne	SHORT $LN2@Key_IsBind
$LN3@Key_IsBind:

; 124  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Key_IsBind
$LN2@Key_IsBind:

; 125  : 	return keys[keynum].binding;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _keys[eax+12]
$LN1@Key_IsBind:

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_IsBind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\keys.c
;	COMDAT _Key_IsDown
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_IsDown PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 111  : 	if( keynum == -1 )

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_IsDown

; 112  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Key_IsDown
$LN2@Key_IsDown:

; 113  : 	return keys[keynum].down;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _keys[eax]
$LN1@Key_IsDown:

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_IsDown ENDP
_TEXT	ENDS
END
