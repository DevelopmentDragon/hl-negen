; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_game.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnPEntityOfEntIndex
PUBLIC	_pfnDecalIndex
PUBLIC	_pfnIsMapValid
PUBLIC	_pfnNumberOfEntities
PUBLIC	_SV_StartSound
PUBLIC	_SV_AllocEdict
PUBLIC	_SV_FreePrivateData
PUBLIC	_SV_FindEntityByString
PUBLIC	_SV_PlaybackEventFull
PUBLIC	_SV_AllocString
PUBLIC	_SV_GetString
PUBLIC	_pfnIndexOfEdict
PUBLIC	_pfnSetFatPVS
PUBLIC	_pfnSetFatPAS
PUBLIC	_pfnPrecacheModel
PUBLIC	_pfnModelIndex
PUBLIC	_pfnRemoveEntity
PUBLIC	_pfnGetCurrentPlayer
PUBLIC	_pfnSetModel
PUBLIC	_pfnModelFrames
PUBLIC	_pfnSetSize
PUBLIC	_pfnChangeLevel
PUBLIC	_pfnGetSpawnParms
PUBLIC	_pfnSaveSpawnParms
PUBLIC	_pfnVecToYaw
PUBLIC	_pfnMoveToOrigin
PUBLIC	_pfnChangeYaw
PUBLIC	_pfnChangePitch
PUBLIC	_pfnGetEntityIllum
PUBLIC	_pfnFindEntityInSphere
PUBLIC	_pfnFindClientInPVS
PUBLIC	_pfnEntitiesInPVS
PUBLIC	_pfnMakeVectors
PUBLIC	_pfnCreateNamedEntity
PUBLIC	_pfnDropToFloor
PUBLIC	_pfnWalkMove
PUBLIC	_pfnSetOrigin
PUBLIC	_pfnEmitAmbientSound
PUBLIC	_pfnTraceSphere
PUBLIC	_pfnGetAimVector
PUBLIC	_pfnServerCommand
PUBLIC	_pfnServerExecute
PUBLIC	_pfnClientCommand
PUBLIC	_pfnParticleEffect
PUBLIC	_pfnLightStyle
PUBLIC	_pfnMessageBegin
PUBLIC	_pfnMessageEnd
PUBLIC	_pfnWriteByte
PUBLIC	_pfnWriteChar
PUBLIC	_pfnWriteShort
PUBLIC	_pfnWriteLong
PUBLIC	_pfnWriteFlag
PUBLIC	_pfnWriteFloat
PUBLIC	_pfnWriteAngle
PUBLIC	_pfnWriteCoord
PUBLIC	_pfnWriteString
PUBLIC	_pfnWriteEntity
PUBLIC	_pfnBuildSoundMsg
PUBLIC	_pfnPvAllocEntPrivateData
PUBLIC	_pfnPvEntPrivateData
PUBLIC	_pfnGetVarsOfEnt
PUBLIC	_pfnPEntityOfEntOffset
PUBLIC	_pfnEntOffsetOfPEntity
PUBLIC	_pfnFindEntityByVars
PUBLIC	_pfnRegUserMsg
PUBLIC	_pfnAnimationAutomove
PUBLIC	_pfnFunctionFromName
PUBLIC	_pfnNameForFunction
PUBLIC	_pfnClientPrintf
PUBLIC	_pfnServerPrint
PUBLIC	_pfnCrosshairAngle
PUBLIC	_pfnSetView
PUBLIC	_pfnStaticDecal
PUBLIC	_pfnIsDedicatedServer
PUBLIC	_pfnGetPlayerWONId
PUBLIC	_pfnFadeClientVolume
PUBLIC	_pfnSetClientMaxspeed
PUBLIC	_pfnRunPlayerMove
PUBLIC	_pfnGetInfoKeyBuffer
PUBLIC	_pfnSetValueForKey
PUBLIC	_pfnSetClientKeyValue
PUBLIC	_pfnGetPhysicsKeyValue
PUBLIC	_pfnSetPhysicsKeyValue
PUBLIC	_pfnGetPhysicsInfoString
PUBLIC	_pfnPrecacheEvent
PUBLIC	_pfnCheckVisibility
PUBLIC	_pfnCanSkipPlayer
PUBLIC	_pfnSetGroupMask
PUBLIC	_pfnCreateInstancedBaseline
PUBLIC	_pfnEndSection
PUBLIC	_pfnGetPlayerUserId
PUBLIC	_pfnGetPlayerStats
PUBLIC	_pfnForceUnmodified
PUBLIC	_pfnVoice_GetClientListening
PUBLIC	_pfnVoice_SetClientListening
PUBLIC	_pfnGetPlayerAuthId
PUBLIC	_pfnQueryClientCvarValue
PUBLIC	_pfnQueryClientCvarValue2
PUBLIC	??_C@_09CNJINBGN@classname@			; `string'
PUBLIC	??_C@_0L@JILCNGEO@globalname@			; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_09DKDOKEPP@viewmodel@			; `string'
PUBLIC	??_C@_0M@HFKHPDIJ@weaponmodel@			; `string'
PUBLIC	??_C@_08MKOCHEFC@armmodel@			; `string'
PUBLIC	??_C@_06JJLAMBGK@target@			; `string'
PUBLIC	??_C@_0L@FEPNPAJD@targetname@			; `string'
PUBLIC	??_C@_07OLJMCAFB@netname@			; `string'
PUBLIC	??_C@_07ONPBMBOP@message@			; `string'
PUBLIC	??_C@_05GPLCCBII@noise@				; `string'
PUBLIC	??_C@_06CFFBLOIB@noise1@			; `string'
PUBLIC	??_C@_06OHMONEC@noise2@				; `string'
PUBLIC	??_C@_06BHGHNMAD@noise3@			; `string'
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Args:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddServerCommand:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_pfnCvar_RegisterServerVariable:PROC
EXTRN	_pfnCvar_RegisterEngineVariable:PROC
EXTRN	_COM_LoadFileForMe:PROC
EXTRN	_pfnCVarGetPointer:PROC
EXTRN	_pfnCVarDirectSet:PROC
EXTRN	_COM_CheckParm:PROC
EXTRN	_pfnGetGameDir:PROC
EXTRN	_pfnTime:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_CRC32_ProcessByte:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemoveKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_SV_SoundIndex:PROC
EXTRN	_SV_GenericIndex:PROC
EXTRN	_SV_FakeConnect:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	_Delta_AddEncoder:PROC
EXTRN	_Delta_FindField:PROC
EXTRN	_Delta_SetField:PROC
EXTRN	_Delta_UnsetField:PROC
EXTRN	_Delta_SetFieldByIndex:PROC
EXTRN	_Delta_UnsetFieldByIndex:PROC
;	COMDAT ??_C@_06BHGHNMAD@noise3@
CONST	SEGMENT
??_C@_06BHGHNMAD@noise3@ DB 'noise3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHMONEC@noise2@
CONST	SEGMENT
??_C@_06OHMONEC@noise2@ DB 'noise2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFFBLOIB@noise1@
CONST	SEGMENT
??_C@_06CFFBLOIB@noise1@ DB 'noise1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GPLCCBII@noise@
CONST	SEGMENT
??_C@_05GPLCCBII@noise@ DB 'noise', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONPBMBOP@message@
CONST	SEGMENT
??_C@_07ONPBMBOP@message@ DB 'message', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLJMCAFB@netname@
CONST	SEGMENT
??_C@_07OLJMCAFB@netname@ DB 'netname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEPNPAJD@targetname@
CONST	SEGMENT
??_C@_0L@FEPNPAJD@targetname@ DB 'targetname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJLAMBGK@target@
CONST	SEGMENT
??_C@_06JJLAMBGK@target@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MKOCHEFC@armmodel@
CONST	SEGMENT
??_C@_08MKOCHEFC@armmodel@ DB 'armmodel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HFKHPDIJ@weaponmodel@
CONST	SEGMENT
??_C@_0M@HFKHPDIJ@weaponmodel@ DB 'weaponmodel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DKDOKEPP@viewmodel@
CONST	SEGMENT
??_C@_09DKDOKEPP@viewmodel@ DB 'viewmodel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JILCNGEO@globalname@
CONST	SEGMENT
??_C@_0L@JILCNGEO@globalname@ DB 'globalname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNJINBGN@classname@
CONST	SEGMENT
??_C@_09CNJINBGN@classname@ DB 'classname', 00H		; `string'
CONST	ENDS
PUBLIC	_SV_StartMusic
PUBLIC	_SV_CreateDecal
PUBLIC	_SV_GetReliableDatagram
PUBLIC	_SV_RestoreCustomDecal
PUBLIC	_SV_SysError
PUBLIC	_SV_Serverinfo
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetNumBytesLeft
PUBLIC	_MSG_GetData
PUBLIC	_SV_LoadProgs
PUBLIC	_SV_UnloadProgs
PUBLIC	_SV_FreeEdicts
PUBLIC	_SV_FreeEdict
PUBLIC	_SV_InitEdict
PUBLIC	_SV_ClassName
PUBLIC	_SV_CopyTraceToGlobal
PUBLIC	_SV_CheckEdict
PUBLIC	_SV_SetMinMaxSize
PUBLIC	_SV_PlaybackReliableEvent
PUBLIC	_SV_BuildSoundMsg
PUBLIC	_SV_BoxInPVS
PUBLIC	_SV_QueueChangeLevel
PUBLIC	_SV_WriteEntityPatch
PUBLIC	_SV_AngleMod
PUBLIC	_SV_SpawnEntities
PUBLIC	_SV_AllocPrivateData
PUBLIC	_SV_CreateNamedEntity
PUBLIC	_SV_MakeString
PUBLIC	_SV_ClientFromEdict
PUBLIC	_SV_MapIsValid
PUBLIC	_SV_FindGlobalEntity
PUBLIC	_SV_CreateStaticEntity
PUBLIC	_SV_SendUserReg
PUBLIC	_pfnWriteBytes
PUBLIC	_SV_RestartAmbientSounds
PUBLIC	_SV_RestartDecals
PUBLIC	_SV_RestartStaticEnts
PUBLIC	_SV_EdictNum
PUBLIC	_SV_Localinfo
PUBLIC	_SV_GetEntvarsDescirption
PUBLIC	_SV_ConvertTrace
PUBLIC	_SV_CheckClientVisiblity
PUBLIC	_SV_GetEntityClass
PUBLIC	_SV_CheckClientPVS
PUBLIC	_SV_ParseEdict
PUBLIC	_SV_LoadFromFile
PUBLIC	??_C@_0CB@EKNEPLEL@bad?5entity?5?$CFi?5?$CIcalled?5at?5?$CFs?3?$CFi?$CJ@ ; `string'
PUBLIC	??_C@_0CB@CNPMFKGE@FATAL?5ERROR?5?$CIshutting?5down?$CJ?3?5?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_SetMinMaxSize@@9@9		; `SV_SetMinMaxSize'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CL@DCCJHOGJ@?$FO1Error?3?$FO7?5?$CFs?$FL?$CFi?$FN?5has?5backwards@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_CopyTraceToGlobal@@9@9	; `SV_CopyTraceToGlobal'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_CheckClientVisiblity@@9@9	; `SV_CheckClientVisiblity'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_Multicast@@9@9		; `SV_Multicast'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@GLEHBJII@SV_Multicast?3?5bad?5dest?3?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0DG@DMOKJIDJ@?$FO3Warning?3?$FO7?5MAX_STATIC_ENTITIE@ ; `string'
PUBLIC	??_C@_0BK@MLBIDEPC@Music?5has?5been?5restored?$CB?6@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_RestartDecals@@9@9		; `SV_RestartDecals'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@GMIJDHAN@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5is?5i@ ; `string'
PUBLIC	??_C@_0CO@FDLMDCIC@?$FO1Error?3?$FO7?5changelevel?3?5map?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0FM@HPNEIPFC@?$FO3Warning?3?$FO7?5changelevel?3?5?$CFs?5do@ ; `string'
PUBLIC	??_C@_0DG@GJJHOCIH@?$FO1Error?3?$FO7?5can?8t?5changelevel?5wi@ ; `string'
PUBLIC	??_C@_0EG@OMEDMDNK@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5does@ ; `string'
PUBLIC	??_C@_0GC@ICGACPNE@?$FO3Warning?3?$FO7?5an?5infinite?5change@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_WriteEntityPatch@@9@9	; `SV_WriteEntityPatch'::`1'::__LINE__Var
PUBLIC	??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0M@NHJMLCCE@maps?1?$CFs?4ent@		; `string'
PUBLIC	??_C@_0BF@KEIEKBBM@Write?5?8maps?1?$CFs?4ent?8?6@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_ReadEntityScript@@9@9	; `SV_ReadEntityScript'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_MapIsValid@@9@9		; `SV_MapIsValid'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_FreePrivateData@@9@9	; `SV_FreePrivateData'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_InitEdict@@9@9		; `SV_InitEdict'::`1'::__LINE__Var
PUBLIC	??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@	; `string'
PUBLIC	?__LINE__Var@?0??SV_FreeEdict@@9@9		; `SV_FreeEdict'::`1'::__LINE__Var
PUBLIC	??_C@_0CL@KBOCFNED@ED_AllocEdict?3?5no?5free?5edicts?5?$CI@ ; `string'
PUBLIC	??_C@_06EKNFNOKI@custom@			; `string'
PUBLIC	??_C@_0CF@HONNHMII@?$FO1Error?3?$FO7?5No?5spawn?5function?5fo@ ; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_05FAPHKBON@freed@				; `string'
PUBLIC	?__LINE__Var@?0??SV_ClientFromEdict@@9@9	; `SV_ClientFromEdict'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnSetModel@@9@9		; `pfnSetModel'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CJ@FCBGMNHP@?$FO1Error?3?$FO7?5world?5model?5can?8t?5be@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnSetSize@@9@9		; `pfnSetSize'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnMoveToOrigin@@9@9		; `pfnMoveToOrigin'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnChangeYaw@@9@9		; `pfnChangeYaw'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnChangePitch@@9@9		; `pfnChangePitch'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_FindEntityByString@@9@9	; `SV_FindEntityByString'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@CMNBBMAL@?$FO1Error?3?$FO7?5FindEntityByString?3?5@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_FindGlobalEntity@@9@9	; `SV_FindGlobalEntity'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnGetEntityIllum@@9@9		; `pfnGetEntityIllum'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnFindEntityInSphere@@9@9	; `pfnFindEntityInSphere'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_CheckClientPVS@@9@9		; `SV_CheckClientPVS'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnFindClientInPVS@@9@9	; `pfnFindClientInPVS'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnEntitiesInPVS@@9@9		; `pfnEntitiesInPVS'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnRemoveEntity@@9@9		; `pfnRemoveEntity'::`1'::__LINE__Var
PUBLIC	??_C@_05MCBCHHEJ@world@				; `string'
PUBLIC	??_C@_06DGDLPBAN@client@			; `string'
PUBLIC	??_C@_0BM@ODNHFHLH@?$FO1Error?3?$FO7?5can?8t?5delete?5?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnMakeStatic@@9@9		; `pfnMakeStatic'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnEntIsOnFloor@@9@9		; `pfnEntIsOnFloor'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnDropToFloor@@9@9		; `pfnDropToFloor'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnWalkMove@@9@9		; `pfnWalkMove'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnSetOrigin@@9@9		; `pfnSetOrigin'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_BuildSoundMsg@@9@9		; `SV_BuildSoundMsg'::`1'::__LINE__Var
PUBLIC	??_C@_0CH@DPGAHNFB@?$FO1Error?3?$FO7?5SV_StartSound?3?5volum@ ; `string'
PUBLIC	??_C@_0DP@DGGLGLAC@?$FO1Error?3?$FO7?5SV_StartSound?3?5atten@ ; `string'
PUBLIC	??_C@_0DI@DIDLBLOO@?$FO1Error?3?$FO7?5SV_StartSound?3?5chann@ ; `string'
PUBLIC	??_C@_0CG@KAOAFKMC@?$FO1Error?3?$FO7?5SV_StartSound?3?5pitch@ ; `string'
PUBLIC	??_C@_0CO@PHKOJBD@?$FO1Error?3?$FO7?5SV_StartSound?3?5passe@ ; `string'
PUBLIC	??_C@_0DB@HNKDPEFJ@?$FO1Error?3?$FO7?5SV_StartSound?3?5?$CFs?5no@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_StartSound@@9@9		; `SV_StartSound'::`1'::__LINE__Var
PUBLIC	??_C@_09MNJMHLFH@?5restored@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07HPJIJIBE@?5onloop@			; `string'
PUBLIC	??_C@_0CE@GIODLDCP@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@ ; `string'
PUBLIC	??_C@_0BM@LLGKIMNB@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnTraceLine@@9@9		; `pfnTraceLine'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnTraceToss@@9@9		; `pfnTraceToss'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnTraceMonsterHull@@9@9	; `pfnTraceMonsterHull'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnTraceModel@@9@9		; `pfnTraceModel'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnTraceTexture@@9@9		; `pfnTraceTexture'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnGetAimVector@@9@9		; `pfnGetAimVector'::`1'::__LINE__Var
PUBLIC	??_C@_06MMOECJNC@sv_aim@			; `string'
PUBLIC	??_C@_0CC@INNNGHJO@?$FO1Error?3?$FO7?5bad?5server?5command?5?$CF@ ; `string'
PUBLIC	??_C@_0BB@JIFJKOMC@exec?5config?4cfg?6@		; `string'
PUBLIC	??_C@_0CM@OAOLJEAF@server?5executing?5?$FO2config?4cfg?$FO7@ ; `string'
PUBLIC	??_C@_0CN@FJFCNMMM@?$FO1Error?3?$FO7?5stuffcmd?3?5client?5is?5@ ; `string'
PUBLIC	??_C@_0CK@EAGFDIFF@?$FO1Error?3?$FO7?5Tried?5to?5stuff?5bad?5c@ ; `string'
PUBLIC	??_C@_0BP@JJDAPFDH@SV_LightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5?$CFd@ ; `string'
PUBLIC	??_C@_0EH@HCPBMJBO@MessageBegin?3?5New?5message?5start@ ; `string'
PUBLIC	??_C@_0DF@DGIJNFM@MessageBegin?3?5tried?5to?5send?5unr@ ; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_0CL@FLBHMFLG@MessageEnd?3?5called?5with?5no?5acti@ ; `string'
PUBLIC	??_C@_0DJ@IJHNIFDN@?$FO1Error?3?$FO7?5MessageEnd?3?5?$CFs?5has?5o@ ; `string'
PUBLIC	??_C@_0DL@INOJEHEK@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5too@ ; `string'
PUBLIC	??_C@_0DB@FEKFALM@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5wri@ ; `string'
PUBLIC	??_C@_0EI@JEOGGFON@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5exp@ ; `string'
PUBLIC	??_C@_0DE@PHIMGBJI@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5hav@ ; `string'
PUBLIC	??_C@_0CP@GBHNFJCB@?$FO1Error?3?$FO7?5pfnWriteString?3?5exce@ ; `string'
PUBLIC	??_C@_0CH@LLHMCHCO@MSG_WriteEntity?3?5invalid?5entnum@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0N@NJFDINDI@?$FO2Note?3?$FO7?5?$CFs@	; `string'
PUBLIC	??_C@_0BA@KNHIKLDN@?$FO3Warning?3?$FO7?5?$CFs@	; `string'
PUBLIC	??_C@_0O@DKJGHMGN@?$FO1Error?3?$FO7?5?$CFs@	; `string'
PUBLIC	?__LINE__Var@?0??pfnPvAllocEntPrivateData@@9@9	; `pfnPvAllocEntPrivateData'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_AllocString@@9@9		; `SV_AllocString'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@JOJIMKK@bad?5entity?5number?5?$CFd?6@	; `string'
PUBLIC	?__LINE__Var@?0??pfnPEntityOfEntIndex@@9@9	; `pfnPEntityOfEntIndex'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnGetModelPtr@@9@9		; `pfnGetModelPtr'::`1'::__LINE__Var
PUBLIC	??_C@_0CL@JAIHJPPE@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5too?5lo@ ; `string'
PUBLIC	??_C@_0DB@LHMDHGPA@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5?$CFs?5has@ ; `string'
PUBLIC	??_C@_0DH@NDFPHNBP@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5user?5m@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnGetBonePosition@@9@9	; `pfnGetBonePosition'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@LCDPNMPO@tried?5to?5sprint?5to?5a?5non?9client@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnGetAttachment@@9@9		; `pfnGetAttachment'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnSetView@@9@9		; `pfnSetView'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@CCGIJEH@?$FO1Error?3?$FO7?5PF_SetView_I?3?5not?5a?5@ ; `string'
PUBLIC	??_C@_03EICDNICE@?$CF?4f@			; `string'
PUBLIC	??_C@_06KOBCLDNE@maxspd@			; `string'
PUBLIC	?__LINE__Var@?0??pfnGetInfoKeyBuffer@@9@9	; `pfnGetInfoKeyBuffer'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@PMHMFMJC@?$FO1Error?3?$FO7?5can?8t?5set?5client?5key@ ; `string'
PUBLIC	??_C@_0DH@MCFALDIE@?$FO1Error?3?$FO7?5GetPhysicsKeyValue?3?5@ ; `string'
PUBLIC	??_C@_0DH@KFOANOOP@?$FO1Error?3?$FO7?5SetPhysicsKeyValue?3?5@ ; `string'
PUBLIC	??_C@_0DJ@NNOEMDHI@?$FO1Error?3?$FO7?5GetPhysicsInfoString@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_PlaybackEventFull@@9@9	; `SV_PlaybackEventFull'::`1'::__LINE__Var
PUBLIC	??_C@_0CP@PCBGDAKA@?$FO1Error?3?$FO7?5EV_Playback?3?5invalid@ ; `string'
PUBLIC	??_C@_0DE@KNGIJMBL@?$FO1Error?3?$FO7?5EV_Playback?3?5event?5?$CF@ ; `string'
PUBLIC	??_C@_0EA@KCPAHPLE@?$FO1Error?3?$FO7?5?$CFs?3?5not?5a?5FEV_GLOBAL@ ; `string'
PUBLIC	??_C@_0EC@BKEFCDLJ@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@ ; `string'
PUBLIC	??_C@_0ED@FODMFBMN@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnSetFatPVS@@9@9		; `pfnSetFatPVS'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnSetFatPAS@@9@9		; `pfnSetFatPAS'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnCheckVisibility@@9@9	; `pfnCheckVisibility'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnCreateInstancedBaseline@@9@9 ; `pfnCreateInstancedBaseline'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@HODEPMM@oem_end_credits@		; `string'
PUBLIC	??_C@_0N@IDGDMADI@?6disconnect?6@		; `string'
PUBLIC	?__LINE__Var@?0??pfnForceUnmodified@@9@9	; `pfnForceUnmodified'::`1'::__LINE__Var
PUBLIC	??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@ ; `string'
PUBLIC	??_C@_0L@GBBDLGEP@Bad?5Player@			; `string'
PUBLIC	??_C@_0EB@NIKEOBLP@?$FO1Error?3?$FO7?5QueryClientCvarValue@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_ParseEdict@@9@9		; `SV_ParseEdict'::`1'::__LINE__Var
PUBLIC	??_C@_0CK@PBLIDAI@ED_ParseEdict?3?5EOF?5without?5clos@ ; `string'
PUBLIC	??_C@_0CL@OPGPBFON@ED_ParseEdict?3?5closing?5brace?5wi@ ; `string'
PUBLIC	??_C@_03GANHLHHC@wad@				; `string'
PUBLIC	??_C@_06PHHMIKBC@_light@			; `string'
PUBLIC	??_C@_0M@EJFMBEL@customclass@			; `string'
PUBLIC	??_C@_02FCKFMMHG@ce@				; `string'
PUBLIC	??_C@_07NCGJLOHD@ce08_02@			; `string'
PUBLIC	??_C@_0BI@PMCHBKMF@info_player_start_force@	; `string'
PUBLIC	??_C@_05FECBCJJD@angle@				; `string'
PUBLIC	??_C@_06GNEAMJOC@angles@			; `string'
PUBLIC	??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg@		; `string'
PUBLIC	??_C@_07BHMOBHIL@?990?50?50@			; `string'
PUBLIC	??_C@_06INPDGABL@90?50?50@			; `string'
PUBLIC	??_C@_05JMKGPOEH@0?50?50@			; `string'
PUBLIC	??_C@_06NHCMNMEH@origin@			; `string'
PUBLIC	??_C@_05OEPGNJB@light@				; `string'
PUBLIC	??_C@_0M@EMAIGPBJ@light_level@			; `string'
PUBLIC	?__LINE__Var@?0??SV_LoadFromFile@@9@9		; `SV_LoadFromFile'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@LCBBAJPK@entities?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0CM@IJEJEKHJ@ED_LoadFromFile?3?5found?5?$CFs?5when?5@ ; `string'
PUBLIC	??_C@_0BI@PMNHCCDI@?6?$CFi?5entities?5inhibited?6@ ; `string'
PUBLIC	??_C@_07BOLPGMIP@sv_zmax@			; `string'
PUBLIC	??_C@_0M@COFDEJEF@sv_wateramp@			; `string'
PUBLIC	??_C@_0O@IFEMIFOJ@sv_wateralpha@		; `string'
PUBLIC	??_C@_0O@CGCGGHO@sv_skycolor_r@			; `string'
PUBLIC	??_C@_0O@DFNHIAGK@sv_skycolor_g@		; `string'
PUBLIC	??_C@_0O@EIKAHECP@sv_skycolor_b@		; `string'
PUBLIC	??_C@_0M@JBBFCNJL@sv_skyvec_x@			; `string'
PUBLIC	??_C@_0M@IIAOBMNK@sv_skyvec_y@			; `string'
PUBLIC	??_C@_0M@KDCDEPBJ@sv_skyvec_z@			; `string'
PUBLIC	??_C@_0L@NPFKENCH@sv_skyname@			; `string'
PUBLIC	??_C@_0M@PCFOFDPA@sv_skydir_x@			; `string'
PUBLIC	??_C@_0M@OLEFGCLB@sv_skydir_y@			; `string'
PUBLIC	??_C@_0M@MAGIDBHC@sv_skydir_z@			; `string'
PUBLIC	??_C@_0M@KODFIOCL@sv_skyangle@			; `string'
PUBLIC	??_C@_0M@IDDIMGBN@sv_skyspeed@			; `string'
PUBLIC	?__LINE__Var@?0??SV_UnloadProgs@@9@9		; `SV_UnloadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BA@HFMOEDOL@host_gameloaded@		; `string'
PUBLIC	??_C@_0O@DOOGBBKD@sv_background@		; `string'
PUBLIC	?__LINE__Var@?0??SV_LoadProgs@@9@9		; `SV_LoadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@JHKBCDAM@Server?5Edicts?5Zone@	; `string'
PUBLIC	??_C@_0N@BOKHDMKE@GetEntityAPI@			; `string'
PUBLIC	??_C@_0O@DMNFJELM@GetEntityAPI2@		; `string'
PUBLIC	??_C@_0BD@CFIEBNAN@GetNewDLLFunctions@		; `string'
PUBLIC	??_C@_0EF@HCGHAGDG@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@ ; `string'
PUBLIC	??_C@_0BA@FAHPOONL@GiveFnptrsToDll@		; `string'
PUBLIC	??_C@_0EI@LJHOCIDJ@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@ ; `string'
PUBLIC	??_C@_0EC@MKPMDLBC@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5new?5@ ; `string'
PUBLIC	??_C@_0DO@PGAKJPDF@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5inte@ ; `string'
PUBLIC	??_C@_0DC@HKCPGJHF@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5couldn@ ; `string'
PUBLIC	??_C@_0DK@CKBBBEDK@SV_LoadProgs?3?5?$FO2initailized?5ext@ ; `string'
PUBLIC	??_C@_0DF@JPPJHCLE@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5coul@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0P@HMJCFNPL@Server?5Strings@		; `string'
PUBLIC	??_C@_0BM@KKGMNAON@Dll?5loaded?5for?5game?5?$FO2?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40a00000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42800000
PUBLIC	__real@42c80000
PUBLIC	__real@42fe0000
PUBLIC	__real@43340000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43b40000
PUBLIC	__real@447a0000
PUBLIC	__real@45000000
PUBLIC	__real@45800000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c3000000
PUBLIC	__real@c3340000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Unlink:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_IsAllocatedExt:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_Cvar_Unlink:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_ParseVector:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Host_Credits:PROC
EXTRN	_COM_ChangeLevel:PROC
EXTRN	_SV_Active:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_DisableVisibility:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_R_CreateDecalList:PROC
EXTRN	_R_ClearAllDecals:PROC
EXTRN	_R_ClearStaticEntities:PROC
EXTRN	_S_StreamGetCurrentState:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_SetValueForStarKey:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_S_GetCurrentStaticSounds:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_Mod_ClearUserData:PROC
EXTRN	_Mod_StudioExtradata:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_Mod_TestBmodelLumps:PROC
EXTRN	_Mod_HeadnodeVisible:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_Mod_GetPVSForPoint:PROC
EXTRN	_Mod_InitStudioAPI:PROC
EXTRN	_Mod_ResetStudioAPI:PROC
EXTRN	_Mod_StudioGetAttachment:PROC
EXTRN	_Mod_GetBonePosition:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteChar:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteShort:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteFlag:PROC
EXTRN	_MSG_WriteCoord:PROC
EXTRN	_MSG_WriteFloat:PROC
EXTRN	_MSG_WriteVec3Coord:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_SV_ModelIndex:PROC
EXTRN	_SV_EventIndex:PROC
EXTRN	_SV_InitOperatorCommands:PROC
EXTRN	_SV_KillOperatorCommands:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_DeactivateServer:PROC
EXTRN	_SV_InitPhysicsAPI:PROC
EXTRN	_SV_MoveStep:PROC
EXTRN	_SV_MoveTest:PROC
EXTRN	_SV_MoveToOrigin:PROC
EXTRN	_SV_CheckBottom:PROC
EXTRN	_SV_VecToYaw:PROC
EXTRN	_SV_ClientPrintf:PROC
EXTRN	_SV_GetClientIDString:PROC
EXTRN	_SV_RunCmd:PROC
EXTRN	_SV_IsPlayerIndex:PROC
EXTRN	_SV_InitClientMove:PROC
EXTRN	_SV_FindBestBaselineForStatic:PROC
EXTRN	_SV_SkipUpdates:PROC
EXTRN	_SV_InitSaveRestore:PROC
EXTRN	_SV_UnlinkEdict:PROC
EXTRN	_SV_ClipMoveToEntity:PROC
EXTRN	_SV_CustomClipMoveToEntity:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_TraceTexture:PROC
EXTRN	_SV_MoveToss:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_SV_SetLightStyle:PROC
EXTRN	_SV_LightForEntity:PROC
EXTRN	_Delta_Init:PROC
EXTRN	_Delta_Shutdown:PROC
EXTRN	_MSG_WriteDeltaEvent:PROC
EXTRN	_MSG_WriteDeltaEntity:PROC
EXTRN	_COM_LoadLibrary:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_COM_NameForFunction:PROC
EXTRN	_COM_FunctionFromName:PROC
EXTRN	_COM_FreeLibrary:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_world:BYTE
EXTRN	_svc_strings:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_novis:DWORD
EXTRN	_sv_validate_changelevel:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_fatpvs	DB	0fffH DUP (?)
	ALIGN	4

_fatphs	DB	0fffH DUP (?)
	ALIGN	4

_clientpvs DB	0fffH DUP (?)
	ALIGN	4

_viewPoint DD	060H DUP (?)
?last_spawncount@?1??pfnChangeLevel@@9@9 DD 01H DUP (?)	; `pfnChangeLevel'::`2'::last_spawncount
?string@?1??pfnWriteString@@9@9 DB 0800H DUP (?)	; `pfnWriteString'::`2'::string
?GetEntityAPI@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GetEntityAPI
?GetEntityAPI2@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GetEntityAPI2
?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GiveFnptrsToDll
?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GiveNewDllFuncs
?gpEngfuncs@?1??SV_LoadProgs@@9@9 DB 0280H DUP (?)	; `SV_LoadProgs'::`2'::gpEngfuncs
?gpGlobals@?1??SV_LoadProgs@@9@9 DB 0b0H DUP (?)	; `SV_LoadProgs'::`2'::gpGlobals
?gpMove@?1??SV_LoadProgs@@9@9 DB 04f5d4H DUP (?)	; `SV_LoadProgs'::`2'::gpMove
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c3000000
CONST	SEGMENT
__real@c3000000 DD 0c3000000r			; -128
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BM@KKGMNAON@Dll?5loaded?5for?5game?5?$FO2?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BM@KKGMNAON@Dll?5loaded?5for?5game?5?$FO2?$CC?$CFs?$CC?6@ DB 'Dll '
	DB	'loaded for game ^2"%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMJCFNPL@Server?5Strings@
CONST	SEGMENT
??_C@_0P@HMJCFNPL@Server?5Strings@ DB 'Server Strings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JPPJHCLE@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5coul@
CONST	SEGMENT
??_C@_0DF@JPPJHCLE@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5coul@ DB '^3Warni'
	DB	'ng:^7 SV_LoadProgs: couldn''t get physics API', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CKBBBEDK@SV_LoadProgs?3?5?$FO2initailized?5ext@
CONST	SEGMENT
??_C@_0DK@CKBBBEDK@SV_LoadProgs?3?5?$FO2initailized?5ext@ DB 'SV_LoadProg'
	DB	's: ^2initailized extended EntityAPI ^7ver. %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HKCPGJHF@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5couldn@
CONST	SEGMENT
??_C@_0DC@HKCPGJHF@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5couldn@ DB '^1Error'
	DB	':^7 SV_LoadProgs: couldn''t get entity API', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PGAKJPDF@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5inte@
CONST	SEGMENT
??_C@_0DO@PGAKJPDF@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5inte@ DB '^3Warni'
	DB	'ng:^7 SV_LoadProgs: interface version %i should be %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MKPMDLBC@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5new?5@
CONST	SEGMENT
??_C@_0EC@MKPMDLBC@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5new?5@ DB '^3Warn'
	DB	'ing:^7 SV_LoadProgs: new interface version %i should be %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@LJHOCIDJ@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@
CONST	SEGMENT
??_C@_0EI@LJHOCIDJ@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@ DB '^1Error'
	DB	':^7 SV_LoadProgs: failed to get address of GiveFnptrsToDll pr'
	DB	'oc', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FAHPOONL@GiveFnptrsToDll@
CONST	SEGMENT
??_C@_0BA@FAHPOONL@GiveFnptrsToDll@ DB 'GiveFnptrsToDll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HCGHAGDG@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@
CONST	SEGMENT
??_C@_0EF@HCGHAGDG@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@ DB '^1Error'
	DB	':^7 SV_LoadProgs: failed to get address of GetEntityAPI proc', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CFIEBNAN@GetNewDLLFunctions@
CONST	SEGMENT
??_C@_0BD@CFIEBNAN@GetNewDLLFunctions@ DB 'GetNewDLLFunctions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMNFJELM@GetEntityAPI2@
CONST	SEGMENT
??_C@_0O@DMNFJELM@GetEntityAPI2@ DB 'GetEntityAPI2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOKHDMKE@GetEntityAPI@
CONST	SEGMENT
??_C@_0N@BOKHDMKE@GetEntityAPI@ DB 'GetEntityAPI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JHKBCDAM@Server?5Edicts?5Zone@
CONST	SEGMENT
??_C@_0BD@JHKBCDAM@Server?5Edicts?5Zone@ DB 'Server Edicts Zone', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_LoadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_LoadProgs@@9@9 DD 012d6H		; `SV_LoadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@DOOGBBKD@sv_background@
CONST	SEGMENT
??_C@_0O@DOOGBBKD@sv_background@ DB 'sv_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HFMOEDOL@host_gameloaded@
CONST	SEGMENT
??_C@_0BA@HFMOEDOL@host_gameloaded@ DB 'host_gameloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_UnloadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_UnloadProgs@@9@9 DD 012b0H		; `SV_UnloadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@IDDIMGBN@sv_skyspeed@
CONST	SEGMENT
??_C@_0M@IDDIMGBN@sv_skyspeed@ DB 'sv_skyspeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KODFIOCL@sv_skyangle@
CONST	SEGMENT
??_C@_0M@KODFIOCL@sv_skyangle@ DB 'sv_skyangle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MAGIDBHC@sv_skydir_z@
CONST	SEGMENT
??_C@_0M@MAGIDBHC@sv_skydir_z@ DB 'sv_skydir_z', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OLEFGCLB@sv_skydir_y@
CONST	SEGMENT
??_C@_0M@OLEFGCLB@sv_skydir_y@ DB 'sv_skydir_y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCFOFDPA@sv_skydir_x@
CONST	SEGMENT
??_C@_0M@PCFOFDPA@sv_skydir_x@ DB 'sv_skydir_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPFKENCH@sv_skyname@
CONST	SEGMENT
??_C@_0L@NPFKENCH@sv_skyname@ DB 'sv_skyname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KDCDEPBJ@sv_skyvec_z@
CONST	SEGMENT
??_C@_0M@KDCDEPBJ@sv_skyvec_z@ DB 'sv_skyvec_z', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIAOBMNK@sv_skyvec_y@
CONST	SEGMENT
??_C@_0M@IIAOBMNK@sv_skyvec_y@ DB 'sv_skyvec_y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBBFCNJL@sv_skyvec_x@
CONST	SEGMENT
??_C@_0M@JBBFCNJL@sv_skyvec_x@ DB 'sv_skyvec_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EIKAHECP@sv_skycolor_b@
CONST	SEGMENT
??_C@_0O@EIKAHECP@sv_skycolor_b@ DB 'sv_skycolor_b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFNHIAGK@sv_skycolor_g@
CONST	SEGMENT
??_C@_0O@DFNHIAGK@sv_skycolor_g@ DB 'sv_skycolor_g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGCGGHO@sv_skycolor_r@
CONST	SEGMENT
??_C@_0O@CGCGGHO@sv_skycolor_r@ DB 'sv_skycolor_r', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFEMIFOJ@sv_wateralpha@
CONST	SEGMENT
??_C@_0O@IFEMIFOJ@sv_wateralpha@ DB 'sv_wateralpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFDEJEF@sv_wateramp@
CONST	SEGMENT
??_C@_0M@COFDEJEF@sv_wateramp@ DB 'sv_wateramp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BOLPGMIP@sv_zmax@
CONST	SEGMENT
??_C@_07BOLPGMIP@sv_zmax@ DB 'sv_zmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PMNHCCDI@?6?$CFi?5entities?5inhibited?6@
CONST	SEGMENT
??_C@_0BI@PMNHCCDI@?6?$CFi?5entities?5inhibited?6@ DB 0aH, '%i entities i'
	DB	'nhibited', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IJEJEKHJ@ED_LoadFromFile?3?5found?5?$CFs?5when?5@
CONST	SEGMENT
??_C@_0CM@IJEJEKHJ@ED_LoadFromFile?3?5found?5?$CFs?5when?5@ DB 'ED_LoadFr'
	DB	'omFile: found %s when expecting {', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCBBAJPK@entities?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BB@LCBBAJPK@entities?5?$CB?$DN?5NULL@ DB 'entities != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_LoadFromFile@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_LoadFromFile@@9@9 DD 0124fH		; `SV_LoadFromFile'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@EMAIGPBJ@light_level@
CONST	SEGMENT
??_C@_0M@EMAIGPBJ@light_level@ DB 'light_level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEPGNJB@light@
CONST	SEGMENT
??_C@_05OEPGNJB@light@ DB 'light', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHCMNMEH@origin@
CONST	SEGMENT
??_C@_06NHCMNMEH@origin@ DB 'origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMKGPOEH@0?50?50@
CONST	SEGMENT
??_C@_05JMKGPOEH@0?50?50@ DB '0 0 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INPDGABL@90?50?50@
CONST	SEGMENT
??_C@_06INPDGABL@90?50?50@ DB '90 0 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHMOBHIL@?990?50?50@
CONST	SEGMENT
??_C@_07BHMOBHIL@?990?50?50@ DB '-90 0 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg@
CONST	SEGMENT
??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg@ DB '%g %g %g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNEAMJOC@angles@
CONST	SEGMENT
??_C@_06GNEAMJOC@angles@ DB 'angles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FECBCJJD@angle@
CONST	SEGMENT
??_C@_05FECBCJJD@angle@ DB 'angle', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PMCHBKMF@info_player_start_force@
CONST	SEGMENT
??_C@_0BI@PMCHBKMF@info_player_start_force@ DB 'info_player_start_force', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCGJLOHD@ce08_02@
CONST	SEGMENT
??_C@_07NCGJLOHD@ce08_02@ DB 'ce08_02', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FCKFMMHG@ce@
CONST	SEGMENT
??_C@_02FCKFMMHG@ce@ DB 'ce', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJFMBEL@customclass@
CONST	SEGMENT
??_C@_0M@EJFMBEL@customclass@ DB 'customclass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PHHMIKBC@_light@
CONST	SEGMENT
??_C@_06PHHMIKBC@_light@ DB '_light', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GANHLHHC@wad@
CONST	SEGMENT
??_C@_03GANHLHHC@wad@ DB 'wad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OPGPBFON@ED_ParseEdict?3?5closing?5brace?5wi@
CONST	SEGMENT
??_C@_0CL@OPGPBFON@ED_ParseEdict?3?5closing?5brace?5wi@ DB 'ED_ParseEdict'
	DB	': closing brace without data', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBLIDAI@ED_ParseEdict?3?5EOF?5without?5clos@
CONST	SEGMENT
??_C@_0CK@PBLIDAI@ED_ParseEdict?3?5EOF?5without?5clos@ DB 'ED_ParseEdict:'
	DB	' EOF without closing brace', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ParseEdict@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ParseEdict@@9@9 DD 011b1H		; `SV_ParseEdict'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EB@NIKEOBLP@?$FO1Error?3?$FO7?5QueryClientCvarValue@
CONST	SEGMENT
??_C@_0EB@NIKEOBLP@?$FO1Error?3?$FO7?5QueryClientCvarValue@ DB '^1Error:^'
	DB	'7 QueryClientCvarValue: tried to send to a non-client!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBBDLGEP@Bad?5Player@
CONST	SEGMENT
??_C@_0L@GBBDLGEP@Bad?5Player@ DB 'Bad Player', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@ DB 'MAX_'
	DB	'MODELS limit exceeded (%d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnForceUnmodified@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnForceUnmodified@@9@9 DD 01066H	; `pfnForceUnmodified'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@IDGDMADI@?6disconnect?6@
CONST	SEGMENT
??_C@_0N@IDGDMADI@?6disconnect?6@ DB 0aH, 'disconnect', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HODEPMM@oem_end_credits@
CONST	SEGMENT
??_C@_0BA@HODEPMM@oem_end_credits@ DB 'oem_end_credits', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnCreateInstancedBaseline@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnCreateInstancedBaseline@@9@9 DD 01023H ; `pfnCreateInstancedBaseline'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnCheckVisibility@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnCheckVisibility@@9@9 DD 0fc4H	; `pfnCheckVisibility'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetFatPAS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetFatPAS@@9@9 DD 0f95H		; `pfnSetFatPAS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetFatPVS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetFatPVS@@9@9 DD 0f63H		; `pfnSetFatPVS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0ED@FODMFBMN@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@
CONST	SEGMENT
??_C@_0ED@FODMFBMN@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@ DB '^3W'
	DB	'arning:^7 %s: specified FEV_HOSTONLY when invoker not a clien'
	DB	't', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@BKEFCDLJ@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@
CONST	SEGMENT
??_C@_0EC@BKEFCDLJ@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@ DB '^3W'
	DB	'arning:^7 %s: specified FEV_NOTHOST when invoker not a client'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@KCPAHPLE@?$FO1Error?3?$FO7?5?$CFs?3?5not?5a?5FEV_GLOBAL@
CONST	SEGMENT
??_C@_0EA@KCPAHPLE@?$FO1Error?3?$FO7?5?$CFs?3?5not?5a?5FEV_GLOBAL@ DB '^1'
	DB	'Error:^7 %s: not a FEV_GLOBAL event missing origin. Ignored.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KNGIJMBL@?$FO1Error?3?$FO7?5EV_Playback?3?5event?5?$CF@
CONST	SEGMENT
??_C@_0DE@KNGIJMBL@?$FO1Error?3?$FO7?5EV_Playback?3?5event?5?$CF@ DB '^1E'
	DB	'rror:^7 EV_Playback: event %i was not precached', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PCBGDAKA@?$FO1Error?3?$FO7?5EV_Playback?3?5invalid@
CONST	SEGMENT
??_C@_0CP@PCBGDAKA@?$FO1Error?3?$FO7?5EV_Playback?3?5invalid@ DB '^1Error'
	DB	':^7 EV_Playback: invalid eventindex %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_PlaybackEventFull@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_PlaybackEventFull@@9@9 DD 0e8dH	; `SV_PlaybackEventFull'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DJ@NNOEMDHI@?$FO1Error?3?$FO7?5GetPhysicsInfoString@
CONST	SEGMENT
??_C@_0DJ@NNOEMDHI@?$FO1Error?3?$FO7?5GetPhysicsInfoString@ DB '^1Error:^'
	DB	'7 GetPhysicsInfoString: tried to a non-client!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KFOANOOP@?$FO1Error?3?$FO7?5SetPhysicsKeyValue?3?5@
CONST	SEGMENT
??_C@_0DH@KFOANOOP@?$FO1Error?3?$FO7?5SetPhysicsKeyValue?3?5@ DB '^1Error'
	DB	':^7 SetPhysicsKeyValue: tried to a non-client!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MCFALDIE@?$FO1Error?3?$FO7?5GetPhysicsKeyValue?3?5@
CONST	SEGMENT
??_C@_0DH@MCFALDIE@?$FO1Error?3?$FO7?5GetPhysicsKeyValue?3?5@ DB '^1Error'
	DB	':^7 GetPhysicsKeyValue: tried to a non-client!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PMHMFMJC@?$FO1Error?3?$FO7?5can?8t?5set?5client?5key@
CONST	SEGMENT
??_C@_0DG@PMHMFMJC@?$FO1Error?3?$FO7?5can?8t?5set?5client?5key@ DB '^1Err'
	DB	'or:^7 can''t set client keys with SetValueForKey', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetInfoKeyBuffer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetInfoKeyBuffer@@9@9 DD 0dfeH	; `pfnGetInfoKeyBuffer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06KOBCLDNE@maxspd@
CONST	SEGMENT
??_C@_06KOBCLDNE@maxspd@ DB 'maxspd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EICDNICE@?$CF?4f@
CONST	SEGMENT
??_C@_03EICDNICE@?$CF?4f@ DB '%.f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CCGIJEH@?$FO1Error?3?$FO7?5PF_SetView_I?3?5not?5a?5@
CONST	SEGMENT
??_C@_0CI@CCGIJEH@?$FO1Error?3?$FO7?5PF_SetView_I?3?5not?5a?5@ DB '^1Erro'
	DB	'r:^7 PF_SetView_I: not a client!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetView@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetView@@9@9 DD 0d40H		; `pfnSetView'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetAttachment@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetAttachment@@9@9 DD 0d18H		; `pfnGetAttachment'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@LCDPNMPO@tried?5to?5sprint?5to?5a?5non?9client@
CONST	SEGMENT
??_C@_0CB@LCDPNMPO@tried?5to?5sprint?5to?5a?5non?9client@ DB 'tried to sp'
	DB	'rint to a non-client', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetBonePosition@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetBonePosition@@9@9 DD 0cc7H	; `pfnGetBonePosition'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DH@NDFPHNBP@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5user?5m@
CONST	SEGMENT
??_C@_0DH@NDFPHNBP@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5user?5m@ DB '^1Erro'
	DB	'r:^7 REG_USER_MSG: user messages limit exceeded', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LHMDHGPA@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5?$CFs?5has@
CONST	SEGMENT
??_C@_0DB@LHMDHGPA@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5?$CFs?5has@ DB '^1E'
	DB	'rror:^7 REG_USER_MSG: %s has too big size %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JAIHJPPE@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5too?5lo@
CONST	SEGMENT
??_C@_0CL@JAIHJPPE@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5too?5lo@ DB '^1Erro'
	DB	'r:^7 REG_USER_MSG: too long name %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetModelPtr@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetModelPtr@@9@9 DD 0c64H		; `pfnGetModelPtr'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnPEntityOfEntIndex@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnPEntityOfEntIndex@@9@9 DD 0c2eH	; `pfnPEntityOfEntIndex'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@JOJIMKK@bad?5entity?5number?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@JOJIMKK@bad?5entity?5number?5?$CFd?6@ DB 'bad entity number %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_AllocString@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_AllocString@@9@9 DD 0bbaH		; `SV_AllocString'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnPvAllocEntPrivateData@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnPvAllocEntPrivateData@@9@9 DD 0b96H	; `pfnPvAllocEntPrivateData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@DKJGHMGN@?$FO1Error?3?$FO7?5?$CFs@
CONST	SEGMENT
??_C@_0O@DKJGHMGN@?$FO1Error?3?$FO7?5?$CFs@ DB '^1Error:^7 %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KNHIKLDN@?$FO3Warning?3?$FO7?5?$CFs@
CONST	SEGMENT
??_C@_0BA@KNHIKLDN@?$FO3Warning?3?$FO7?5?$CFs@ DB '^3Warning:^7 %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NJFDINDI@?$FO2Note?3?$FO7?5?$CFs@
CONST	SEGMENT
??_C@_0N@NJFDINDI@?$FO2Note?3?$FO7?5?$CFs@ DB '^2Note:^7 %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LLHMCHCO@MSG_WriteEntity?3?5invalid?5entnum@
CONST	SEGMENT
??_C@_0CH@LLHMCHCO@MSG_WriteEntity?3?5invalid?5entnum@ DB 'MSG_WriteEntit'
	DB	'y: invalid entnumber %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GBHNFJCB@?$FO1Error?3?$FO7?5pfnWriteString?3?5exce@
CONST	SEGMENT
??_C@_0CP@GBHNFJCB@?$FO1Error?3?$FO7?5pfnWriteString?3?5exce@ DB '^1Error'
	DB	':^7 pfnWriteString: exceeds %i symbols', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PHIMGBJI@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5hav@
CONST	SEGMENT
??_C@_0DE@PHIMGBJI@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5hav@ DB '^1E'
	DB	'rror:^7 SV_Multicast: %s have encountered error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@JEOGGFON@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5exp@
CONST	SEGMENT
??_C@_0EI@JEOGGFON@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5exp@ DB '^1E'
	DB	'rror:^7 SV_Multicast: %s expected %i bytes, it written %i. Ig'
	DB	'nored.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FEKFALM@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5wri@
CONST	SEGMENT
??_C@_0DB@FEKFALM@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5wri@ DB '^1Er'
	DB	'ror:^7 SV_Multicast: %s writes NULL message', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@INOJEHEK@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5too@
CONST	SEGMENT
??_C@_0DL@INOJEHEK@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5too@ DB '^1E'
	DB	'rror:^7 SV_Multicast: %s too long (more than %d bytes)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IJHNIFDN@?$FO1Error?3?$FO7?5MessageEnd?3?5?$CFs?5has?5o@
CONST	SEGMENT
??_C@_0DJ@IJHNIFDN@?$FO1Error?3?$FO7?5MessageEnd?3?5?$CFs?5has?5o@ DB '^1'
	DB	'Error:^7 MessageEnd: %s has overflow multicast buffer', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FLBHMFLG@MessageEnd?3?5called?5with?5no?5acti@
CONST	SEGMENT
??_C@_0CL@FLBHMFLG@MessageEnd?3?5called?5with?5no?5acti@ DB 'MessageEnd: '
	DB	'called with no active message', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DGIJNFM@MessageBegin?3?5tried?5to?5send?5unr@
CONST	SEGMENT
??_C@_0DF@DGIJNFM@MessageBegin?3?5tried?5to?5send?5unr@ DB 'MessageBegin:'
	DB	' tried to send unregistered message %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HCPBMJBO@MessageBegin?3?5New?5message?5start@
CONST	SEGMENT
??_C@_0EH@HCPBMJBO@MessageBegin?3?5New?5message?5start@ DB 'MessageBegin:'
	DB	' New message started when msg ''%s'' has not been sent yet', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JJDAPFDH@SV_LightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0BP@JJDAPFDH@SV_LightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5?$CFd@ DB 'S'
	DB	'V_LightStyle: style: %i >= %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EAGFDIFF@?$FO1Error?3?$FO7?5Tried?5to?5stuff?5bad?5c@
CONST	SEGMENT
??_C@_0CK@EAGFDIFF@?$FO1Error?3?$FO7?5Tried?5to?5stuff?5bad?5c@ DB '^1Err'
	DB	'or:^7 Tried to stuff bad command %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FJFCNMMM@?$FO1Error?3?$FO7?5stuffcmd?3?5client?5is?5@
CONST	SEGMENT
??_C@_0CN@FJFCNMMM@?$FO1Error?3?$FO7?5stuffcmd?3?5client?5is?5@ DB '^1Err'
	DB	'or:^7 stuffcmd: client is not spawned!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OAOLJEAF@server?5executing?5?$FO2config?4cfg?$FO7@
CONST	SEGMENT
??_C@_0CM@OAOLJEAF@server?5executing?5?$FO2config?4cfg?$FO7@ DB 'server e'
	DB	'xecuting ^2config.cfg^7 (%i cvars)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JIFJKOMC@exec?5config?4cfg?6@
CONST	SEGMENT
??_C@_0BB@JIFJKOMC@exec?5config?4cfg?6@ DB 'exec config.cfg', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@INNNGHJO@?$FO1Error?3?$FO7?5bad?5server?5command?5?$CF@
CONST	SEGMENT
??_C@_0CC@INNNGHJO@?$FO1Error?3?$FO7?5bad?5server?5command?5?$CF@ DB '^1E'
	DB	'rror:^7 bad server command %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMOECJNC@sv_aim@
CONST	SEGMENT
??_C@_06MMOECJNC@sv_aim@ DB 'sv_aim', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetAimVector@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetAimVector@@9@9 DD 0913H		; `pfnGetAimVector'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnTraceTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnTraceTexture@@9@9 DD 08f9H		; `pfnTraceTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnTraceModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnTraceModel@@9@9 DD 08c8H		; `pfnTraceModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnTraceMonsterHull@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnTraceMonsterHull@@9@9 DD 08b1H	; `pfnTraceMonsterHull'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnTraceToss@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnTraceToss@@9@9 DD 088fH		; `pfnTraceToss'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnTraceLine@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnTraceLine@@9@9 DD 087fH		; `pfnTraceLine'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@LLGKIMNB@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?$CFs?6@
CONST	SEGMENT
??_C@_0BM@LLGKIMNB@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?$CFs?6@ DB 'm'
	DB	'usic "%s" "%s" pos %i%s%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GIODLDCP@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@
CONST	SEGMENT
??_C@_0CE@GIODLDCP@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@ DB 'm'
	DB	'usic "%s" "%s" loop %d pos %i%s%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPJIJIBE@?5onloop@
CONST	SEGMENT
??_C@_07HPJIJIBE@?5onloop@ DB ' onloop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNJMHLFH@?5restored@
CONST	SEGMENT
??_C@_09MNJMHLFH@?5restored@ DB ' restored', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_StartSound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_StartSound@@9@9 DD 0830H		; `SV_StartSound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@HNKDPEFJ@?$FO1Error?3?$FO7?5SV_StartSound?3?5?$CFs?5no@
CONST	SEGMENT
??_C@_0DB@HNKDPEFJ@?$FO1Error?3?$FO7?5SV_StartSound?3?5?$CFs?5no@ DB '^1E'
	DB	'rror:^7 SV_StartSound: %s not precached (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PHKOJBD@?$FO1Error?3?$FO7?5SV_StartSound?3?5passe@
CONST	SEGMENT
??_C@_0CO@PHKOJBD@?$FO1Error?3?$FO7?5SV_StartSound?3?5passe@ DB '^1Error:'
	DB	'^7 SV_StartSound: passed NULL sample', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KAOAFKMC@?$FO1Error?3?$FO7?5SV_StartSound?3?5pitch@
CONST	SEGMENT
??_C@_0CG@KAOAFKMC@?$FO1Error?3?$FO7?5SV_StartSound?3?5pitch@ DB '^1Error'
	DB	':^7 SV_StartSound: pitch = %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DIDLBLOO@?$FO1Error?3?$FO7?5SV_StartSound?3?5chann@
CONST	SEGMENT
??_C@_0DI@DIDLBLOO@?$FO1Error?3?$FO7?5SV_StartSound?3?5chann@ DB '^1Error'
	DB	':^7 SV_StartSound: channel must be in range 0-7', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@DGGLGLAC@?$FO1Error?3?$FO7?5SV_StartSound?3?5atten@
CONST	SEGMENT
??_C@_0DP@DGGLGLAC@?$FO1Error?3?$FO7?5SV_StartSound?3?5atten@ DB '^1Error'
	DB	':^7 SV_StartSound: attenuation %g must be in range 0-4', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DPGAHNFB@?$FO1Error?3?$FO7?5SV_StartSound?3?5volum@
CONST	SEGMENT
??_C@_0CH@DPGAHNFB@?$FO1Error?3?$FO7?5SV_StartSound?3?5volum@ DB '^1Error'
	DB	':^7 SV_StartSound: volume = %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_BuildSoundMsg@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_BuildSoundMsg@@9@9 DD 07c5H		; `SV_BuildSoundMsg'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetOrigin@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetOrigin@@9@9 DD 07b6H		; `pfnSetOrigin'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnWalkMove@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnWalkMove@@9@9 DD 0797H		; `pfnWalkMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnDropToFloor@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnDropToFloor@@9@9 DD 0774H		; `pfnDropToFloor'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnEntIsOnFloor@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnEntIsOnFloor@@9@9 DD 0766H		; `pfnEntIsOnFloor'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnMakeStatic@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnMakeStatic@@9@9 DD 074cH		; `pfnMakeStatic'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@ODNHFHLH@?$FO1Error?3?$FO7?5can?8t?5delete?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@ODNHFHLH@?$FO1Error?3?$FO7?5can?8t?5delete?5?$CFs?6@ DB '^1Erro'
	DB	'r:^7 can''t delete %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DGDLPBAN@client@
CONST	SEGMENT
??_C@_06DGDLPBAN@client@ DB 'client', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MCBCHHEJ@world@
CONST	SEGMENT
??_C@_05MCBCHHEJ@world@ DB 'world', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnRemoveEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnRemoveEntity@@9@9 DD 072bH		; `pfnRemoveEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnEntitiesInPVS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnEntitiesInPVS@@9@9 DD 06f7H		; `pfnEntitiesInPVS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnFindClientInPVS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnFindClientInPVS@@9@9 DD 06bcH	; `pfnFindClientInPVS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_CheckClientPVS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_CheckClientPVS@@9@9 DD 067bH	; `SV_CheckClientPVS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnFindEntityInSphere@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnFindEntityInSphere@@9@9 DD 0649H	; `pfnFindEntityInSphere'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetEntityIllum@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetEntityIllum@@9@9 DD 063aH	; `pfnGetEntityIllum'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FindGlobalEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FindGlobalEntity@@9@9 DD 0625H	; `SV_FindGlobalEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@CMNBBMAL@?$FO1Error?3?$FO7?5FindEntityByString?3?5@
CONST	SEGMENT
??_C@_0DG@CMNBBMAL@?$FO1Error?3?$FO7?5FindEntityByString?3?5@ DB '^1Error'
	DB	':^7 FindEntityByString: field %s not a string', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FindEntityByString@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FindEntityByString@@9@9 DD 05ecH	; `SV_FindEntityByString'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnChangePitch@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnChangePitch@@9@9 DD 05deH		; `pfnChangePitch'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnChangeYaw@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnChangeYaw@@9@9 DD 05d0H		; `pfnChangeYaw'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnMoveToOrigin@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnMoveToOrigin@@9@9 DD 05c2H		; `pfnMoveToOrigin'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetSize@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetSize@@9@9 DD 056dH		; `pfnSetSize'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CJ@FCBGMNHP@?$FO1Error?3?$FO7?5world?5model?5can?8t?5be@
CONST	SEGMENT
??_C@_0CJ@FCBGMNHP@?$FO1Error?3?$FO7?5world?5model?5can?8t?5be@ DB '^1Err'
	DB	'or:^7 world model can''t be changed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@ DB '^1Erro'
	DB	'r:^7 no precache: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSetModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSetModel@@9@9 DD 0505H		; `pfnSetModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ClientFromEdict@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ClientFromEdict@@9@9 DD 04c7H	; `SV_ClientFromEdict'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05FAPHKBON@freed@
CONST	SEGMENT
??_C@_05FAPHKBON@freed@ DB 'freed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HONNHMII@?$FO1Error?3?$FO7?5No?5spawn?5function?5fo@
CONST	SEGMENT
??_C@_0CF@HONNHMII@?$FO1Error?3?$FO7?5No?5spawn?5function?5fo@ DB '^1Erro'
	DB	'r:^7 No spawn function for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKNFNOKI@custom@
CONST	SEGMENT
??_C@_06EKNFNOKI@custom@ DB 'custom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KBOCFNED@ED_AllocEdict?3?5no?5free?5edicts?5?$CI@
CONST	SEGMENT
??_C@_0CL@KBOCFNED@ED_AllocEdict?3?5no?5free?5edicts?5?$CI@ DB 'ED_AllocE'
	DB	'dict: no free edicts (max is %d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FreeEdict@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FreeEdict@@9@9 DD 03d9H		; `SV_FreeEdict'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@ DB 'pEdict != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_InitEdict@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_InitEdict@@9@9 DD 03c4H		; `SV_InitEdict'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FreePrivateData@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FreePrivateData@@9@9 DD 03aeH	; `SV_FreePrivateData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_MapIsValid@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_MapIsValid@@9@9 DD 0368H		; `SV_MapIsValid'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ReadEntityScript@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ReadEntityScript@@9@9 DD 0326H	; `SV_ReadEntityScript'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@KEIEKBBM@Write?5?8maps?1?$CFs?4ent?8?6@
CONST	SEGMENT
??_C@_0BF@KEIEKBBM@Write?5?8maps?1?$CFs?4ent?8?6@ DB 'Write ''maps/%s.ent'
	DB	'''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHJMLCCE@maps?1?$CFs?4ent@
CONST	SEGMENT
??_C@_0M@NHJMLCCE@maps?1?$CFs?4ent@ DB 'maps/%s.ent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@
CONST	SEGMENT
??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@ DB 'maps/%s.bsp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_WriteEntityPatch@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_WriteEntityPatch@@9@9 DD 02f6H	; `SV_WriteEntityPatch'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GC@ICGACPNE@?$FO3Warning?3?$FO7?5an?5infinite?5change@
CONST	SEGMENT
??_C@_0GC@ICGACPNE@?$FO3Warning?3?$FO7?5an?5infinite?5change@ DB '^3Warni'
	DB	'ng:^7 an infinite changelevel was detected and will be disabl'
	DB	'ed until a next save\restore', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OMEDMDNK@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5does@
CONST	SEGMENT
??_C@_0EG@OMEDMDNK@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5does@ DB '^1E'
	DB	'rror:^7 changelevel: %s doesn''t have a valid spawnpoint. Ign'
	DB	'ored.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GJJHOCIH@?$FO1Error?3?$FO7?5can?8t?5changelevel?5wi@
CONST	SEGMENT
??_C@_0DG@GJJHOCIH@?$FO1Error?3?$FO7?5can?8t?5changelevel?5wi@ DB '^1Erro'
	DB	'r:^7 can''t changelevel with same map. Ignored.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@HPNEIPFC@?$FO3Warning?3?$FO7?5changelevel?3?5?$CFs?5do@
CONST	SEGMENT
??_C@_0FM@HPNEIPFC@?$FO3Warning?3?$FO7?5changelevel?3?5?$CFs?5do@ DB '^3W'
	DB	'arning:^7 changelevel: %s doesn''t contain landmark [%s]. smo'
	DB	'oth transition was disabled', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FDLMDCIC@?$FO1Error?3?$FO7?5changelevel?3?5map?5?$CFs?5@
CONST	SEGMENT
??_C@_0CO@FDLMDCIC@?$FO1Error?3?$FO7?5changelevel?3?5map?5?$CFs?5@ DB '^1'
	DB	'Error:^7 changelevel: map %s doesn''t exist', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GMIJDHAN@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5is?5i@
CONST	SEGMENT
??_C@_0DI@GMIJDHAN@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5is?5i@ DB '^1'
	DB	'Error:^7 changelevel: %s is invalid or not supported', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_RestartDecals@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_RestartDecals@@9@9 DD 0262H		; `SV_RestartDecals'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@MLBIDEPC@Music?5has?5been?5restored?$CB?6@
CONST	SEGMENT
??_C@_0BK@MLBIDEPC@Music?5has?5been?5restored?$CB?6@ DB 'Music has been r'
	DB	'estored!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DMOKJIDJ@?$FO3Warning?3?$FO7?5MAX_STATIC_ENTITIE@
CONST	SEGMENT
??_C@_0DG@DMOKJIDJ@?$FO3Warning?3?$FO7?5MAX_STATIC_ENTITIE@ DB '^3Warning'
	DB	':^7 MAX_STATIC_ENTITIES limit exceeded (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLEHBJII@SV_Multicast?3?5bad?5dest?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BM@GLEHBJII@SV_Multicast?3?5bad?5dest?3?5?$CFi?6@ DB 'SV_Multicast'
	DB	': bad dest: %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Multicast@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Multicast@@9@9 DD 0145H		; `SV_Multicast'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_CheckClientVisiblity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_CheckClientVisiblity@@9@9 DD 0110H	; `SV_CheckClientVisiblity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_CopyTraceToGlobal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_CopyTraceToGlobal@@9@9 DD 0ddH	; `SV_CopyTraceToGlobal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CL@DCCJHOGJ@?$FO1Error?3?$FO7?5?$CFs?$FL?$CFi?$FN?5has?5backwards@
CONST	SEGMENT
??_C@_0CL@DCCJHOGJ@?$FO1Error?3?$FO7?5?$CFs?$FL?$CFi?$FN?5has?5backwards@ DB '^'
	DB	'1Error:^7 %s[%i] has backwards mins/maxs', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_game.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_SetMinMaxSize@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_SetMinMaxSize@@9@9 DD 0bfH		; `SV_SetMinMaxSize'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@CNPMFKGE@FATAL?5ERROR?5?$CIshutting?5down?$CJ?3?5?$CFs@
CONST	SEGMENT
??_C@_0CB@CNPMFKGE@FATAL?5ERROR?5?$CIshutting?5down?$CJ?3?5?$CFs@ DB 'FAT'
	DB	'AL ERROR (shutting down): %s', 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_gEntvarsDescription DD 01H
	DD	FLAT:??_C@_09CNJINBGN@classname@
	DD	00H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_0L@JILCNGEO@globalname@
	DD	04H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:??_C@_05NCCFOPHA@model@
	DD	0b8H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:??_C@_09DKDOKEPP@viewmodel@
	DD	0bcH
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:??_C@_0M@HFKHPDIJ@weaponmodel@
	DD	0c4H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:??_C@_08MKOCHEFC@armmodel@
	DD	0c0H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_06JJLAMBGK@target@
	DD	0228H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_0L@FEPNPAJD@targetname@
	DD	022cH
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_07OLJMCAFB@netname@
	DD	0230H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_07ONPBMBOP@message@
	DD	0234H
	DW	01H
	DW	00H
	DD	012H
	DD	FLAT:??_C@_05GPLCCBII@noise@
	DD	0248H
	DW	01H
	DW	00H
	DD	012H
	DD	FLAT:??_C@_06CFFBLOIB@noise1@
	DD	024cH
	DW	01H
	DW	00H
	DD	012H
	DD	FLAT:??_C@_06OHMONEC@noise2@
	DD	0250H
	DW	01H
	DW	00H
	DD	012H
	DD	FLAT:??_C@_06BHGHNMAD@noise3@
	DD	0254H
	DW	01H
	DW	00H
_gEngfuncs DD	FLAT:_pfnPrecacheModel
	DD	FLAT:_SV_SoundIndex
	DD	FLAT:_pfnSetModel
	DD	FLAT:_pfnModelIndex
	DD	FLAT:_pfnModelFrames
	DD	FLAT:_pfnSetSize
	DD	FLAT:_pfnChangeLevel
	DD	FLAT:_pfnGetSpawnParms
	DD	FLAT:_pfnSaveSpawnParms
	DD	FLAT:_pfnVecToYaw
	DD	FLAT:_VectorAngles
	DD	FLAT:_pfnMoveToOrigin
	DD	FLAT:_pfnChangeYaw
	DD	FLAT:_pfnChangePitch
	DD	FLAT:_SV_FindEntityByString
	DD	FLAT:_pfnGetEntityIllum
	DD	FLAT:_pfnFindEntityInSphere
	DD	FLAT:_pfnFindClientInPVS
	DD	FLAT:_pfnEntitiesInPVS
	DD	FLAT:_pfnMakeVectors
	DD	FLAT:_AngleVectors
	DD	FLAT:_SV_AllocEdict
	DD	FLAT:_pfnRemoveEntity
	DD	FLAT:_pfnCreateNamedEntity
	DD	FLAT:_pfnMakeStatic
	DD	FLAT:_pfnEntIsOnFloor
	DD	FLAT:_pfnDropToFloor
	DD	FLAT:_pfnWalkMove
	DD	FLAT:_pfnSetOrigin
	DD	FLAT:_SV_StartSound
	DD	FLAT:_pfnEmitAmbientSound
	DD	FLAT:_pfnTraceLine
	DD	FLAT:_pfnTraceToss
	DD	FLAT:_pfnTraceMonsterHull
	DD	FLAT:_pfnTraceHull
	DD	FLAT:_pfnTraceModel
	DD	FLAT:_pfnTraceTexture
	DD	FLAT:_pfnTraceSphere
	DD	FLAT:_pfnGetAimVector
	DD	FLAT:_pfnServerCommand
	DD	FLAT:_pfnServerExecute
	DD	FLAT:_pfnClientCommand
	DD	FLAT:_pfnParticleEffect
	DD	FLAT:_pfnLightStyle
	DD	FLAT:_pfnDecalIndex
	DD	FLAT:_SV_PointContents
	DD	FLAT:_pfnMessageBegin
	DD	FLAT:_pfnMessageEnd
	DD	FLAT:_pfnWriteByte
	DD	FLAT:_pfnWriteChar
	DD	FLAT:_pfnWriteShort
	DD	FLAT:_pfnWriteLong
	DD	FLAT:_pfnWriteFlag
	DD	FLAT:_pfnWriteFloat
	DD	FLAT:_pfnWriteAngle
	DD	FLAT:_pfnWriteCoord
	DD	FLAT:_pfnWriteString
	DD	FLAT:_pfnWriteEntity
	DD	FLAT:_pfnCvar_RegisterServerVariable
	DD	FLAT:_Cvar_VariableValue
	DD	FLAT:_Cvar_VariableString
	DD	FLAT:_Cvar_SetValue
	DD	FLAT:_Cvar_Set
	DD	FLAT:_pfnAlertMessage
	DD	FLAT:_pfnEngineFprintf
	DD	FLAT:_pfnPvAllocEntPrivateData
	DD	FLAT:_pfnPvEntPrivateData
	DD	FLAT:_SV_FreePrivateData
	DD	FLAT:_SV_GetString
	DD	FLAT:_SV_AllocString
	DD	FLAT:_pfnGetVarsOfEnt
	DD	FLAT:_pfnPEntityOfEntOffset
	DD	FLAT:_pfnEntOffsetOfPEntity
	DD	FLAT:_pfnIndexOfEdict
	DD	FLAT:_pfnPEntityOfEntIndex
	DD	FLAT:_pfnFindEntityByVars
	DD	FLAT:_pfnGetModelPtr
	DD	FLAT:_pfnRegUserMsg
	DD	FLAT:_pfnAnimationAutomove
	DD	FLAT:_pfnGetBonePosition
	DD	FLAT:_pfnFunctionFromName
	DD	FLAT:_pfnNameForFunction
	DD	FLAT:_pfnClientPrintf
	DD	FLAT:_pfnServerPrint
	DD	FLAT:_Cmd_Args
	DD	FLAT:_Cmd_Argv
	DD	FLAT:_Cmd_Argc
	DD	FLAT:_pfnGetAttachment
	DD	FLAT:_CRC32_Init
	DD	FLAT:_CRC32_ProcessBuffer
	DD	FLAT:_CRC32_ProcessByte
	DD	FLAT:_CRC32_Final
	DD	FLAT:_COM_RandomLong
	DD	FLAT:_COM_RandomFloat
	DD	FLAT:_pfnSetView
	DD	FLAT:_pfnTime
	DD	FLAT:_pfnCrosshairAngle
	DD	FLAT:_COM_LoadFileForMe
	DD	FLAT:_COM_FreeFile
	DD	FLAT:_pfnEndSection
	DD	FLAT:_COM_CompareFileTime
	DD	FLAT:_pfnGetGameDir
	DD	FLAT:_pfnCvar_RegisterEngineVariable
	DD	FLAT:_pfnFadeClientVolume
	DD	FLAT:_pfnSetClientMaxspeed
	DD	FLAT:_SV_FakeConnect
	DD	FLAT:_pfnRunPlayerMove
	DD	FLAT:_pfnNumberOfEntities
	DD	FLAT:_pfnGetInfoKeyBuffer
	DD	FLAT:_Info_ValueForKey
	DD	FLAT:_pfnSetValueForKey
	DD	FLAT:_pfnSetClientKeyValue
	DD	FLAT:_pfnIsMapValid
	DD	FLAT:_pfnStaticDecal
	DD	FLAT:_SV_GenericIndex
	DD	FLAT:_pfnGetPlayerUserId
	DD	FLAT:_pfnBuildSoundMsg
	DD	FLAT:_pfnIsDedicatedServer
	DD	FLAT:_pfnCVarGetPointer
	DD	FLAT:_pfnGetPlayerWONId
	DD	FLAT:_Info_RemoveKey
	DD	FLAT:_pfnGetPhysicsKeyValue
	DD	FLAT:_pfnSetPhysicsKeyValue
	DD	FLAT:_pfnGetPhysicsInfoString
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_SV_PlaybackEventFull
	DD	FLAT:_pfnSetFatPVS
	DD	FLAT:_pfnSetFatPAS
	DD	FLAT:_pfnCheckVisibility
	DD	FLAT:_Delta_SetField
	DD	FLAT:_Delta_UnsetField
	DD	FLAT:_Delta_AddEncoder
	DD	FLAT:_pfnGetCurrentPlayer
	DD	FLAT:_pfnCanSkipPlayer
	DD	FLAT:_Delta_FindField
	DD	FLAT:_Delta_SetFieldByIndex
	DD	FLAT:_Delta_UnsetFieldByIndex
	DD	FLAT:_pfnSetGroupMask
	DD	FLAT:_pfnCreateInstancedBaseline
	DD	FLAT:_pfnCVarDirectSet
	DD	FLAT:_pfnForceUnmodified
	DD	FLAT:_pfnGetPlayerStats
	DD	FLAT:_Cmd_AddServerCommand
	DD	FLAT:_pfnVoice_GetClientListening
	DD	FLAT:_pfnVoice_SetClientListening
	DD	FLAT:_pfnGetPlayerAuthId
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnQueryClientCvarValue
	DD	FLAT:_pfnQueryClientCvarValue2
	DD	FLAT:_COM_CheckParm
_DATA	ENDS
;	COMDAT ??_C@_0CB@EKNEPLEL@bad?5entity?5?$CFi?5?$CIcalled?5at?5?$CFs?3?$CFi?$CJ@
CONST	SEGMENT
??_C@_0CB@EKNEPLEL@bad?5entity?5?$CFi?5?$CIcalled?5at?5?$CFs?3?$CFi?$CJ@ DB 'b'
	DB	'ad entity %i (called at %s:%i)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	021aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0969H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0163H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	015dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	075fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0168H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	08dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	06cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	086H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	013dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03b3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	033eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0dbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01d7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0294H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	035fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	018aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0deH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02dcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	034bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	015cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0b0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0a4fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0282H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_LoadFromFile
_TEXT	SEGMENT
tv70 = -2388						; size = 4
_ent$ = -2064						; size = 4
_inhibited$ = -2060					; size = 4
_create_world$ = -2056					; size = 4
_token$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_mapname$ = 8						; size = 4
_entities$ = 12						; size = 4
_SV_LoadFromFile PROC					; COMDAT

; 4687 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2388				; 00000954H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 4688 : 	char	token[2048];
; 4689 : 	qboolean	create_world = true;

	mov	DWORD PTR _create_world$[ebp], 1

; 4690 : 	int	inhibited;
; 4691 : 	edict_t	*ent;
; 4692 : 
; 4693 : 	Assert( entities != NULL );

	cmp	DWORD PTR _entities$[ebp], 0
	je	SHORT $LN13@SV_LoadFro
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN14@SV_LoadFro
$LN13@SV_LoadFro:
	mov	DWORD PTR tv70[ebp], 0
$LN14@SV_LoadFro:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadFromFile@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BB@LCBBAJPK@entities?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4694 : 
; 4695 : 	// user dll can override spawn entities function (Xash3D extension)
; 4696 : 	if( !svgame.physFuncs.SV_LoadEntities || !svgame.physFuncs.SV_LoadEntities( mapname, entities ))

	cmp	DWORD PTR _svgame+19504, 0
	je	SHORT $LN5@SV_LoadFro
	mov	eax, DWORD PTR _entities$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19504
	add	esp, 8
	test	eax, eax
	jne	$LN4@SV_LoadFro
$LN5@SV_LoadFro:

; 4697 : 	{
; 4698 : 		inhibited = 0;

	mov	DWORD PTR _inhibited$[ebp], 0
$LN15@SV_LoadFro:

; 4699 : 
; 4700 : 		// parse ents
; 4701 : 		while(( entities = COM_ParseFile( entities, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _entities$[ebp], eax
	cmp	DWORD PTR _entities$[ebp], 0
	je	$LN3@SV_LoadFro

; 4702 : 		{
; 4703 : 			if( token[0] != '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN6@SV_LoadFro

; 4704 : 				Host_Error( "ED_LoadFromFile: found %s when expecting {\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@IJEJEKHJ@ED_LoadFromFile?3?5found?5?$CFs?5when?5@
	call	_Host_Error
	add	esp, 8
$LN6@SV_LoadFro:

; 4705 : 
; 4706 : 			if( create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN7@SV_LoadFro

; 4707 : 			{
; 4708 : 				create_world = false;

	mov	DWORD PTR _create_world$[ebp], 0

; 4709 : 				ent = EDICT_NUM( 0 ); // already initialized

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 4710 : 			}

	jmp	SHORT $LN8@SV_LoadFro
$LN7@SV_LoadFro:

; 4711 : 			else ent = SV_AllocEdict();

	call	_SV_AllocEdict
	mov	DWORD PTR _ent$[ebp], eax
$LN8@SV_LoadFro:

; 4712 : 
; 4713 : 			if( !SV_ParseEdict( &entities, ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	_SV_ParseEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_LoadFro

; 4714 : 				continue;

	jmp	$LN15@SV_LoadFro
$LN9@SV_LoadFro:

; 4715 : 
; 4716 : 			if( svgame.dllFuncs.pfnSpawn( ent ) == -1 )

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19276
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN11@SV_LoadFro

; 4717 : 			{
; 4718 : 				// game rejected the spawn
; 4719 : 				if( !FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	jne	SHORT $LN11@SV_LoadFro

; 4720 : 				{
; 4721 : 					SV_FreeEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4

; 4722 : 					inhibited++;

	mov	eax, DWORD PTR _inhibited$[ebp]
	add	eax, 1
	mov	DWORD PTR _inhibited$[ebp], eax
$LN11@SV_LoadFro:

; 4723 : 				}
; 4724 : 			}
; 4725 : 		}

	jmp	$LN15@SV_LoadFro
$LN3@SV_LoadFro:

; 4726 : 
; 4727 : 		Con_DPrintf( "\n%i entities inhibited\n", inhibited );

	mov	eax, DWORD PTR _inhibited$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@PMNHCCDI@?6?$CFi?5entities?5inhibited?6@
	call	_Con_DPrintf
	add	esp, 8
$LN4@SV_LoadFro:

; 4728 : 	}
; 4729 : 
; 4730 : 	// reset world origin and angles for some reason
; 4731 : 	VectorClear( svgame.edicts->v.origin );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0

; 4732 : 	VectorClear( svgame.edicts->v.angles );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0

; 4733 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadFromFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_ParseEdict
_TEXT	SEGMENT
_pstart$1 = -6440					; size = 4
_flYawAngle$2 = -6436					; size = 4
_keyname$3 = -6432					; size = 256
_origin$ = -6176					; size = 12
_token$ = -6164						; size = 2048
_classname$ = -4116					; size = 4
_numpairs$ = -4112					; size = 4
_i$ = -4108						; size = 4
_adjust_origin$ = -4104					; size = 4
_pkvd$ = -4100						; size = 4096
__$ArrayPad$ = -4					; size = 4
_pfile$ = 8						; size = 4
_ent$ = 12						; size = 4
_SV_ParseEdict PROC					; COMDAT

; 4529 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 6952				; 00001b28H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 4530 : 	KeyValueData	pkvd[256]; // per one entity
; 4531 : 	qboolean		adjust_origin = false;

	mov	DWORD PTR _adjust_origin$[ebp], 0

; 4532 : 	int		i, numpairs = 0;

	mov	DWORD PTR _numpairs$[ebp], 0

; 4533 : 	char		*classname = NULL;

	mov	DWORD PTR _classname$[ebp], 0
$LN43@SV_ParseEd:

; 4534 : 	char		token[2048];
; 4535 : 	vec3_t		origin;
; 4536 : 
; 4537 : 	// go through all the dictionary pairs
; 4538 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@SV_ParseEd

; 4539 : 	{	
; 4540 : 		string	keyname;
; 4541 : 
; 4542 : 		// parse key
; 4543 : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@SV_ParseEd

; 4544 : 			Host_Error( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET ??_C@_0CK@PBLIDAI@ED_ParseEdict?3?5EOF?5without?5clos@
	call	_Host_Error
	add	esp, 4
$LN10@SV_ParseEd:

; 4545 : 		if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN11@SV_ParseEd
	jmp	$LN3@SV_ParseEd
$LN11@SV_ParseEd:

; 4546 : 
; 4547 : 		Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$3[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 4548 : 
; 4549 : 		// parse value	
; 4550 : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL ) 

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN12@SV_ParseEd

; 4551 : 			Host_Error( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET ??_C@_0CK@PBLIDAI@ED_ParseEdict?3?5EOF?5without?5clos@
	call	_Host_Error
	add	esp, 4
$LN12@SV_ParseEd:

; 4552 : 
; 4553 : 		if( token[0] == '}' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN13@SV_ParseEd

; 4554 : 			Host_Error( "ED_ParseEdict: closing brace without data\n" );

	push	OFFSET ??_C@_0CL@OPGPBFON@ED_ParseEdict?3?5closing?5brace?5wi@
	call	_Host_Error
	add	esp, 4
$LN13@SV_ParseEd:

; 4555 : 
; 4556 : 		// ignore attempts to set key ""
; 4557 : 		if( !keyname[0] ) continue;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _keyname$3[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN14@SV_ParseEd
	jmp	$LN43@SV_ParseEd
$LN14@SV_ParseEd:

; 4558 : 
; 4559 : 		// "wad" field is already handled
; 4560 : 		if( !Q_strcmp( keyname, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03GANHLHHC@wad@
	lea	eax, DWORD PTR _keyname$3[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@SV_ParseEd

; 4561 : 			continue;

	jmp	$LN43@SV_ParseEd
$LN15@SV_ParseEd:

; 4562 : 
; 4563 : 		// keynames with a leading underscore are used for
; 4564 : 		// utility comments and are immediately discarded by engine
; 4565 : 		if( keyname[0] == '_' && Q_strcmp( keyname, "_light" ))

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _keyname$3[ebp+ecx]
	cmp	edx, 95					; 0000005fH
	jne	SHORT $LN16@SV_ParseEd
	push	99999					; 0001869fH
	push	OFFSET ??_C@_06PHHMIKBC@_light@
	lea	eax, DWORD PTR _keyname$3[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@SV_ParseEd

; 4566 : 			continue;

	jmp	$LN43@SV_ParseEd
$LN16@SV_ParseEd:

; 4567 : 
; 4568 : 		// ignore attempts to set value ""
; 4569 : 		if( !token[0] ) continue;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN17@SV_ParseEd
	jmp	$LN43@SV_ParseEd
$LN17@SV_ParseEd:

; 4570 : 
; 4571 : 		// create keyvalue strings
; 4572 : 		pkvd[numpairs].szClassName = ""; // unknown at this moment

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax], OFFSET ??_C@_00CNPNBAHC@@

; 4573 : 		pkvd[numpairs].szKeyName = copystring( keyname );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	lea	ecx, DWORD PTR _keyname$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], eax

; 4574 : 		pkvd[numpairs].szValue = copystring( token );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax

; 4575 : 		pkvd[numpairs].fHandled = false;		

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax+12], 0

; 4576 : 
; 4577 : 		if( !Q_strcmp( keyname, "classname" ) && classname == NULL )

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09CNJINBGN@classname@
	lea	eax, DWORD PTR _keyname$3[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@SV_ParseEd
	cmp	DWORD PTR _classname$[ebp], 0
	jne	SHORT $LN18@SV_ParseEd

; 4578 : 			classname = copystring( pkvd[numpairs].szValue );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 49					; 00000031H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	DWORD PTR _classname$[ebp], eax
$LN18@SV_ParseEd:

; 4579 : 		if( ++numpairs >= 256 ) break;

	mov	eax, DWORD PTR _numpairs$[ebp]
	add	eax, 1
	mov	DWORD PTR _numpairs$[ebp], eax
	cmp	DWORD PTR _numpairs$[ebp], 256		; 00000100H
	jl	SHORT $LN19@SV_ParseEd
	jmp	SHORT $LN3@SV_ParseEd
$LN19@SV_ParseEd:

; 4580 : 	}

	jmp	$LN43@SV_ParseEd
$LN3@SV_ParseEd:

; 4581 : 	
; 4582 : 	ent = SV_AllocPrivateData( ent, ALLOC_STRING( classname ));

	mov	eax, DWORD PTR _classname$[ebp]
	push	eax
	call	_SV_AllocString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_AllocPrivateData
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 4583 : 
; 4584 : 	if( !SV_IsValidEdict( ent ) || FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 55					; 00000037H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_ParseEd
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	je	$LN20@SV_ParseEd
$LN21@SV_ParseEd:

; 4585 : 	{
; 4586 : 		// release allocated strings
; 4587 : 		for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SV_ParseEd
$LN4@SV_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@SV_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numpairs$[ebp]
	jge	SHORT $LN5@SV_ParseEd

; 4588 : 		{
; 4589 : 			Mem_Free( pkvd[i].szKeyName );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4590 : 			Mem_Free( pkvd[i].szValue );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 61					; 0000003dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4591 : 		}

	jmp	SHORT $LN4@SV_ParseEd
$LN5@SV_ParseEd:

; 4592 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_ParseEd
$LN20@SV_ParseEd:

; 4593 : 	}
; 4594 : 
; 4595 : 	if( FBitSet( ent->v.flags, FL_CUSTOMENTITY ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 536870912				; 20000000H
	je	$LN22@SV_ParseEd

; 4596 : 	{
; 4597 : 		if( numpairs < 256 )

	cmp	DWORD PTR _numpairs$[ebp], 256		; 00000100H
	jge	SHORT $LN23@SV_ParseEd

; 4598 : 		{
; 4599 : 			pkvd[numpairs].szClassName = "custom";

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax], OFFSET ??_C@_06EKNFNOKI@custom@

; 4600 : 			pkvd[numpairs].szKeyName = "customclass";

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax+4], OFFSET ??_C@_0M@EJFMBEL@customclass@

; 4601 : 			pkvd[numpairs].szValue = classname;

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+eax+8], ecx

; 4602 : 			pkvd[numpairs].fHandled = false;

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax+12], 0

; 4603 : 			numpairs++;

	mov	eax, DWORD PTR _numpairs$[ebp]
	add	eax, 1
	mov	DWORD PTR _numpairs$[ebp], eax
$LN23@SV_ParseEd:

; 4604 : 		}
; 4605 : 
; 4606 : 		// clear it now - no longer used
; 4607 : 		ClearBits( ent->v.flags, FL_CUSTOMENTITY );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -536870913				; dfffffffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN22@SV_ParseEd:

; 4608 : 	}
; 4609 : 
; 4610 : #ifdef HACKS_RELATED_HLMODS
; 4611 : 	// chemical existence have broked changelevels
; 4612 : 	if( !Q_stricmp( GI->gamedir, "ce" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_02FCKFMMHG@ce@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd

; 4613 : 	{
; 4614 : 	 	if( !Q_stricmp( sv.name, "ce08_02" ) && !Q_stricmp( classname, "info_player_start_force" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07NCGJLOHD@ce08_02@
	push	OFFSET _sv+56
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd
	push	99999					; 0001869fH
	push	OFFSET ??_C@_0BI@PMCHBKMF@info_player_start_force@
	mov	eax, DWORD PTR _classname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd

; 4615 : 			adjust_origin = true;

	mov	DWORD PTR _adjust_origin$[ebp], 1
$LN25@SV_ParseEd:

; 4616 : 	}
; 4617 : #endif
; 4618 : 
; 4619 : 	for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@SV_ParseEd
$LN7@SV_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@SV_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numpairs$[ebp]
	jge	$LN8@SV_ParseEd

; 4620 : 	{
; 4621 : 		if( !Q_strcmp( pkvd[i].szKeyName, "angle" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05FECBCJJD@angle@
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN32@SV_ParseEd

; 4622 : 		{
; 4623 : 			float	flYawAngle = Q_atof( pkvd[i].szValue );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	push	ecx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _flYawAngle$2[ebp]

; 4624 : 
; 4625 : 			Mem_Free( pkvd[i].szKeyName ); // will be replace with 'angles'

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 96					; 00000060H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4626 : 			Mem_Free( pkvd[i].szValue );	// release old value, so we don't need these

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 97					; 00000061H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4627 : 			pkvd[i].szKeyName = copystring( "angles" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 98					; 00000062H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_06GNEAMJOC@angles@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+4], eax

; 4628 : 
; 4629 : 			if( flYawAngle >= 0.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN27@SV_ParseEd

; 4630 : 				pkvd[i].szValue = copystring( va( "%g %g %g", ent->v.angles[0], flYawAngle, ent->v.angles[2] ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 101				; 00000065H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+208]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _flYawAngle$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+208]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg@
	call	_va
	add	esp, 28					; 0000001cH
	push	eax
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
	jmp	$LN32@SV_ParseEd
$LN27@SV_ParseEd:

; 4631 : 			else if( flYawAngle == -1.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@SV_ParseEd

; 4632 : 				pkvd[i].szValue = copystring( "-90 0 0" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 103				; 00000067H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_07BHMOBHIL@?990?50?50@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
	jmp	SHORT $LN32@SV_ParseEd
$LN29@SV_ParseEd:

; 4633 : 			else if( flYawAngle == -2.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@c0000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@SV_ParseEd

; 4634 : 				pkvd[i].szValue = copystring( "90 0 0" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 105				; 00000069H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_06INPDGABL@90?50?50@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
	jmp	SHORT $LN32@SV_ParseEd
$LN31@SV_ParseEd:

; 4635 : 			else pkvd[i].szValue = copystring( "0 0 0" ); // technically an error

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 106				; 0000006aH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_05JMKGPOEH@0?50?50@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
$LN32@SV_ParseEd:

; 4636 : 		}
; 4637 : 
; 4638 : #ifdef HACKS_RELATED_HLMODS
; 4639 : 		if( adjust_origin && !Q_strcmp( pkvd[i].szKeyName, "origin" ))

	cmp	DWORD PTR _adjust_origin$[ebp], 0
	je	$LN33@SV_ParseEd
	push	99999					; 0001869fH
	push	OFFSET ??_C@_06NHCMNMEH@origin@
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN33@SV_ParseEd

; 4640 : 		{
; 4641 : 			char	*pstart = pkvd[i].szValue;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	mov	DWORD PTR _pstart$1[ebp], ecx

; 4642 : 
; 4643 : 			COM_ParseVector( &pstart, origin, 3 );

	push	3
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pstart$1[ebp]
	push	ecx
	call	_COM_ParseVector
	add	esp, 12					; 0000000cH

; 4644 : 			Mem_Free( pkvd[i].szValue );	// release old value, so we don't need these

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 115				; 00000073H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4645 : 			pkvd[i].szValue = copystring( va( "%g %g %g", origin[0], origin[1], origin[2] - 16.0f ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 116				; 00000074H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _origin$[ebp+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _origin$[ebp+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg@
	call	_va
	add	esp, 28					; 0000001cH
	push	eax
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
$LN33@SV_ParseEd:

; 4646 : 		}
; 4647 : #endif
; 4648 : 		if( !Q_strcmp( pkvd[i].szKeyName, "light" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05OEPGNJB@light@
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@SV_ParseEd

; 4649 : 		{
; 4650 : 			Mem_Free( pkvd[i].szKeyName );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 121				; 00000079H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4651 : 			pkvd[i].szKeyName = copystring( "light_level" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 122				; 0000007aH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@EMAIGPBJ@light_level@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+4], eax
$LN34@SV_ParseEd:

; 4652 : 		}
; 4653 : 
; 4654 : 		if( !pkvd[i].fHandled )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _pkvd$[ebp+eax+12], 0
	jne	SHORT $LN35@SV_ParseEd

; 4655 : 		{
; 4656 : 			pkvd[i].szClassName = classname;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+eax], ecx

; 4657 : 			svgame.dllFuncs.pfnKeyValue( ent, &pkvd[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _pkvd$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19296
	add	esp, 8
$LN35@SV_ParseEd:

; 4658 : 		}
; 4659 : 
; 4660 : 		// no reason to keep this data
; 4661 : 		if( Mem_IsAllocatedExt( host.mempool, pkvd[i].szKeyName ))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@SV_ParseEd

; 4662 : 			Mem_Free( pkvd[i].szKeyName );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 133				; 00000085H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN36@SV_ParseEd:

; 4663 : 
; 4664 : 		if( Mem_IsAllocatedExt( host.mempool, pkvd[i].szValue ))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@SV_ParseEd

; 4665 : 			Mem_Free( pkvd[i].szValue );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 136				; 00000088H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN37@SV_ParseEd:

; 4666 : 	}

	jmp	$LN7@SV_ParseEd
$LN8@SV_ParseEd:

; 4667 : 
; 4668 : 	if( classname )

	cmp	DWORD PTR _classname$[ebp], 0
	je	SHORT $LN38@SV_ParseEd

; 4669 : 		Mem_Free( classname );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseEdict@@9@9
	add	eax, 140				; 0000008cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _classname$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN38@SV_ParseEd:

; 4670 : 
; 4671 : 	return true;

	mov	eax, 1
$LN1@SV_ParseEd:

; 4672 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEngineStub
_TEXT	SEGMENT
_pfnEngineStub PROC					; COMDAT

; 4352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4353 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEngineStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnQueryClientCvarValue2
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_cvarName$ = 12						; size = 4
_requestID$ = 16					; size = 4
_pfnQueryClientCvarValue2 PROC				; COMDAT

; 4324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4325 : 	sv_client_t *cl;
; 4326 : 
; 4327 : 	if( !COM_CheckString( cvarName ))

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnQueryCl

; 4328 : 		return;

	jmp	$LN1@pfnQueryCl
$LN2@pfnQueryCl:

; 4329 : 
; 4330 : 	if(( cl = SV_ClientFromEdict( player, true )) != NULL )

	push	1
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN3@pfnQueryCl

; 4331 : 	{
; 4332 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_querycvarvalue2 );

	push	0
	push	1
	push	58					; 0000003aH
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 4333 : 		MSG_WriteLong( &cl->netchan.message, requestID );

	mov	eax, DWORD PTR _requestID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 4334 : 		MSG_WriteString( &cl->netchan.message, cvarName );

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 4335 : 	}

	jmp	SHORT $LN1@pfnQueryCl
$LN3@pfnQueryCl:

; 4336 : 	else
; 4337 : 	{
; 4338 : 		if( svgame.dllFuncs2.pfnCvarValue2 )

	cmp	DWORD PTR _svgame+19488, 0
	je	SHORT $LN5@pfnQueryCl

; 4339 : 			svgame.dllFuncs2.pfnCvarValue2( player, requestID, cvarName, "Bad Player" );

	push	OFFSET ??_C@_0L@GBBDLGEP@Bad?5Player@
	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _requestID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	call	DWORD PTR _svgame+19488
	add	esp, 16					; 00000010H
$LN5@pfnQueryCl:

; 4340 : 		Con_Printf( S_ERROR "QueryClientCvarValue: tried to send to a non-client!\n" );

	push	OFFSET ??_C@_0EB@NIKEOBLP@?$FO1Error?3?$FO7?5QueryClientCvarValue@
	call	_Con_Printf
	add	esp, 4
$LN1@pfnQueryCl:

; 4341 : 	}
; 4342 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnQueryClientCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnQueryClientCvarValue
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_cvarName$ = 12						; size = 4
_pfnQueryClientCvarValue PROC				; COMDAT

; 4297 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4298 : 	sv_client_t *cl;
; 4299 : 
; 4300 : 	if( !COM_CheckString( cvarName ))

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnQueryCl

; 4301 : 		return;

	jmp	SHORT $LN1@pfnQueryCl
$LN2@pfnQueryCl:

; 4302 : 
; 4303 : 	if(( cl = SV_ClientFromEdict( player, true )) != NULL )

	push	1
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN3@pfnQueryCl

; 4304 : 	{
; 4305 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_querycvarvalue );

	push	0
	push	1
	push	57					; 00000039H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 4306 : 		MSG_WriteString( &cl->netchan.message, cvarName );

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 4307 : 	}

	jmp	SHORT $LN1@pfnQueryCl
$LN3@pfnQueryCl:

; 4308 : 	else
; 4309 : 	{
; 4310 : 		if( svgame.dllFuncs2.pfnCvarValue )

	cmp	DWORD PTR _svgame+19484, 0
	je	SHORT $LN5@pfnQueryCl

; 4311 : 			svgame.dllFuncs2.pfnCvarValue( player, "Bad Player" );

	push	OFFSET ??_C@_0L@GBBDLGEP@Bad?5Player@
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	DWORD PTR _svgame+19484
	add	esp, 8
$LN5@pfnQueryCl:

; 4312 : 		Con_Printf( S_ERROR "QueryClientCvarValue: tried to send to a non-client!\n" );

	push	OFFSET ??_C@_0EB@NIKEOBLP@?$FO1Error?3?$FO7?5QueryClientCvarValue@
	call	_Con_Printf
	add	esp, 4
$LN1@pfnQueryCl:

; 4313 : 	}
; 4314 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnQueryClientCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPlayerAuthId
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnGetPlayerAuthId PROC				; COMDAT

; 4285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4286 : 	return SV_GetClientIDString( SV_ClientFromEdict( e, false ));

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	push	eax
	call	_SV_GetClientIDString
	add	esp, 4

; 4287 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerAuthId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnVoice_SetClientListening
_TEXT	SEGMENT
_iReceiver$ = 8						; size = 4
_iSender$ = 12						; size = 4
_bListen$ = 16						; size = 4
_pfnVoice_SetClientListening PROC			; COMDAT

; 4262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4263 : 	iReceiver -= 1;

	mov	eax, DWORD PTR _iReceiver$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iReceiver$[ebp], eax

; 4264 : 	iSender -= 1;

	mov	eax, DWORD PTR _iSender$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iSender$[ebp], eax

; 4265 : 
; 4266 : 	if( iReceiver < 0 || iReceiver >= svs.maxclients || iSender < 0 || iSender > svs.maxclients )

	cmp	DWORD PTR _iReceiver$[ebp], 0
	jl	SHORT $LN3@pfnVoice_S
	mov	eax, DWORD PTR _iReceiver$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@pfnVoice_S
	cmp	DWORD PTR _iSender$[ebp], 0
	jl	SHORT $LN3@pfnVoice_S
	mov	eax, DWORD PTR _iSender$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN2@pfnVoice_S
$LN3@pfnVoice_S:

; 4267 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnVoice_S
$LN2@pfnVoice_S:

; 4268 : 
; 4269 : 	if( bListen ) SetBits( svs.clients[iSender].listeners, BIT( iReceiver ));

	cmp	DWORD PTR _bListen$[ebp], 0
	je	SHORT $LN4@pfnVoice_S
	imul	eax, DWORD PTR _iSender$[ebp], 289832
	mov	edx, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _svs+33344
	or	edx, DWORD PTR [ecx+eax+265476]
	imul	eax, DWORD PTR _iSender$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+eax+265476], edx
	jmp	SHORT $LN5@pfnVoice_S
$LN4@pfnVoice_S:

; 4270 : 	else ClearBits( svs.clients[iSender].listeners, BIT( iReceiver ));

	imul	eax, DWORD PTR _iSender$[ebp], 289832
	mov	edx, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	edx, cl
	not	edx
	mov	ecx, DWORD PTR _svs+33344
	and	edx, DWORD PTR [ecx+eax+265476]
	imul	eax, DWORD PTR _iSender$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+eax+265476], edx
$LN5@pfnVoice_S:

; 4271 : 
; 4272 : 	return true;

	mov	eax, 1
$LN1@pfnVoice_S:

; 4273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnVoice_SetClientListening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnVoice_GetClientListening
_TEXT	SEGMENT
tv76 = -68						; size = 4
_iReceiver$ = 8						; size = 4
_iSender$ = 12						; size = 4
_pfnVoice_GetClientListening PROC			; COMDAT

; 4245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4246 : 	iReceiver -= 1;

	mov	eax, DWORD PTR _iReceiver$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iReceiver$[ebp], eax

; 4247 : 	iSender -= 1;

	mov	eax, DWORD PTR _iSender$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iSender$[ebp], eax

; 4248 : 
; 4249 : 	if( iReceiver < 0 || iReceiver >= svs.maxclients || iSender < 0 || iSender > svs.maxclients )

	cmp	DWORD PTR _iReceiver$[ebp], 0
	jl	SHORT $LN3@pfnVoice_G
	mov	eax, DWORD PTR _iReceiver$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@pfnVoice_G
	cmp	DWORD PTR _iSender$[ebp], 0
	jl	SHORT $LN3@pfnVoice_G
	mov	eax, DWORD PTR _iSender$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN2@pfnVoice_G
$LN3@pfnVoice_G:

; 4250 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnVoice_G
$LN2@pfnVoice_G:

; 4251 : 
; 4252 : 	return (FBitSet( svs.clients[iSender].listeners, BIT( iReceiver )) != 0 );

	imul	eax, DWORD PTR _iSender$[ebp], 289832
	mov	edx, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _svs+33344
	and	edx, DWORD PTR [ecx+eax+265476]
	je	SHORT $LN5@pfnVoice_G
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN6@pfnVoice_G
$LN5@pfnVoice_G:
	mov	DWORD PTR tv76[ebp], 0
$LN6@pfnVoice_G:
	mov	eax, DWORD PTR tv76[ebp]
$LN1@pfnVoice_G:

; 4253 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnVoice_GetClientListening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnForceUnmodified
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pc$ = -4						; size = 4
_type$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_filename$ = 20						; size = 4
_pfnForceUnmodified PROC				; COMDAT

; 4198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 4199 : 	consistency_t	*pc;
; 4200 : 	int		i;
; 4201 : 
; 4202 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@pfnForceUn

; 4203 : 		return;

	jmp	$LN10@pfnForceUn
$LN8@pfnForceUn:

; 4204 : 
; 4205 : 	if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	$LN9@pfnForceUn

; 4206 : 	{
; 4207 : 		for( i = 0; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnForceUn
$LN2@pfnForceUn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnForceUn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@pfnForceUn

; 4208 : 		{
; 4209 : 			pc = &sv.consistency_list[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _sv+809160
	mov	DWORD PTR _pc$[ebp], eax

; 4210 : 
; 4211 : 			if( !pc->filename )

	mov	eax, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN11@pfnForceUn

; 4212 : 			{
; 4213 : 				if( mins ) VectorCopy( mins, pc->mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN13@pfnForceUn
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+20], eax
$LN13@pfnForceUn:

; 4214 : 				if( maxs ) VectorCopy( maxs, pc->maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN14@pfnForceUn
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+32], eax
$LN14@pfnForceUn:

; 4215 : 				pc->filename = SV_CopyString( filename );

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnForceUnmodified@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+19592
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [ecx], eax

; 4216 : 				pc->check_type = type;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4217 : 				return;

	jmp	$LN10@pfnForceUn

; 4218 : 			}

	jmp	SHORT $LN15@pfnForceUn
$LN11@pfnForceUn:

; 4219 : 			else if( !Q_strcmp( filename, pc->filename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@pfnForceUn

; 4220 : 				return;

	jmp	SHORT $LN10@pfnForceUn
$LN15@pfnForceUn:

; 4221 : 		}

	jmp	$LN2@pfnForceUn
$LN3@pfnForceUn:

; 4222 : 		Host_Error( "MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET ??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@
	call	_Host_Error
	add	esp, 8

; 4223 : 	}

	jmp	SHORT $LN10@pfnForceUn
$LN9@pfnForceUn:

; 4224 : 	else
; 4225 : 	{
; 4226 : 		for( i = 0; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@pfnForceUn
$LN5@pfnForceUn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@pfnForceUn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN6@pfnForceUn

; 4227 : 		{
; 4228 : 			pc = &sv.consistency_list[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _sv+809160
	mov	DWORD PTR _pc$[ebp], eax

; 4229 : 			if( !pc->filename ) continue;

	mov	eax, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN16@pfnForceUn
	jmp	SHORT $LN5@pfnForceUn
$LN16@pfnForceUn:

; 4230 : 
; 4231 : 			if( !Q_strcmp( filename, pc->filename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@pfnForceUn

; 4232 : 				return;

	jmp	SHORT $LN10@pfnForceUn
$LN17@pfnForceUn:

; 4233 : 		}

	jmp	SHORT $LN5@pfnForceUn
$LN6@pfnForceUn:

; 4234 : 		Con_Printf( S_ERROR "no precache: %s\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN10@pfnForceUn:

; 4235 : 	}
; 4236 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnForceUnmodified ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPlayerStats
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_ping$ = 12						; size = 4
_packet_loss$ = 16					; size = 4
_pfnGetPlayerStats PROC					; COMDAT

; 4178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4179 : 	sv_client_t	*cl;
; 4180 : 
; 4181 : 	if( packet_loss ) *packet_loss = 0;

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN2@pfnGetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@pfnGetPlay:

; 4182 : 	if( ping ) *ping = 0;

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN3@pfnGetPlay
	mov	eax, DWORD PTR _ping$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@pfnGetPlay:

; 4183 : 
; 4184 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN4@pfnGetPlay

; 4185 : 		return;

	jmp	SHORT $LN6@pfnGetPlay
$LN4@pfnGetPlay:

; 4186 : 
; 4187 : 	if( packet_loss ) *packet_loss = cl->packet_loss;

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN5@pfnGetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264936]
	mov	DWORD PTR [eax], edx
$LN5@pfnGetPlay:

; 4188 : 	if( ping ) *ping = cl->latency * 1000;

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN6@pfnGetPlay
	mov	eax, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR [eax+264940]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _ping$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@pfnGetPlay:

; 4189 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPlayerUserId
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_e$ = 8							; size = 4
_pfnGetPlayerUserId PROC				; COMDAT

; 4163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4164 : 	sv_client_t	*cl;
; 4165 : 
; 4166 : 	if(( cl = SV_ClientFromEdict( e, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPlay

; 4167 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 4168 : 	return cl->userid;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+289828]
$LN1@pfnGetPlay:

; 4169 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerUserId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEndSection
_TEXT	SEGMENT
_pszSection$ = 8					; size = 4
_pfnEndSection PROC					; COMDAT

; 4150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4151 : 	if( !Q_stricmp( "oem_end_credits", pszSection ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszSection$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@HODEPMM@oem_end_credits@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnEndSect

; 4152 : 		Host_Credits ();

	call	_Host_Credits
	jmp	SHORT $LN1@pfnEndSect
$LN2@pfnEndSect:

; 4153 : 	else Cbuf_AddText( "\ndisconnect\n" );

	push	OFFSET ??_C@_0N@IDGDMADI@?6disconnect?6@
	call	_Cbuf_AddText
	add	esp, 4
$LN1@pfnEndSect:

; 4154 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEndSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnCreateInstancedBaseline
_TEXT	SEGMENT
_classname$ = 8						; size = 4
_baseline$ = 12						; size = 4
_pfnCreateInstancedBaseline PROC			; COMDAT

; 4131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4132 : 	if( !baseline || sv.num_instanced >= MAX_CUSTOM_BASELINES )

	cmp	DWORD PTR _baseline$[ebp], 0
	je	SHORT $LN3@pfnCreateI
	cmp	DWORD PTR _sv+2415316, 64		; 00000040H
	jl	SHORT $LN2@pfnCreateI
$LN3@pfnCreateI:

; 4133 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCreateI
$LN2@pfnCreateI:

; 4134 : 
; 4135 : 	// g-cont. must sure that classname is really allocated
; 4136 : 	sv.instanced[sv.num_instanced].classname = SV_CopyString( STRING( classname ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnCreateInstancedBaseline@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _classname$[ebp]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _svgame+19592
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR _sv+2415316, 456
	mov	DWORD PTR _sv[ecx+2386128], eax

; 4137 : 	sv.instanced[sv.num_instanced].baseline = *baseline;

	imul	edi, DWORD PTR _sv+2415316, 456
	add	edi, OFFSET _sv+2386132
	mov	ecx, 113				; 00000071H
	mov	esi, DWORD PTR _baseline$[ebp]
	rep movsd

; 4138 : 	sv.num_instanced++;

	mov	eax, DWORD PTR _sv+2415316
	add	eax, 1
	mov	DWORD PTR _sv+2415316, eax

; 4139 : 
; 4140 : 	return sv.num_instanced;

	mov	eax, DWORD PTR _sv+2415316
$LN1@pfnCreateI:

; 4141 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCreateInstancedBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetGroupMask
_TEXT	SEGMENT
_mask$ = 8						; size = 4
_op$ = 12						; size = 4
_pfnSetGroupMask PROC					; COMDAT

; 4119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4120 : 	svs.groupmask = mask;

	mov	eax, DWORD PTR _mask$[ebp]
	mov	DWORD PTR _svs+20, eax

; 4121 : 	svs.groupop = op;

	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR _svs+24, eax

; 4122 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetGroupMask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnCanSkipPlayer
_TEXT	SEGMENT
tv71 = -72						; size = 4
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_pfnCanSkipPlayer PROC					; COMDAT

; 4088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 4089 : 	sv_client_t	*cl;
; 4090 : 
; 4091 : 	if(( cl = SV_ClientFromEdict( player, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnCanSkip

; 4092 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCanSkip
$LN2@pfnCanSkip:

; 4093 : 
; 4094 : 	return FBitSet( cl->flags, FCL_LOCAL_WEAPONS ) ? true : false;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 32					; 00000020H
	je	SHORT $LN4@pfnCanSkip
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@pfnCanSkip
$LN4@pfnCanSkip:
	mov	DWORD PTR tv71[ebp], 0
$LN5@pfnCanSkip:
	mov	eax, DWORD PTR tv71[ebp]
$LN1@pfnCanSkip:

; 4095 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCanSkipPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnCheckVisibility
_TEXT	SEGMENT
tv159 = -76						; size = 4
tv140 = -76						; size = 4
_leafnum$ = -8						; size = 4
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
_pset$ = 12						; size = 4
_pfnCheckVisibility PROC				; COMDAT

; 4036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 4037 : 	int	i, leafnum;
; 4038 : 
; 4039 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnCheckVisibility@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnCheckVi

; 4040 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnCheckVi
$LN8@pfnCheckVi:

; 4041 : 
; 4042 : 	// vis not set - fullvis enabled
; 4043 : 	if( !pset ) return 1;

	cmp	DWORD PTR _pset$[ebp], 0
	jne	SHORT $LN9@pfnCheckVi
	mov	eax, 1
	jmp	$LN1@pfnCheckVi
$LN9@pfnCheckVi:

; 4044 : 
; 4045 : 	if( FBitSet( ent->v.flags, FL_CUSTOMENTITY ) && ent->v.owner && FBitSet( ent->v.owner->v.flags, FL_CLIENT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 536870912				; 20000000H
	je	SHORT $LN10@pfnCheckVi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+644], 0
	je	SHORT $LN10@pfnCheckVi
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	mov	edx, DWORD PTR [ecx+656]
	and	edx, 8
	je	SHORT $LN10@pfnCheckVi

; 4046 : 		ent = ent->v.owner;	// upcast beams to my owner

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	mov	DWORD PTR _ent$[ebp], ecx
$LN10@pfnCheckVi:

; 4047 : 
; 4048 : 	if( ent->headnode < 0 )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jge	$LN11@pfnCheckVi

; 4049 : 	{
; 4050 : 		// check individual leafs
; 4051 : 		for( i = 0; i < ent->num_leafs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnCheckVi
$LN2@pfnCheckVi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnCheckVi:
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN3@pfnCheckVi

; 4052 : 		{
; 4053 : 			if( CHECKVISBIT( pset, ent->leafnums[i] ))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	test	edx, edx
	jl	SHORT $LN18@pfnCheckVi
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	sar	edx, 3
	mov	eax, DWORD PTR _pset$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	ecx, WORD PTR [ecx+eax*2+24]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv140[ebp], ecx
	jmp	SHORT $LN19@pfnCheckVi
$LN18@pfnCheckVi:
	mov	DWORD PTR tv140[ebp], 0
$LN19@pfnCheckVi:
	cmp	DWORD PTR tv140[ebp], 0
	je	SHORT $LN13@pfnCheckVi

; 4054 : 				return 1;	// visible passed by leaf

	mov	eax, 1
	jmp	$LN1@pfnCheckVi
$LN13@pfnCheckVi:

; 4055 : 		}

	jmp	SHORT $LN2@pfnCheckVi
$LN3@pfnCheckVi:

; 4056 : 
; 4057 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnCheckVi

; 4058 : 	}

	jmp	$LN1@pfnCheckVi
$LN11@pfnCheckVi:

; 4059 : 	else
; 4060 : 	{
; 4061 : 		for( i = 0; i < MAX_ENT_LEAFS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@pfnCheckVi
$LN5@pfnCheckVi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@pfnCheckVi:
	cmp	DWORD PTR _i$[ebp], 48			; 00000030H
	jge	SHORT $LN6@pfnCheckVi

; 4062 : 		{
; 4063 : 			leafnum = ent->leafnums[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	mov	DWORD PTR _leafnum$[ebp], edx

; 4064 : 			if( leafnum == -1 ) break;

	cmp	DWORD PTR _leafnum$[ebp], -1
	jne	SHORT $LN14@pfnCheckVi
	jmp	SHORT $LN6@pfnCheckVi
$LN14@pfnCheckVi:

; 4065 : 
; 4066 : 			if( CHECKVISBIT( pset, leafnum ))

	cmp	DWORD PTR _leafnum$[ebp], 0
	jl	SHORT $LN20@pfnCheckVi
	mov	eax, DWORD PTR _leafnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _pset$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	ecx, DWORD PTR _leafnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv159[ebp], ecx
	jmp	SHORT $LN21@pfnCheckVi
$LN20@pfnCheckVi:
	mov	DWORD PTR tv159[ebp], 0
$LN21@pfnCheckVi:
	cmp	DWORD PTR tv159[ebp], 0
	je	SHORT $LN15@pfnCheckVi

; 4067 : 				return 1;	// visible passed by leaf

	mov	eax, 1
	jmp	SHORT $LN1@pfnCheckVi
$LN15@pfnCheckVi:

; 4068 : 		}

	jmp	SHORT $LN5@pfnCheckVi
$LN6@pfnCheckVi:

; 4069 : 
; 4070 : 		// too many leafs for individual check, go by headnode
; 4071 : 		if( !Mod_HeadnodeVisible( &sv.worldmodel->nodes[ent->headnode], pset, &leafnum ))

	lea	eax, DWORD PTR _leafnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	imul	eax, DWORD PTR [edx+16], 52
	mov	ecx, DWORD PTR _sv+2595644
	add	eax, DWORD PTR [ecx+164]
	push	eax
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@pfnCheckVi

; 4072 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCheckVi
$LN16@pfnCheckVi:

; 4073 : 
; 4074 : 		((edict_t *)ent)->leafnums[ent->num_leafs] = leafnum;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ax, WORD PTR _leafnum$[ebp]
	mov	WORD PTR [edx+ecx*2+24], ax

; 4075 : 		((edict_t *)ent)->num_leafs = (ent->num_leafs + 1) % MAX_ENT_LEAFS;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+20]
	add	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+20], edx

; 4076 : 
; 4077 : 		return 2;	// visible passed by headnode

	mov	eax, 2
$LN1@pfnCheckVi:

; 4078 : 	}
; 4079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCheckVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPrecacheEvent
_TEXT	SEGMENT
_type$ = 8						; size = 4
_psz$ = 12						; size = 4
_pfnPrecacheEvent PROC					; COMDAT

; 3713 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3714 : 	return (word)SV_EventIndex( psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_SV_EventIndex
	add	esp, 4

; 3715 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPrecacheEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPhysicsInfoString
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pfnGetPhysicsInfoString PROC				; COMDAT

; 3691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3692 : 	sv_client_t	*cl;
; 3693 : 
; 3694 : 	// pfnUserInfoChanged passed
; 3695 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPhys

; 3696 : 	{
; 3697 : 		Con_Printf( S_ERROR "GetPhysicsInfoString: tried to a non-client!\n" );

	push	OFFSET ??_C@_0DJ@NNOEMDHI@?$FO1Error?3?$FO7?5GetPhysicsInfoString@
	call	_Con_Printf
	add	esp, 4

; 3698 : 		return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 3699 : 	}
; 3700 : 
; 3701 : 	return cl->physinfo;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
$LN1@pfnGetPhys:

; 3702 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPhysicsInfoString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetPhysicsKeyValue
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_pfnSetPhysicsKeyValue PROC				; COMDAT

; 3671 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3672 : 	sv_client_t	*cl;
; 3673 : 
; 3674 : 	// pfnUserInfoChanged passed
; 3675 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnSetPhys

; 3676 : 	{
; 3677 : 		Con_Printf( S_ERROR "SetPhysicsKeyValue: tried to a non-client!\n" );

	push	OFFSET ??_C@_0DH@KFOANOOP@?$FO1Error?3?$FO7?5SetPhysicsKeyValue?3?5@
	call	_Con_Printf
	add	esp, 4

; 3678 : 		return;

	jmp	SHORT $LN1@pfnSetPhys
$LN2@pfnSetPhys:

; 3679 : 	}
; 3680 : 
; 3681 : 	Info_SetValueForKey( cl->physinfo, key, value, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 304				; 00000130H
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
$LN1@pfnSetPhys:

; 3682 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetPhysicsKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPhysicsKeyValue
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_key$ = 12						; size = 4
_pfnGetPhysicsKeyValue PROC				; COMDAT

; 3651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3652 : 	sv_client_t	*cl;
; 3653 : 
; 3654 : 	// pfnUserInfoChanged passed
; 3655 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPhys

; 3656 : 	{
; 3657 : 		Con_Printf( S_ERROR "GetPhysicsKeyValue: tried to a non-client!\n" );

	push	OFFSET ??_C@_0DH@MCFALDIE@?$FO1Error?3?$FO7?5GetPhysicsKeyValue?3?5@
	call	_Con_Printf
	add	esp, 4

; 3658 : 		return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 3659 : 	}
; 3660 : 
; 3661 : 	return Info_ValueForKey( cl->physinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
$LN1@pfnGetPhys:

; 3662 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPhysicsKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetClientKeyValue
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_clientIndex$ = 8					; size = 4
_infobuffer$ = 12					; size = 4
_key$ = 16						; size = 4
_value$ = 20						; size = 4
_pfnSetClientKeyValue PROC				; COMDAT

; 3622 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3623 : 	sv_client_t	*cl;
; 3624 : 
; 3625 : 	if( infobuffer == svs.localinfo || infobuffer == svs.serverinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+572
	je	SHORT $LN3@pfnSetClie
	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+60
	jne	SHORT $LN2@pfnSetClie
$LN3@pfnSetClie:

; 3626 : 		return;

	jmp	$LN1@pfnSetClie
$LN2@pfnSetClie:

; 3627 : 
; 3628 : 	clientIndex -= 1;

	mov	eax, DWORD PTR _clientIndex$[ebp]
	sub	eax, 1
	mov	DWORD PTR _clientIndex$[ebp], eax

; 3629 : 
; 3630 : 	if( !svs.clients || clientIndex < 0 || clientIndex >= svs.maxclients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN5@pfnSetClie
	cmp	DWORD PTR _clientIndex$[ebp], 0
	jl	SHORT $LN5@pfnSetClie
	mov	eax, DWORD PTR _clientIndex$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jl	SHORT $LN4@pfnSetClie
$LN5@pfnSetClie:

; 3631 : 		return;

	jmp	SHORT $LN1@pfnSetClie
$LN4@pfnSetClie:

; 3632 : 
; 3633 : 	// value not changed?
; 3634 : 	if( !Q_strcmp( Info_ValueForKey( infobuffer, key ), value ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnSetClie

; 3635 : 		return;

	jmp	SHORT $LN1@pfnSetClie
$LN6@pfnSetClie:

; 3636 : 
; 3637 : 	cl = &svs.clients[clientIndex]; 

	imul	eax, DWORD PTR _clientIndex$[ebp], 289832
	add	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax

; 3638 : 
; 3639 : 	Info_SetValueForStarKey( infobuffer, key, value, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H

; 3640 : 	SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 3641 : 	cl->next_sendinfotime = 0.0;	// send immediately

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264352], xmm0
$LN1@pfnSetClie:

; 3642 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetClientKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetValueForKey
_TEXT	SEGMENT
_infobuffer$ = 8					; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_pfnSetValueForKey PROC					; COMDAT

; 3607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3608 : 	if( infobuffer == svs.localinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+572
	jne	SHORT $LN2@pfnSetValu

; 3609 : 		Info_SetValueForStarKey( infobuffer, key, value, MAX_LOCALINFO_STRING );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetValu
$LN2@pfnSetValu:

; 3610 : 	else if( infobuffer == svs.serverinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+60
	jne	SHORT $LN4@pfnSetValu

; 3611 : 		Info_SetValueForStarKey( infobuffer, key, value, MAX_SERVERINFO_STRING );

	push	512					; 00000200H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetValu
$LN4@pfnSetValu:

; 3612 : 	else Con_Printf( S_ERROR "can't set client keys with SetValueForKey\n" );

	push	OFFSET ??_C@_0DG@PMHMFMJC@?$FO1Error?3?$FO7?5can?8t?5set?5client?5key@
	call	_Con_Printf
	add	esp, 4
$LN1@pfnSetValu:

; 3613 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetInfoKeyBuffer
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_e$ = 8							; size = 4
_pfnGetInfoKeyBuffer PROC				; COMDAT

; 3582 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3583 : 	sv_client_t	*cl;
; 3584 : 
; 3585 : 	// NULL passes localinfo
; 3586 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetInfoKeyBuffer@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetInfo

; 3587 : 		return SV_Localinfo();

	call	_SV_Localinfo
	jmp	SHORT $LN1@pfnGetInfo
$LN2@pfnGetInfo:

; 3588 : 
; 3589 : 	// world passes serverinfo
; 3590 : 	if( e == svgame.edicts )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7928
	jne	SHORT $LN3@pfnGetInfo

; 3591 : 		return SV_Serverinfo();

	call	_SV_Serverinfo
	jmp	SHORT $LN1@pfnGetInfo
$LN3@pfnGetInfo:

; 3592 : 
; 3593 : 	// userinfo for specified edict
; 3594 : 	if(( cl = SV_ClientFromEdict( e, false )) != NULL )

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN4@pfnGetInfo

; 3595 : 		return cl->userinfo;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	jmp	SHORT $LN1@pfnGetInfo
$LN4@pfnGetInfo:

; 3596 : 
; 3597 : 	return ""; // assume error

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
$LN1@pfnGetInfo:

; 3598 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetInfoKeyBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnRunPlayerMove
_TEXT	SEGMENT
_seed$ = -72						; size = 4
_cmd$ = -68						; size = 56
_oldcl$ = -12						; size = 4
_cl$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pClient$ = 8						; size = 4
_viewangles$ = 12					; size = 4
_fmove$ = 16						; size = 4
_smove$ = 20						; size = 4
_upmove$ = 24						; size = 4
_buttons$ = 28						; size = 2
_impulse$ = 32						; size = 1
_msec$ = 36						; size = 1
_pfnRunPlayerMove PROC					; COMDAT

; 3521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3522 : 	sv_client_t	*cl, *oldcl;
; 3523 : 	usercmd_t		cmd;
; 3524 : 	uint		seed;
; 3525 : 
; 3526 : 	if(( cl = SV_ClientFromEdict( pClient, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnRunPlay

; 3527 : 		return;

	jmp	$LN1@pfnRunPlay
$LN2@pfnRunPlay:

; 3528 : 
; 3529 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN3@pfnRunPlay

; 3530 : 		return; // only fakeclients allows

	jmp	$LN1@pfnRunPlay
$LN3@pfnRunPlay:

; 3531 : 
; 3532 : 	oldcl = sv.current_client;

	mov	eax, DWORD PTR _sv+40
	mov	DWORD PTR _oldcl$[ebp], eax

; 3533 : 
; 3534 : 	sv.current_client = SV_ClientFromEdict( pClient, true );

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _sv+40, eax

; 3535 : 	sv.current_client->timebase = (sv.time + sv.frametime) - ((double)msec / 1000.0);

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _sv+16
	movzx	eax, BYTE PTR _msec$[ebp]
	cvtsi2sd xmm1, eax
	divsd	xmm1, QWORD PTR __real@408f400000000000
	subsd	xmm0, xmm1
	mov	ecx, DWORD PTR _sv+40
	movsd	QWORD PTR [ecx+264368], xmm0

; 3536 : 
; 3537 : 	memset( &cmd, 0, sizeof( cmd ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3538 : 	VectorCopy( viewangles, cmd.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _viewangles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _cmd$[ebp+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _viewangles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _cmd$[ebp+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _viewangles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _cmd$[ebp+ecx+4], eax

; 3539 : 	cmd.forwardmove = fmove;

	movss	xmm0, DWORD PTR _fmove$[ebp]
	movss	DWORD PTR _cmd$[ebp+16], xmm0

; 3540 : 	cmd.sidemove = smove;

	movss	xmm0, DWORD PTR _smove$[ebp]
	movss	DWORD PTR _cmd$[ebp+20], xmm0

; 3541 : 	cmd.upmove = upmove;

	movss	xmm0, DWORD PTR _upmove$[ebp]
	movss	DWORD PTR _cmd$[ebp+24], xmm0

; 3542 : 	cmd.buttons = buttons;

	movzx	eax, WORD PTR _buttons$[ebp]
	mov	DWORD PTR _cmd$[ebp+32], eax

; 3543 : 	cmd.impulse = impulse;

	mov	al, BYTE PTR _impulse$[ebp]
	mov	BYTE PTR _cmd$[ebp+36], al

; 3544 : 	cmd.msec = msec;

	mov	al, BYTE PTR _msec$[ebp]
	mov	BYTE PTR _cmd$[ebp+2], al

; 3545 : 
; 3546 : 	seed = COM_RandomLong( 0, 0x7fffffff ); // full range

	push	2147483647				; 7fffffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _seed$[ebp], eax

; 3547 : 
; 3548 : 	SV_RunCmd( cl, &cmd, seed );

	mov	eax, DWORD PTR _seed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 3549 : 
; 3550 : 	cl->lastcmd = cmd;

	mov	edi, DWORD PTR _cl$[ebp]
	add	edi, 264856				; 00040a98H
	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _cmd$[ebp]
	rep movsd

; 3551 : 	sv.current_client = oldcl;

	mov	eax, DWORD PTR _oldcl$[ebp]
	mov	DWORD PTR _sv+40, eax
$LN1@pfnRunPlay:

; 3552 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRunPlayerMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetClientMaxspeed
_TEXT	SEGMENT
tv75 = -76						; size = 4
tv72 = -72						; size = 4
_cl$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_fNewMaxspeed$ = 12					; size = 4
_pfnSetClientMaxspeed PROC				; COMDAT

; 3502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3503 : 	sv_client_t	*cl;
; 3504 : 
; 3505 : 	// not spawned clients allowed
; 3506 : 	if(( cl = SV_ClientFromEdict( pEdict, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnSetClie

; 3507 : 		return;

	jmp	$LN1@pfnSetClie
$LN2@pfnSetClie:

; 3508 : 
; 3509 : 	fNewMaxspeed = bound( -svgame.movevars.maxspeed, fNewMaxspeed, svgame.movevars.maxspeed );

	movss	xmm0, DWORD PTR _svgame+7944
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _fNewMaxspeed$[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@pfnSetClie
	movss	xmm0, DWORD PTR _svgame+7944
	comiss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	jbe	SHORT $LN4@pfnSetClie
	movss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	movss	DWORD PTR tv72[ebp], xmm0
	jmp	SHORT $LN5@pfnSetClie
$LN4@pfnSetClie:
	movss	xmm0, DWORD PTR _svgame+7944
	movss	DWORD PTR tv72[ebp], xmm0
$LN5@pfnSetClie:
	movss	xmm0, DWORD PTR tv72[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN7@pfnSetClie
$LN6@pfnSetClie:
	movss	xmm0, DWORD PTR _svgame+7944
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv75[ebp], xmm0
$LN7@pfnSetClie:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _fNewMaxspeed$[ebp], xmm0

; 3510 : 	Info_SetValueForKey( cl->physinfo, "maxspd", va( "%.f", fNewMaxspeed ), MAX_INFO_STRING );

	push	256					; 00000100H
	cvtss2sd xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_03EICDNICE@?$CF?4f@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_06KOBCLDNE@maxspd@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 3511 : 	cl->edict->v.maxspeed = fNewMaxspeed;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	movss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	movss	DWORD PTR [ecx+752], xmm0
$LN1@pfnSetClie:

; 3512 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetClientMaxspeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnFadeClientVolume
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_fadePercent$ = 12					; size = 4
_fadeOutSeconds$ = 16					; size = 4
_holdTime$ = 20						; size = 4
_fadeInSeconds$ = 24					; size = 4
_pfnFadeClientVolume PROC				; COMDAT

; 3478 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3479 : 	sv_client_t	*cl;
; 3480 : 
; 3481 : 	if(( cl = SV_ClientFromEdict( pEdict, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnFadeCli

; 3482 : 		return;

	jmp	SHORT $LN1@pfnFadeCli
$LN2@pfnFadeCli:

; 3483 : 
; 3484 : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@pfnFadeCli

; 3485 : 		return;

	jmp	SHORT $LN1@pfnFadeCli
$LN3@pfnFadeCli:

; 3486 : 
; 3487 : 	MSG_BeginServerCmd( &cl->netchan.message, svc_soundfade );

	push	0
	push	1
	push	48					; 00000030H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3488 : 	MSG_WriteByte( &cl->netchan.message, fadePercent );

	mov	eax, DWORD PTR _fadePercent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 3489 : 	MSG_WriteByte( &cl->netchan.message, holdTime );

	mov	eax, DWORD PTR _holdTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 3490 : 	MSG_WriteByte( &cl->netchan.message, fadeOutSeconds );

	mov	eax, DWORD PTR _fadeOutSeconds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 3491 : 	MSG_WriteByte( &cl->netchan.message, fadeInSeconds );

	mov	eax, DWORD PTR _fadeInSeconds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN1@pfnFadeCli:

; 3492 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFadeClientVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetPlayerWONId
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnGetPlayerWONId PROC					; COMDAT

; 3451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3452 : 	return (uint)-1;

	or	eax, -1

; 3453 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerWONId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnIsDedicatedServer
_TEXT	SEGMENT
tv65 = -68						; size = 4
_pfnIsDedicatedServer PROC				; COMDAT

; 3439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3440 : 	return (host.type == HOST_DEDICATED);

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN3@pfnIsDedic
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnIsDedic
$LN3@pfnIsDedic:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnIsDedic:
	mov	eax, DWORD PTR tv65[ebp]

; 3441 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsDedicatedServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnStaticDecal
_TEXT	SEGMENT
_origin$ = 8						; size = 4
_decalIndex$ = 12					; size = 4
_entityIndex$ = 16					; size = 4
_modelIndex$ = 20					; size = 4
_pfnStaticDecal PROC					; COMDAT

; 3428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3429 : 	SV_CreateDecal( &sv.signon, origin, decalIndex, entityIndex, modelIndex, FDECAL_PERMANENT, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	push	OFFSET _sv+2456340
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH

; 3430 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStaticDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetView
_TEXT	SEGMENT
_viewEnt$ = -8						; size = 4
_client$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pViewent$ = 12						; size = 4
_pfnSetView PROC					; COMDAT

; 3392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3393 : 	sv_client_t	*client;
; 3394 : 	int		viewEnt;
; 3395 : 
; 3396 : 	if( !SV_IsValidEdict( pClient ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetView@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pClient$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetView

; 3397 : 		return;

	jmp	$LN1@pfnSetView
$LN2@pfnSetView:

; 3398 : 
; 3399 : 	if(( client = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN3@pfnSetView

; 3400 : 	{
; 3401 : 		Con_Printf( S_ERROR "PF_SetView_I: not a client!\n" );

	push	OFFSET ??_C@_0CI@CCGIJEH@?$FO1Error?3?$FO7?5PF_SetView_I?3?5not?5a?5@
	call	_Con_Printf
	add	esp, 4

; 3402 : 		return;

	jmp	$LN1@pfnSetView
$LN3@pfnSetView:

; 3403 : 	}
; 3404 : 
; 3405 : 	if( !SV_IsValidEdict( pViewent ) || pClient == pViewent )

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetView@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pViewent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@pfnSetView
	mov	eax, DWORD PTR _pClient$[ebp]
	cmp	eax, DWORD PTR _pViewent$[ebp]
	jne	SHORT $LN4@pfnSetView
$LN6@pfnSetView:

; 3406 : 		client->pViewEntity = NULL; // just reset viewentity

	mov	eax, DWORD PTR _client$[ebp]
	mov	DWORD PTR [eax+264952], 0
	jmp	SHORT $LN5@pfnSetView
$LN4@pfnSetView:

; 3407 : 	else client->pViewEntity = (edict_t *)pViewent;

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _pViewent$[ebp]
	mov	DWORD PTR [eax+264952], ecx
$LN5@pfnSetView:

; 3408 : 
; 3409 : 	// fakeclients ignore to send client message (but can see into the trigger_camera through the PVS)
; 3410 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@pfnSetView

; 3411 : 		return;

	jmp	SHORT $LN1@pfnSetView
$LN7@pfnSetView:

; 3412 : 
; 3413 : 	if( client->pViewEntity )

	mov	eax, DWORD PTR _client$[ebp]
	cmp	DWORD PTR [eax+264952], 0
	je	SHORT $LN8@pfnSetView

; 3414 : 		viewEnt = NUM_FOR_EDICT( client->pViewEntity );

	mov	eax, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR [eax+264952]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
	jmp	SHORT $LN9@pfnSetView
$LN8@pfnSetView:

; 3415 : 	else viewEnt = NUM_FOR_EDICT( client->edict );

	mov	eax, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR [eax+264948]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
$LN9@pfnSetView:

; 3416 : 
; 3417 : 	MSG_BeginServerCmd( &client->netchan.message, svc_setview );

	push	0
	push	1
	push	5
	mov	eax, DWORD PTR _client$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3418 : 	MSG_WriteWord( &client->netchan.message, viewEnt );

	mov	eax, DWORD PTR _viewEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8
$LN1@pfnSetView:

; 3419 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnCrosshairAngle
_TEXT	SEGMENT
_client$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pitch$ = 12						; size = 4
_yaw$ = 16						; size = 4
_pfnCrosshairAngle PROC					; COMDAT

; 3365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3366 : 	sv_client_t	*client;
; 3367 : 
; 3368 : 	if(( client = SV_ClientFromEdict( pClient, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN2@pfnCrossha

; 3369 : 		return;

	jmp	$LN1@pfnCrossha
$LN2@pfnCrossha:

; 3370 : 
; 3371 : 	// fakeclients ignores it silently
; 3372 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@pfnCrossha

; 3373 : 		return;

	jmp	$LN1@pfnCrossha
$LN3@pfnCrossha:

; 3374 : 
; 3375 : 	if( pitch > 180.0f ) pitch -= 360;

	movss	xmm0, DWORD PTR _pitch$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN4@pfnCrossha
	movss	xmm0, DWORD PTR _pitch$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN4@pfnCrossha:

; 3376 : 	if( pitch < -180.0f ) pitch += 360;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _pitch$[ebp]
	jbe	SHORT $LN5@pfnCrossha
	movss	xmm0, DWORD PTR _pitch$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN5@pfnCrossha:

; 3377 : 	if( yaw > 180.0f ) yaw -= 360;

	movss	xmm0, DWORD PTR _yaw$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN6@pfnCrossha
	movss	xmm0, DWORD PTR _yaw$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN6@pfnCrossha:

; 3378 : 	if( yaw < -180.0f ) yaw += 360;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _yaw$[ebp]
	jbe	SHORT $LN7@pfnCrossha
	movss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN7@pfnCrossha:

; 3379 : 
; 3380 : 	MSG_BeginServerCmd( &client->netchan.message, svc_crosshairangle );

	push	0
	push	1
	push	47					; 0000002fH
	mov	eax, DWORD PTR _client$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3381 : 	MSG_WriteChar( &client->netchan.message, pitch * 5 );

	movss	xmm0, DWORD PTR _pitch$[ebp]
	mulss	xmm0, DWORD PTR __real@40a00000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteChar
	add	esp, 8

; 3382 : 	MSG_WriteChar( &client->netchan.message, yaw * 5 );

	movss	xmm0, DWORD PTR _yaw$[ebp]
	mulss	xmm0, DWORD PTR __real@40a00000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteChar
	add	esp, 8
$LN1@pfnCrossha:

; 3383 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCrosshairAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetAttachment
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_iAttachment$ = 12					; size = 4
_rgflOrigin$ = 16					; size = 4
_rgflAngles$ = 20					; size = 4
_pfnGetAttachment PROC					; COMDAT

; 3352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3353 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetAttachment@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetAtta

; 3354 : 		return;

	jmp	SHORT $LN1@pfnGetAtta
$LN2@pfnGetAtta:

; 3355 : 	Mod_StudioGetAttachment( pEdict, iAttachment, rgflOrigin, rgflAngles );

	mov	eax, DWORD PTR _rgflAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rgflOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAttachment$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_Mod_StudioGetAttachment
	add	esp, 16					; 00000010H
$LN1@pfnGetAtta:

; 3356 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetAttachment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnServerPrint
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_pfnServerPrint PROC					; COMDAT

; 3339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3340 : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	je	SHORT $LN2@pfnServerP

; 3341 : 		SV_BroadcastPrintf( NULL, "%s", szMsg );

	mov	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnServerP
$LN2@pfnServerP:

; 3342 : 	else Con_Printf( "%s", szMsg );

	mov	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8
$LN1@pfnServerP:

; 3343 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnClientPrintf
_TEXT	SEGMENT
tv72 = -72						; size = 4
_client$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_ptype$ = 12						; size = 4
_szMsg$ = 16						; size = 4
_pfnClientPrintf PROC					; COMDAT

; 3306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3307 : 	sv_client_t	*client;
; 3308 : 
; 3309 : 	if(( client = SV_ClientFromEdict( pEdict, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN4@pfnClientP

; 3310 : 	{
; 3311 : 		Con_Printf( "tried to sprint to a non-client\n" );

	push	OFFSET ??_C@_0CB@LCDPNMPO@tried?5to?5sprint?5to?5a?5non?9client@
	call	_Con_Printf
	add	esp, 4

; 3312 : 		return;

	jmp	SHORT $LN1@pfnClientP
$LN4@pfnClientP:

; 3313 : 	}
; 3314 : 
; 3315 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN5@pfnClientP

; 3316 : 		return;

	jmp	SHORT $LN1@pfnClientP
$LN5@pfnClientP:

; 3317 : 
; 3318 : 	switch( ptype )

	mov	eax, DWORD PTR _ptype$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN7@pfnClientP
	cmp	DWORD PTR tv72[ebp], 1
	je	SHORT $LN8@pfnClientP
	cmp	DWORD PTR tv72[ebp], 2
	je	SHORT $LN7@pfnClientP
	jmp	SHORT $LN1@pfnClientP
$LN7@pfnClientP:

; 3319 : 	{
; 3320 : 	case print_console:
; 3321 : 	case print_chat:
; 3322 : 		SV_ClientPrintf( client, "%s", szMsg );

	mov	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	ecx, DWORD PTR _client$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 12					; 0000000cH

; 3323 : 		break;

	jmp	SHORT $LN1@pfnClientP
$LN8@pfnClientP:

; 3324 : 	case print_center:
; 3325 : 		MSG_BeginServerCmd( &client->netchan.message, svc_centerprint );

	push	0
	push	1
	push	26					; 0000001aH
	mov	eax, DWORD PTR _client$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3326 : 		MSG_WriteString( &client->netchan.message, szMsg );

	mov	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
$LN1@pfnClientP:

; 3327 : 		break;
; 3328 : 	}
; 3329 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnNameForFunction
_TEXT	SEGMENT
_function$ = 8						; size = 4
_pfnNameForFunction PROC				; COMDAT

; 3295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3296 : 	return COM_NameForFunction( svgame.hInstance, function );

	mov	eax, DWORD PTR _function$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_NameForFunction
	add	esp, 8

; 3297 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnNameForFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnFunctionFromName
_TEXT	SEGMENT
_pName$ = 8						; size = 4
_pfnFunctionFromName PROC				; COMDAT

; 3284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3285 : 	return COM_FunctionFromName( svgame.hInstance, pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_FunctionFromName
	add	esp, 8

; 3286 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFunctionFromName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetBonePosition
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_iBone$ = 12						; size = 4
_rgflOrigin$ = 16					; size = 4
_rgflAngles$ = 20					; size = 4
_pfnGetBonePosition PROC				; COMDAT

; 3271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3272 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetBonePosition@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetBone

; 3273 : 		return;

	jmp	SHORT $LN1@pfnGetBone
$LN2@pfnGetBone:

; 3274 : 	Mod_GetBonePosition( pEdict, iBone, rgflOrigin, rgflAngles );

	mov	eax, DWORD PTR _rgflAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rgflOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBone$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_Mod_GetBonePosition
	add	esp, 16					; 00000010H
$LN1@pfnGetBone:

; 3275 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetBonePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnAnimationAutomove
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_flTime$ = 12						; size = 4
_pfnAnimationAutomove PROC				; COMDAT

; 3261 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3262 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnAnimationAutomove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnRegUserMsg
_TEXT	SEGMENT
tv79 = -76						; size = 4
tv78 = -72						; size = 4
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pfnRegUserMsg PROC					; COMDAT

; 3203 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3204 : 	int	i;
; 3205 : 	
; 3206 : 	if( !COM_CheckString( pszName ))

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnRegUser

; 3207 : 		return svc_bad;

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN5@pfnRegUser:

; 3208 : 
; 3209 : 	if( Q_strlen( pszName ) >= sizeof( svgame.msg[0].name ))

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	jb	SHORT $LN6@pfnRegUser

; 3210 : 	{
; 3211 : 		Con_Printf( S_ERROR "REG_USER_MSG: too long name %s\n", pszName );

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@JAIHJPPE@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5too?5lo@
	call	_Con_Printf
	add	esp, 8

; 3212 : 		return svc_bad; // force error

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN6@pfnRegUser:

; 3213 : 	}
; 3214 : 
; 3215 : 	if( iSize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _iSize$[ebp], 2048		; 00000800H
	jle	SHORT $LN7@pfnRegUser

; 3216 : 	{
; 3217 : 		Con_Printf( S_ERROR "REG_USER_MSG: %s has too big size %i\n", pszName, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DB@LHMDHGPA@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5?$CFs?5has@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 3218 : 		return svc_bad; // force error

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN7@pfnRegUser:

; 3219 : 	}
; 3220 : 
; 3221 : 	// make sure what size inrange
; 3222 : 	iSize = bound( -1, iSize, MAX_USERMSG_LENGTH );

	cmp	DWORD PTR _iSize$[ebp], -1
	jl	SHORT $LN14@pfnRegUser
	cmp	DWORD PTR _iSize$[ebp], 2048		; 00000800H
	jge	SHORT $LN12@pfnRegUser
	mov	eax, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN13@pfnRegUser
$LN12@pfnRegUser:
	mov	DWORD PTR tv78[ebp], 2048		; 00000800H
$LN13@pfnRegUser:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN15@pfnRegUser
$LN14@pfnRegUser:
	mov	DWORD PTR tv79[ebp], -1
$LN15@pfnRegUser:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _iSize$[ebp], edx

; 3223 : 
; 3224 : 	// message 0 is reserved for svc_bad
; 3225 : 	for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnRegUser
$LN2@pfnRegUser:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnRegUser:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnRegUser
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _svgame[eax+edx+4]
	test	eax, eax
	je	SHORT $LN3@pfnRegUser

; 3226 : 	{
; 3227 : 		// see if already registered
; 3228 : 		if( !Q_strcmp( svgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _svgame+4
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnRegUser

; 3229 : 			return svc_lastmsg + i; // offset

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 58					; 0000003aH
	jmp	$LN1@pfnRegUser
$LN8@pfnRegUser:

; 3230 : 	}

	jmp	SHORT $LN2@pfnRegUser
$LN3@pfnRegUser:

; 3231 : 
; 3232 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN9@pfnRegUser

; 3233 : 	{
; 3234 : 		Con_Printf( S_ERROR "REG_USER_MSG: user messages limit exceeded\n" );

	push	OFFSET ??_C@_0DH@NDFPHNBP@?$FO1Error?3?$FO7?5REG_USER_MSG?3?5user?5m@
	call	_Con_Printf
	add	esp, 4

; 3235 : 		return svc_bad;

	xor	eax, eax
	jmp	SHORT $LN1@pfnRegUser
$LN9@pfnRegUser:

; 3236 : 	}
; 3237 : 
; 3238 : 	// register new message
; 3239 : 	Q_strncpy( svgame.msg[i].name, pszName, sizeof( svgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _svgame+4
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3240 : 	svgame.msg[i].number = svc_lastmsg + i;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 58					; 0000003aH
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _svgame[ecx+36], eax

; 3241 : 	svgame.msg[i].size = iSize;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _svgame[eax+40], ecx

; 3242 : 
; 3243 : 	if( sv.state == ss_active )

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN10@pfnRegUser

; 3244 : 	{
; 3245 : 		// tell the client about new user message
; 3246 : 		SV_SendUserReg( &sv.multicast, &svgame.msg[i] );

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	push	eax
	push	OFFSET _sv+2448128
	call	_SV_SendUserReg
	add	esp, 8

; 3247 : 		SV_Multicast( MSG_ALL, NULL, NULL, false, false );

	push	0
	push	0
	push	0
	push	0
	push	2
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN10@pfnRegUser:

; 3248 : 	}
; 3249 : 
; 3250 : 	return svgame.msg[i].number;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	eax, DWORD PTR _svgame[eax+36]
$LN1@pfnRegUser:

; 3251 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRegUserMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetModelPtr
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_pfnGetModelPtr PROC					; COMDAT

; 3172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3173 : 	model_t	*mod;
; 3174 : 
; 3175 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetModelPtr@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetMode

; 3176 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetMode
$LN2@pfnGetMode:

; 3177 : 
; 3178 : 	mod = SV_ModelHandle( pEdict->v.modelindex );

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 3179 : 	return Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
$LN1@pfnGetMode:

; 3180 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelPtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnFindEntityByVars
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pEdict$ = -4						; size = 4
_pvars$ = 8						; size = 4
_pfnFindEntityByVars PROC				; COMDAT

; 3145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3146 : 	edict_t	*pEdict;
; 3147 : 	int	i;
; 3148 : 
; 3149 : 	// don't pass invalid arguments
; 3150 : 	if( !pvars ) return NULL;

	cmp	DWORD PTR _pvars$[ebp], 0
	jne	SHORT $LN5@pfnFindEnt
	xor	eax, eax
	jmp	SHORT $LN1@pfnFindEnt
$LN5@pfnFindEnt:

; 3151 : 
; 3152 : 	for( i = 0; i < GI->max_edicts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnFindEnt
$LN2@pfnFindEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnFindEnt:
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN3@pfnFindEnt

; 3153 : 	{
; 3154 : 		pEdict = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax

; 3155 : 
; 3156 : 		// g-cont: we should compare pointers
; 3157 : 		if( &pEdict->v == pvars )

	mov	eax, DWORD PTR _pEdict$[ebp]
	add	eax, 128				; 00000080H
	cmp	eax, DWORD PTR _pvars$[ebp]
	jne	SHORT $LN6@pfnFindEnt

; 3158 : 			return pEdict; // found it

	mov	eax, DWORD PTR _pEdict$[ebp]
	jmp	SHORT $LN1@pfnFindEnt
$LN6@pfnFindEnt:

; 3159 : 	}

	jmp	SHORT $LN2@pfnFindEnt
$LN3@pfnFindEnt:

; 3160 : 
; 3161 : 	return NULL;

	xor	eax, eax
$LN1@pfnFindEnt:

; 3162 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindEntityByVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEntOffsetOfPEntity
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnEntOffsetOfPEntity PROC				; COMDAT

; 3089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3090 : 	return (byte *)pEdict - (byte *)svgame.edicts;

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928

; 3091 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEntOffsetOfPEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPEntityOfEntOffset
_TEXT	SEGMENT
_iEntOffset$ = 8					; size = 4
_pfnPEntityOfEntOffset PROC				; COMDAT

; 3078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3079 : 	return (edict_t *)((byte *)svgame.edicts + iEntOffset);

	mov	eax, DWORD PTR _svgame+7928
	add	eax, DWORD PTR _iEntOffset$[ebp]

; 3080 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPEntityOfEntOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetVarsOfEnt
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnGetVarsOfEnt PROC					; COMDAT

; 3065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3066 : 	if( pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN2@pfnGetVars

; 3067 : 		return &pEdict->v;

	mov	eax, DWORD PTR _pEdict$[ebp]
	add	eax, 128				; 00000080H
	jmp	SHORT $LN1@pfnGetVars
$LN2@pfnGetVars:

; 3068 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetVars:

; 3069 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetVarsOfEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPvEntPrivateData
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnPvEntPrivateData PROC				; COMDAT

; 2988 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2989 : 	if( pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN2@pfnPvEntPr

; 2990 : 		return pEdict->pvPrivateData;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $LN1@pfnPvEntPr
$LN2@pfnPvEntPr:

; 2991 : 	return NULL;

	xor	eax, eax
$LN1@pfnPvEntPr:

; 2992 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPvEntPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPvAllocEntPrivateData
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pEdict$ = 8						; size = 4
_cb$ = 12						; size = 4
_pfnPvAllocEntPrivateData PROC				; COMDAT

; 2966 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2967 : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN4@pfnPvAlloc
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@pfnPvAlloc
$LN4@pfnPvAlloc:
	mov	DWORD PTR tv70[ebp], 0
$LN5@pfnPvAlloc:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPvAllocEntPrivateData@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2968 : 
; 2969 : 	SV_FreePrivateData( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_FreePrivateData
	add	esp, 4

; 2970 : 
; 2971 : 	if( cb > 0 )

	cmp	DWORD PTR _cb$[ebp], 0
	jle	SHORT $LN2@pfnPvAlloc

; 2972 : 	{
; 2973 : 		// a poke646 have memory corrupt in somewhere - this is trashed last sixteen bytes :(
; 2974 : 		pEdict->pvPrivateData = Mem_Calloc( svgame.mempool, (cb + 15) & ~15 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPvAllocEntPrivateData@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _cb$[ebp]
	add	ecx, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	push	ecx
	mov	edx, DWORD PTR _svgame+19588
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [ecx+124], eax
$LN2@pfnPvAlloc:

; 2975 : 	}
; 2976 : 
; 2977 : 	return pEdict->pvPrivateData;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [eax+124]

; 2978 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPvAllocEntPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnBuildSoundMsg
_TEXT	SEGMENT
_pSource$ = 8						; size = 4
_chan$ = 12						; size = 4
_samp$ = 16						; size = 4
_fvol$ = 20						; size = 4
_attn$ = 24						; size = 4
_fFlags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_msg_dest$ = 36						; size = 4
_msg_type$ = 40						; size = 4
_pOrigin$ = 44						; size = 4
_pSend$ = 48						; size = 4
_pfnBuildSoundMsg PROC					; COMDAT

; 2953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2954 : 	pfnMessageBegin( msg_dest, msg_type, pOrigin, pSend );

	mov	eax, DWORD PTR _pSend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	_pfnMessageBegin
	add	esp, 16					; 00000010H

; 2955 : 	SV_BuildSoundMsg( &sv.multicast, pSource, chan, samp, fvol * 255, attn, fFlags, pitch, pOrigin );

	mov	eax, DWORD PTR _pOrigin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fFlags$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _samp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSource$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H

; 2956 : 	pfnMessageEnd();

	call	_pfnMessageEnd

; 2957 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnBuildSoundMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEngineFprintf
_TEXT	SEGMENT
_pfile$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnEngineFprintf PROC					; COMDAT

; 2942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2943 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEngineFprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnAlertMessage
_TEXT	SEGMENT
tv77 = -2380						; size = 4
_args$ = -2056						; size = 4
_buffer$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnAlertMessage PROC					; COMDAT

; 2889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2380				; 0000094cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2890 : 	char	buffer[2048];
; 2891 : 	va_list	args;
; 2892 : 
; 2893 : 	if( type == at_logged && svs.maxclients > 1 )

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN4@pfnAlertMe
	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN4@pfnAlertMe

; 2894 : 	{
; 2895 : 		va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2896 : 		Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	2048					; 00000800H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2897 : 		va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2898 : 		Log_Printf( "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Log_Printf
	add	esp, 8

; 2899 : 		return;

	jmp	$LN2@pfnAlertMe
$LN4@pfnAlertMe:

; 2900 : 	}
; 2901 : 
; 2902 : 	if( host_developer.value <= DEV_NONE )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _host_developer+12
	jb	SHORT $LN5@pfnAlertMe

; 2903 : 		return;

	jmp	$LN2@pfnAlertMe
$LN5@pfnAlertMe:

; 2904 : 
; 2905 : 	// g-cont: some mods have wrong aiconsole messages that crash the engine
; 2906 : 	if( type == at_aiconsole && host_developer.value < DEV_EXTENDED )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN6@pfnAlertMe
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN6@pfnAlertMe

; 2907 : 		return;

	jmp	$LN2@pfnAlertMe
$LN6@pfnAlertMe:

; 2908 : 
; 2909 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2910 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	2048					; 00000800H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2911 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2912 : 
; 2913 : 	// check message for pass
; 2914 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 4
	ja	SHORT $LN2@pfnAlertMe
	mov	ecx, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN13@pfnAlertMe[ecx*4]
$LN7@pfnAlertMe:

; 2915 : 	{
; 2916 : 	case at_notice:
; 2917 : 		Con_Printf( S_NOTE "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@NJFDINDI@?$FO2Note?3?$FO7?5?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2918 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN8@pfnAlertMe:

; 2919 : 	case at_console:
; 2920 : 		Con_Printf( "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2921 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN9@pfnAlertMe:

; 2922 : 	case at_aiconsole:
; 2923 : 		Con_DPrintf( "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_DPrintf
	add	esp, 8

; 2924 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN10@pfnAlertMe:

; 2925 : 	case at_warning:
; 2926 : 		Con_Printf( S_WARN "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@KNHIKLDN@?$FO3Warning?3?$FO7?5?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2927 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN11@pfnAlertMe:

; 2928 : 	case at_error:
; 2929 : 		Con_Printf( S_ERROR "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@DKJGHMGN@?$FO1Error?3?$FO7?5?$CFs@
	call	_Con_Printf
	add	esp, 8
$LN2@pfnAlertMe:

; 2930 : 		break;
; 2931 : 	}
; 2932 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@pfnAlertMe:
	DD	$LN7@pfnAlertMe
	DD	$LN8@pfnAlertMe
	DD	$LN9@pfnAlertMe
	DD	$LN10@pfnAlertMe
	DD	$LN11@pfnAlertMe
_pfnAlertMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteEntity
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteEntity PROC					; COMDAT

; 2875 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2876 : 	if( iValue < 0 || iValue >= svgame.numEntities )

	cmp	DWORD PTR _iValue$[ebp], 0
	jl	SHORT $LN3@pfnWriteEn
	mov	eax, DWORD PTR _iValue$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jl	SHORT $LN2@pfnWriteEn
$LN3@pfnWriteEn:

; 2877 : 		Host_Error( "MSG_WriteEntity: invalid entnumber %i\n", iValue );

	mov	eax, DWORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@LLHMCHCO@MSG_WriteEntity?3?5invalid?5entnum@
	call	_Host_Error
	add	esp, 8
$LN2@pfnWriteEn:

; 2878 : 	MSG_WriteShort( &sv.multicast, (short)iValue );

	movsx	eax, WORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteShort
	add	esp, 8

; 2879 : 	svgame.msg_realsize += 2;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 2
	mov	DWORD PTR _svgame+7888, eax

; 2880 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteString
_TEXT	SEGMENT
tv141 = -80						; size = 4
_dst$ = -12						; size = 4
_rem$ = -8						; size = 4
_len$ = -4						; size = 4
_src$ = 8						; size = 4
_pfnWriteString PROC					; COMDAT

; 2812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2813 : 	static char	string[MAX_USERMSG_LENGTH];
; 2814 : 	int		len = Q_strlen( src ) + 1;

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2815 : 	int		rem = rem = sizeof( string ) - 1;

	mov	DWORD PTR _rem$[ebp], 2047		; 000007ffH
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR _rem$[ebp], eax

; 2816 : 	char		*dst;
; 2817 : 
; 2818 : 	if( len == 1 )

	cmp	DWORD PTR _len$[ebp], 1
	jne	SHORT $LN4@pfnWriteSt

; 2819 : 	{
; 2820 : 		MSG_WriteChar( &sv.multicast, 0 );

	push	0
	push	OFFSET _sv+2448128
	call	_MSG_WriteChar
	add	esp, 8

; 2821 : 		svgame.msg_realsize += 1; 

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 1
	mov	DWORD PTR _svgame+7888, eax

; 2822 : 		return; // fast exit

	jmp	$LN1@pfnWriteSt
$LN4@pfnWriteSt:

; 2823 : 	}
; 2824 : 
; 2825 : 	// prepare string to sending
; 2826 : 	dst = string;

	mov	DWORD PTR _dst$[ebp], OFFSET ?string@?1??pfnWriteString@@9@9
$LN2@pfnWriteSt:

; 2827 : 
; 2828 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@pfnWriteSt

; 2829 : 	{
; 2830 : 		// some escaped chars parsed as two symbols - merge it here
; 2831 : 		if( src[0] == '\\' && src[1] == 'n' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN5@pfnWriteSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 110				; 0000006eH
	jne	SHORT $LN5@pfnWriteSt

; 2832 : 		{
; 2833 : 			*dst++ = '\n';

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dst$[ebp], ecx

; 2834 : 			src += 2;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 2
	mov	DWORD PTR _src$[ebp], eax

; 2835 : 			len -= 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2836 : 		}

	jmp	$LN6@pfnWriteSt
$LN5@pfnWriteSt:

; 2837 : 		else if( src[0] == '\\' && src[1] == 'r' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN7@pfnWriteSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 114				; 00000072H
	jne	SHORT $LN7@pfnWriteSt

; 2838 : 		{
; 2839 : 			*dst++ = '\r';

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dst$[ebp], ecx

; 2840 : 			src += 2;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 2
	mov	DWORD PTR _src$[ebp], eax

; 2841 : 			len -= 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2842 : 		}

	jmp	SHORT $LN6@pfnWriteSt
$LN7@pfnWriteSt:

; 2843 : 		else if( src[0] == '\\' && src[1] == 't' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN9@pfnWriteSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 116				; 00000074H
	jne	SHORT $LN9@pfnWriteSt

; 2844 : 		{
; 2845 : 			*dst++ = '\t';

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 9
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dst$[ebp], ecx

; 2846 : 			src += 2;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 2
	mov	DWORD PTR _src$[ebp], eax

; 2847 : 			len -= 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2848 : 		}

	jmp	SHORT $LN6@pfnWriteSt
$LN9@pfnWriteSt:

; 2849 : 		else if(( *dst++ = *src++ ) == 0 )

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _dst$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv141[ebp], ecx
	mov	edx, DWORD PTR _dst$[ebp]
	add	edx, 1
	mov	DWORD PTR _dst$[ebp], edx
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 1
	mov	DWORD PTR _src$[ebp], eax
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN6@pfnWriteSt

; 2850 : 			break;

	jmp	SHORT $LN3@pfnWriteSt
$LN6@pfnWriteSt:

; 2851 : 
; 2852 : 		if( --rem <= 0 )

	mov	eax, DWORD PTR _rem$[ebp]
	sub	eax, 1
	mov	DWORD PTR _rem$[ebp], eax
	cmp	DWORD PTR _rem$[ebp], 0
	jg	SHORT $LN12@pfnWriteSt

; 2853 : 		{
; 2854 : 			Con_Printf( S_ERROR "pfnWriteString: exceeds %i symbols\n", len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@GBHNFJCB@?$FO1Error?3?$FO7?5pfnWriteString?3?5exce@
	call	_Con_Printf
	add	esp, 8

; 2855 : 			*dst = '\0'; // string end (not included in count)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 0

; 2856 : 			len = Q_strlen( string ) + 1;

	push	OFFSET ?string@?1??pfnWriteString@@9@9
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2857 : 			break;

	jmp	SHORT $LN3@pfnWriteSt
$LN12@pfnWriteSt:

; 2858 : 		}
; 2859 : 	}

	jmp	$LN2@pfnWriteSt
$LN3@pfnWriteSt:

; 2860 : 
; 2861 : 	*dst = '\0'; // string end (not included in count)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 0

; 2862 : 	MSG_WriteString( &sv.multicast, string );

	push	OFFSET ?string@?1??pfnWriteString@@9@9
	push	OFFSET _sv+2448128
	call	_MSG_WriteString
	add	esp, 8

; 2863 : 
; 2864 : 	// NOTE: some messages with constant string length can be marked as known sized
; 2865 : 	svgame.msg_realsize += len;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _svgame+7888, eax
$LN1@pfnWriteSt:

; 2866 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteCoord
_TEXT	SEGMENT
_flValue$ = 8						; size = 4
_pfnWriteCoord PROC					; COMDAT

; 2788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2789 : 	MSG_WriteCoord( &sv.multicast, flValue );

	push	ecx
	movss	xmm0, DWORD PTR _flValue$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _sv+2448128
	call	_MSG_WriteCoord
	add	esp, 8

; 2790 : 	svgame.msg_realsize += 2;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 2
	mov	DWORD PTR _svgame+7888, eax

; 2791 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteAngle
_TEXT	SEGMENT
_iAngle$ = -4						; size = 4
_flValue$ = 8						; size = 4
_pfnWriteAngle PROC					; COMDAT

; 2774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2775 : 	int	iAngle = ((int)(( flValue ) * 256 / 360) & 255);

	movss	xmm0, DWORD PTR _flValue$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si eax, xmm0
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _iAngle$[ebp], eax

; 2776 : 
; 2777 : 	MSG_WriteChar( &sv.multicast, iAngle );

	mov	eax, DWORD PTR _iAngle$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteChar
	add	esp, 8

; 2778 : 	svgame.msg_realsize += 1;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 1
	mov	DWORD PTR _svgame+7888, eax

; 2779 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteFloat
_TEXT	SEGMENT
_flValue$ = 8						; size = 4
_pfnWriteFloat PROC					; COMDAT

; 2761 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2762 : 	MSG_WriteFloat(&sv.multicast, flValue);

	push	ecx
	movss	xmm0, DWORD PTR _flValue$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _sv+2448128
	call	_MSG_WriteFloat
	add	esp, 8

; 2763 : 	svgame.msg_realsize += 4;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 4
	mov	DWORD PTR _svgame+7888, eax

; 2764 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteFlag
_TEXT	SEGMENT
_fValue$ = 8						; size = 8
_pfnWriteFlag PROC					; COMDAT

; 2749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2750 : 	MSG_WriteFlag(&sv.multicast, fValue);

	mov	eax, DWORD PTR _fValue$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _fValue$[ebp]
	push	ecx
	push	OFFSET _sv+2448128
	call	_MSG_WriteFlag
	add	esp, 12					; 0000000cH

; 2751 : 	svgame.msg_realsize += 8;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 8
	mov	DWORD PTR _svgame+7888, eax

; 2752 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteLong
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteLong PROC					; COMDAT

; 2737 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2738 : 	MSG_WriteLong( &sv.multicast, iValue );

	mov	eax, DWORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteLong
	add	esp, 8

; 2739 : 	svgame.msg_realsize += 4;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 4
	mov	DWORD PTR _svgame+7888, eax

; 2740 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteShort
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteShort PROC					; COMDAT

; 2725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2726 : 	MSG_WriteShort( &sv.multicast, (short)iValue );

	movsx	eax, WORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteShort
	add	esp, 8

; 2727 : 	svgame.msg_realsize += 2;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 2
	mov	DWORD PTR _svgame+7888, eax

; 2728 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteChar
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteChar PROC					; COMDAT

; 2713 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2714 : 	MSG_WriteChar( &sv.multicast, (char)iValue );

	movsx	eax, BYTE PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteChar
	add	esp, 8

; 2715 : 	svgame.msg_realsize++;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 1
	mov	DWORD PTR _svgame+7888, eax

; 2716 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteByte
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteByte PROC					; COMDAT

; 2700 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2701 : 	if( iValue == -1 ) iValue = 0xFF; // convert char to byte 

	cmp	DWORD PTR _iValue$[ebp], -1
	jne	SHORT $LN2@pfnWriteBy
	mov	DWORD PTR _iValue$[ebp], 255		; 000000ffH
$LN2@pfnWriteBy:

; 2702 : 	MSG_WriteByte( &sv.multicast, (byte)iValue );

	movzx	eax, BYTE PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteByte
	add	esp, 8

; 2703 : 	svgame.msg_realsize++;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 1
	mov	DWORD PTR _svgame+7888, eax

; 2704 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnMessageEnd
_TEXT	SEGMENT
tv166 = -92						; size = 4
tv165 = -88						; size = 4
_svc_msg$1 = -20					; size = 4
_realsize$2 = -16					; size = 4
_expsize$3 = -12					; size = 4
_org$ = -8						; size = 4
_name$ = -4						; size = 4
_pfnMessageEnd PROC					; COMDAT

; 2602 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2603 : 	const char	*name = "Unknown";

	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_07NBCGADJA@Unknown@

; 2604 : 	float		*org = NULL;

	mov	DWORD PTR _org$[ebp], 0

; 2605 : 
; 2606 : 	if( svgame.msg_name ) name = svgame.msg_name;

	cmp	DWORD PTR _svgame, 0
	je	SHORT $LN2@pfnMessage
	mov	eax, DWORD PTR _svgame
	mov	DWORD PTR _name$[ebp], eax
$LN2@pfnMessage:

; 2607 : 	if( !svgame.msg_started ) Host_Error( "MessageEnd: called with no active message\n" );

	cmp	DWORD PTR _svgame+7900, 0
	jne	SHORT $LN3@pfnMessage
	push	OFFSET ??_C@_0CL@FLBHMFLG@MessageEnd?3?5called?5with?5no?5acti@
	call	_Host_Error
	add	esp, 4
$LN3@pfnMessage:

; 2608 : 	svgame.msg_started = false;

	mov	DWORD PTR _svgame+7900, 0

; 2609 : 
; 2610 : 	if( MSG_CheckOverflow( &sv.multicast ))

	push	OFFSET _sv+2448128
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@pfnMessage

; 2611 : 	{
; 2612 : 		Con_Printf( S_ERROR "MessageEnd: %s has overflow multicast buffer\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@IJHNIFDN@?$FO1Error?3?$FO7?5MessageEnd?3?5?$CFs?5has?5o@
	call	_Con_Printf
	add	esp, 8

; 2613 : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2614 : 		return;

	jmp	$LN1@pfnMessage
$LN4@pfnMessage:

; 2615 : 	}
; 2616 : 
; 2617 : 	// check for system message
; 2618 : 	if( svgame.msg_index < 0 )

	cmp	DWORD PTR _svgame+7892, 0
	jge	$LN5@pfnMessage

; 2619 : 	{
; 2620 : 		if( svgame.msg_size_index != -1 )

	cmp	DWORD PTR _svgame+7884, -1
	je	SHORT $LN7@pfnMessage

; 2621 : 		{
; 2622 : 			// variable sized message
; 2623 : 			if( svgame.msg_realsize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _svgame+7888, 2048		; 00000800H
	jle	SHORT $LN8@pfnMessage

; 2624 : 			{
; 2625 : 				Con_Printf( S_ERROR "SV_Multicast: %s too long (more than %d bytes)\n", name, MAX_USERMSG_LENGTH );

	push	2048					; 00000800H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@INOJEHEK@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5too@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2626 : 				MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2627 : 				return;

	jmp	$LN1@pfnMessage

; 2628 : 			}

	jmp	SHORT $LN10@pfnMessage
$LN8@pfnMessage:

; 2629 : 			else if( svgame.msg_realsize < 0 )

	cmp	DWORD PTR _svgame+7888, 0
	jge	SHORT $LN10@pfnMessage

; 2630 : 			{
; 2631 : 				Con_Printf( S_ERROR "SV_Multicast: %s writes NULL message\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@FEKFALM@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5wri@
	call	_Con_Printf
	add	esp, 8

; 2632 : 				MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2633 : 				return;

	jmp	$LN1@pfnMessage
$LN10@pfnMessage:

; 2634 : 			}
; 2635 : 
; 2636 : 			sv.multicast.pData[svgame.msg_size_index] = svgame.msg_realsize;

	mov	eax, DWORD PTR _sv+2448136
	add	eax, DWORD PTR _svgame+7884
	mov	cl, BYTE PTR _svgame+7888
	mov	BYTE PTR [eax], cl
$LN7@pfnMessage:

; 2637 : 		}
; 2638 : 	}

	jmp	$LN15@pfnMessage
$LN5@pfnMessage:

; 2639 : 	else if( svgame.msg[svgame.msg_index].size != -1 )

	imul	eax, DWORD PTR _svgame+7892, 40
	cmp	DWORD PTR _svgame[eax+40], -1
	je	SHORT $LN11@pfnMessage

; 2640 : 	{
; 2641 : 		int	expsize = svgame.msg[svgame.msg_index].size;

	imul	eax, DWORD PTR _svgame+7892, 40
	mov	ecx, DWORD PTR _svgame[eax+40]
	mov	DWORD PTR _expsize$3[ebp], ecx

; 2642 : 		int	realsize = svgame.msg_realsize;

	mov	eax, DWORD PTR _svgame+7888
	mov	DWORD PTR _realsize$2[ebp], eax

; 2643 : 	
; 2644 : 		// compare sizes
; 2645 : 		if( expsize != realsize )

	mov	eax, DWORD PTR _expsize$3[ebp]
	cmp	eax, DWORD PTR _realsize$2[ebp]
	je	SHORT $LN13@pfnMessage

; 2646 : 		{
; 2647 : 			Con_Printf( S_ERROR "SV_Multicast: %s expected %i bytes, it written %i. Ignored.\n", name, expsize, realsize );

	mov	eax, DWORD PTR _realsize$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _expsize$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0EI@JEOGGFON@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5exp@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 2648 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2649 : 			return;

	jmp	$LN1@pfnMessage
$LN13@pfnMessage:

; 2650 : 		}
; 2651 : 	}

	jmp	$LN15@pfnMessage
$LN11@pfnMessage:

; 2652 : 	else if( svgame.msg_size_index != -1 )

	cmp	DWORD PTR _svgame+7884, -1
	je	SHORT $LN14@pfnMessage

; 2653 : 	{
; 2654 : 		// variable sized message
; 2655 : 		if( svgame.msg_realsize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _svgame+7888, 2048		; 00000800H
	jle	SHORT $LN16@pfnMessage

; 2656 : 		{
; 2657 : 			Con_Printf( S_ERROR "SV_Multicast: %s too long (more than %d bytes)\n", name, MAX_USERMSG_LENGTH );

	push	2048					; 00000800H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@INOJEHEK@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5too@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2658 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2659 : 			return;

	jmp	$LN1@pfnMessage

; 2660 : 		}

	jmp	SHORT $LN18@pfnMessage
$LN16@pfnMessage:

; 2661 : 		else if( svgame.msg_realsize < 0 )

	cmp	DWORD PTR _svgame+7888, 0
	jge	SHORT $LN18@pfnMessage

; 2662 : 		{
; 2663 : 			Con_Printf( S_ERROR "SV_Multicast: %s writes NULL message\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@FEKFALM@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5wri@
	call	_Con_Printf
	add	esp, 8

; 2664 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2665 : 			return;

	jmp	$LN1@pfnMessage
$LN18@pfnMessage:

; 2666 : 		}
; 2667 : 
; 2668 : 		*(word *)&sv.multicast.pData[svgame.msg_size_index] = svgame.msg_realsize;

	mov	eax, DWORD PTR _sv+2448136
	add	eax, DWORD PTR _svgame+7884
	mov	cx, WORD PTR _svgame+7888
	mov	WORD PTR [eax], cx

; 2669 : 	}

	jmp	SHORT $LN15@pfnMessage
$LN14@pfnMessage:

; 2670 : 	else
; 2671 : 	{
; 2672 : 		// this should never happen
; 2673 : 		Con_Printf( S_ERROR "SV_Multicast: %s have encountered error\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@PHIMGBJI@?$FO1Error?3?$FO7?5SV_Multicast?3?5?$CFs?5hav@
	call	_Con_Printf
	add	esp, 8

; 2674 : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 2675 : 		return;

	jmp	$LN1@pfnMessage
$LN15@pfnMessage:

; 2676 : 	}
; 2677 : 
; 2678 : 	// update some messages in case their was format was changed and we want to keep backward compatibility
; 2679 : 	if( svgame.msg_index < 0 )

	cmp	DWORD PTR _svgame+7892, 0
	jge	SHORT $LN20@pfnMessage

; 2680 : 	{
; 2681 : 		int	svc_msg = abs( svgame.msg_index );

	mov	eax, DWORD PTR _svgame+7892
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _svc_msg$1[ebp], eax

; 2682 : 
; 2683 : 		if(( svc_msg == svc_finale || svc_msg == svc_cutscene ) && svgame.msg_realsize == 0 )

	cmp	DWORD PTR _svc_msg$1[ebp], 31		; 0000001fH
	je	SHORT $LN21@pfnMessage
	cmp	DWORD PTR _svc_msg$1[ebp], 34		; 00000022H
	jne	SHORT $LN20@pfnMessage
$LN21@pfnMessage:
	cmp	DWORD PTR _svgame+7888, 0
	jne	SHORT $LN20@pfnMessage

; 2684 : 			MSG_WriteChar( &sv.multicast, 0 ); // write null string

	push	0
	push	OFFSET _sv+2448128
	call	_MSG_WriteChar
	add	esp, 8
$LN20@pfnMessage:

; 2685 : 	}
; 2686 : 
; 2687 : 	if( !VectorIsNull( svgame.msg_org )) org = svgame.msg_org;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _svgame[ecx+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@pfnMessage
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _svgame[eax+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@pfnMessage
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _svgame[eax+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@pfnMessage
$LN23@pfnMessage:
	mov	DWORD PTR _org$[ebp], OFFSET _svgame+7908
$LN22@pfnMessage:

; 2688 : 	svgame.msg_dest = bound( MSG_BROADCAST, svgame.msg_dest, MSG_SPEC );

	cmp	DWORD PTR _svgame+7896, 0
	jl	SHORT $LN27@pfnMessage
	cmp	DWORD PTR _svgame+7896, 9
	jge	SHORT $LN25@pfnMessage
	mov	eax, DWORD PTR _svgame+7896
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN26@pfnMessage
$LN25@pfnMessage:
	mov	DWORD PTR tv165[ebp], 9
$LN26@pfnMessage:
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	jmp	SHORT $LN28@pfnMessage
$LN27@pfnMessage:
	mov	DWORD PTR tv166[ebp], 0
$LN28@pfnMessage:
	mov	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR _svgame+7896, edx

; 2689 : 
; 2690 : 	SV_Multicast( svgame.msg_dest, org, svgame.msg_ent, true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _svgame+7904
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+7896
	push	edx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN1@pfnMessage:

; 2691 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMessageEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnMessageBegin
_TEXT	SEGMENT
tv70 = -80						; size = 4
tv69 = -76						; size = 4
_iSize$ = -8						; size = 4
_i$ = -4						; size = 4
_msg_dest$ = 8						; size = 4
_msg_num$ = 12						; size = 4
_pOrigin$ = 16						; size = 4
_ed$ = 20						; size = 4
_pfnMessageBegin PROC					; COMDAT

; 2537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2538 : 	int	i, iSize;
; 2539 : 
; 2540 : 	if( svgame.msg_started )

	cmp	DWORD PTR _svgame+7900, 0
	je	SHORT $LN5@pfnMessage

; 2541 : 		Host_Error( "MessageBegin: New message started when msg '%s' has not been sent yet\n", svgame.msg_name );

	mov	eax, DWORD PTR _svgame
	push	eax
	push	OFFSET ??_C@_0EH@HCPBMJBO@MessageBegin?3?5New?5message?5start@
	call	_Host_Error
	add	esp, 8
$LN5@pfnMessage:

; 2542 : 	svgame.msg_started = true;

	mov	DWORD PTR _svgame+7900, 1

; 2543 : 
; 2544 : 	// check range
; 2545 : 	msg_num = bound( svc_bad, msg_num, 255 );

	cmp	DWORD PTR _msg_num$[ebp], 0
	jl	SHORT $LN19@pfnMessage
	cmp	DWORD PTR _msg_num$[ebp], 255		; 000000ffH
	jge	SHORT $LN17@pfnMessage
	mov	eax, DWORD PTR _msg_num$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN18@pfnMessage
$LN17@pfnMessage:
	mov	DWORD PTR tv69[ebp], 255		; 000000ffH
$LN18@pfnMessage:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN20@pfnMessage
$LN19@pfnMessage:
	mov	DWORD PTR tv70[ebp], 0
$LN20@pfnMessage:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _msg_num$[ebp], edx

; 2546 : 
; 2547 : 	if( msg_num <= svc_lastmsg )

	cmp	DWORD PTR _msg_num$[ebp], 58		; 0000003aH
	jg	SHORT $LN6@pfnMessage

; 2548 : 	{
; 2549 : 		svgame.msg_index = -msg_num; // this is a system message

	mov	eax, DWORD PTR _msg_num$[ebp]
	neg	eax
	mov	DWORD PTR _svgame+7892, eax

; 2550 : 		svgame.msg_name = svc_strings[msg_num];

	mov	eax, DWORD PTR _msg_num$[ebp]
	mov	ecx, DWORD PTR _svc_strings[eax*4]
	mov	DWORD PTR _svgame, ecx

; 2551 : 
; 2552 : 		if( msg_num == svc_temp_entity )

	cmp	DWORD PTR _msg_num$[ebp], 23		; 00000017H
	jne	SHORT $LN8@pfnMessage

; 2553 : 			iSize = -1; // temp entity have variable size

	mov	DWORD PTR _iSize$[ebp], -1
	jmp	SHORT $LN9@pfnMessage
$LN8@pfnMessage:

; 2554 : 		else iSize = 0;

	mov	DWORD PTR _iSize$[ebp], 0
$LN9@pfnMessage:

; 2555 : 	}

	jmp	$LN7@pfnMessage
$LN6@pfnMessage:

; 2556 : 	else
; 2557 : 	{
; 2558 : 		// check for existing
; 2559 : 		for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnMessage
$LN2@pfnMessage:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnMessage:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnMessage
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _svgame[eax+edx+4]
	test	eax, eax
	je	SHORT $LN3@pfnMessage

; 2560 : 		{
; 2561 : 			if( svgame.msg[i].number == msg_num )

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _svgame[eax+36]
	cmp	ecx, DWORD PTR _msg_num$[ebp]
	jne	SHORT $LN10@pfnMessage

; 2562 : 				break; // found

	jmp	SHORT $LN3@pfnMessage
$LN10@pfnMessage:

; 2563 : 		}

	jmp	SHORT $LN2@pfnMessage
$LN3@pfnMessage:

; 2564 : 
; 2565 : 		if( i == MAX_USER_MESSAGES )

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN11@pfnMessage

; 2566 : 		{
; 2567 : 			Host_Error( "MessageBegin: tried to send unregistered message %i\n", msg_num );

	mov	eax, DWORD PTR _msg_num$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@DGIJNFM@MessageBegin?3?5tried?5to?5send?5unr@
	call	_Host_Error
	add	esp, 8

; 2568 : 			return;

	jmp	$LN1@pfnMessage
$LN11@pfnMessage:

; 2569 : 		}
; 2570 : 
; 2571 : 		svgame.msg_name = svgame.msg[i].name;

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	mov	DWORD PTR _svgame, eax

; 2572 : 		iSize = svgame.msg[i].size;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _svgame[eax+40]
	mov	DWORD PTR _iSize$[ebp], ecx

; 2573 : 		svgame.msg_index = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _svgame+7892, eax
$LN7@pfnMessage:

; 2574 : 	}
; 2575 : 
; 2576 : 	MSG_WriteCmdExt( &sv.multicast, msg_num, NS_SERVER, svgame.msg_name );

	mov	eax, DWORD PTR _svgame
	push	eax
	push	1
	mov	ecx, DWORD PTR _msg_num$[ebp]
	push	ecx
	push	OFFSET _sv+2448128
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2577 : 
; 2578 : 	// save message destination
; 2579 : 	if( pOrigin ) VectorCopy( pOrigin, svgame.msg_org );

	cmp	DWORD PTR _pOrigin$[ebp], 0
	je	SHORT $LN12@pfnMessage
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pOrigin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _svgame[eax+7908], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _svgame[eax+7908], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pOrigin$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _svgame[ecx+7908], eax
	jmp	SHORT $LN13@pfnMessage
$LN12@pfnMessage:

; 2580 : 	else VectorClear( svgame.msg_org );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[eax+7908], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[ecx+7908], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[eax+7908], xmm0
$LN13@pfnMessage:

; 2581 : 
; 2582 : 	if( iSize == -1 )

	cmp	DWORD PTR _iSize$[ebp], -1
	jne	SHORT $LN14@pfnMessage

; 2583 : 	{
; 2584 : 		// variable sized messages sent size as first short
; 2585 : 		svgame.msg_size_index = MSG_GetNumBytesWritten( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _svgame+7884, eax

; 2586 : 		MSG_WriteWord( &sv.multicast, 0 ); // reserve space for now

	push	0
	push	OFFSET _sv+2448128
	call	_MSG_WriteWord
	add	esp, 8

; 2587 : 	}

	jmp	SHORT $LN15@pfnMessage
$LN14@pfnMessage:

; 2588 : 	else svgame.msg_size_index = -1; // message has constant size

	mov	DWORD PTR _svgame+7884, -1
$LN15@pfnMessage:

; 2589 : 
; 2590 : 	svgame.msg_realsize = 0;

	mov	DWORD PTR _svgame+7888, 0

; 2591 : 	svgame.msg_dest = msg_dest;

	mov	eax, DWORD PTR _msg_dest$[ebp]
	mov	DWORD PTR _svgame+7896, eax

; 2592 : 	svgame.msg_ent = ed;

	mov	eax, DWORD PTR _ed$[ebp]
	mov	DWORD PTR _svgame+7904, eax
$LN1@pfnMessage:

; 2593 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMessageBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnLightStyle
_TEXT	SEGMENT
_style$ = 8						; size = 4
_val$ = 12						; size = 4
_pfnLightStyle PROC					; COMDAT

; 2498 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2499 : 	if( style < 0 ) style = 0;

	cmp	DWORD PTR _style$[ebp], 0
	jge	SHORT $LN2@pfnLightSt
	mov	DWORD PTR _style$[ebp], 0
$LN2@pfnLightSt:

; 2500 : 	if( style >= MAX_LIGHTSTYLES )

	cmp	DWORD PTR _style$[ebp], 64		; 00000040H
	jl	SHORT $LN3@pfnLightSt

; 2501 : 		Host_Error( "SV_LightStyle: style: %i >= %d", style, MAX_LIGHTSTYLES );

	push	64					; 00000040H
	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@JJDAPFDH@SV_LightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5?$CFd@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN3@pfnLightSt:

; 2502 : 	if( sv.loadgame ) return; // don't let the world overwrite our restored styles

	cmp	DWORD PTR _sv+8, 0
	je	SHORT $LN4@pfnLightSt
	jmp	SHORT $LN1@pfnLightSt
$LN4@pfnLightSt:

; 2503 : 
; 2504 : 	SV_SetLightStyle( style, val, 0.0f ); // set correct style

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _style$[ebp]
	push	ecx
	call	_SV_SetLightStyle
	add	esp, 12					; 0000000cH
$LN1@pfnLightSt:

; 2505 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnParticleEffect
_TEXT	SEGMENT
tv158 = -76						; size = 4
tv139 = -76						; size = 4
tv88 = -76						; size = 4
tv157 = -72						; size = 4
tv138 = -72						; size = 4
tv87 = -72						; size = 4
_v$ = -4						; size = 4
_org$ = 8						; size = 4
_dir$ = 12						; size = 4
_color$ = 16						; size = 4
_count$ = 20						; size = 4
_pfnParticleEffect PROC					; COMDAT

; 2472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2473 : 	int	v;
; 2474 : 
; 2475 : 	if( MSG_GetNumBytesLeft( &sv.datagram ) < 16 )

	push	OFFSET _sv+2415320
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN2@pfnParticl

; 2476 : 		return;

	jmp	$LN1@pfnParticl
$LN2@pfnParticl:

; 2477 : 
; 2478 : 	MSG_BeginServerCmd( &sv.datagram, svc_particle );

	push	0
	push	1
	push	18					; 00000012H
	push	OFFSET _sv+2415320
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2479 : 	MSG_WriteVec3Coord( &sv.datagram, org );

	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 2480 : 	v = bound( -128, dir[0] * 16.0f, 127 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN6@pfnParticl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@pfnParticl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN5@pfnParticl
$LN4@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv87[ebp], xmm0
$LN5@pfnParticl:
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN7@pfnParticl
$LN6@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv88[ebp], xmm0
$LN7@pfnParticl:
	cvttss2si eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2481 : 	MSG_WriteChar( &sv.datagram, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteChar
	add	esp, 8

; 2482 : 	v = bound( -128, dir[1] * 16.0f, 127 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN10@pfnParticl
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@pfnParticl
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv138[ebp], xmm0
	jmp	SHORT $LN9@pfnParticl
$LN8@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv138[ebp], xmm0
$LN9@pfnParticl:
	movss	xmm0, DWORD PTR tv138[ebp]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN11@pfnParticl
$LN10@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv139[ebp], xmm0
$LN11@pfnParticl:
	cvttss2si eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2483 : 	MSG_WriteChar( &sv.datagram, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteChar
	add	esp, 8

; 2484 : 	v = bound( -128, dir[2] * 16.0f, 127 );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN14@pfnParticl
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@pfnParticl
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv157[ebp], xmm0
	jmp	SHORT $LN13@pfnParticl
$LN12@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv157[ebp], xmm0
$LN13@pfnParticl:
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN15@pfnParticl
$LN14@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv158[ebp], xmm0
$LN15@pfnParticl:
	cvttss2si eax, DWORD PTR tv158[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2485 : 	MSG_WriteChar( &sv.datagram, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteChar
	add	esp, 8

; 2486 : 	MSG_WriteByte( &sv.datagram, count );

	cvttss2si eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteByte
	add	esp, 8

; 2487 : 	MSG_WriteByte( &sv.datagram, color );

	cvttss2si eax, DWORD PTR _color$[ebp]
	push	eax
	push	OFFSET _sv+2415320
	call	_MSG_WriteByte
	add	esp, 8

; 2488 : 	MSG_WriteByte( &sv.datagram, 0 ); // z-vel

	push	0
	push	OFFSET _sv+2415320
	call	_MSG_WriteByte
	add	esp, 8
$LN1@pfnParticl:

; 2489 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnParticleEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnClientCommand
_TEXT	SEGMENT
_args$ = -268						; size = 4
_buffer$ = -264						; size = 256
_cl$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnClientCommand PROC					; COMDAT

; 2435 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2436 : 	sv_client_t	*cl;
; 2437 : 	string		buffer;
; 2438 : 	va_list		args;
; 2439 : 
; 2440 : 	if( sv.state != ss_active )

	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@pfnClientC

; 2441 : 		return; // early out

	jmp	$LN1@pfnClientC
$LN2@pfnClientC:

; 2442 : 
; 2443 : 	if(( cl = SV_ClientFromEdict( pEdict, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN3@pfnClientC

; 2444 : 	{
; 2445 : 		Con_Printf( S_ERROR "stuffcmd: client is not spawned!\n" );

	push	OFFSET ??_C@_0CN@FJFCNMMM@?$FO1Error?3?$FO7?5stuffcmd?3?5client?5is?5@
	call	_Con_Printf
	add	esp, 4

; 2446 : 		return;

	jmp	$LN1@pfnClientC
$LN3@pfnClientC:

; 2447 : 	}
; 2448 : 
; 2449 : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN4@pfnClientC

; 2450 : 		return;

	jmp	$LN1@pfnClientC
$LN4@pfnClientC:

; 2451 : 
; 2452 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2453 : 	Q_vsnprintf( buffer, MAX_STRING, szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2454 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2455 : 
; 2456 : 	if( SV_IsValidCmd( buffer ))

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_SV_IsValidCmd
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@pfnClientC

; 2457 : 	{
; 2458 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_stufftext );

	push	0
	push	1
	push	9
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2459 : 		MSG_WriteString( &cl->netchan.message, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2460 : 	}

	jmp	SHORT $LN1@pfnClientC
$LN5@pfnClientC:

; 2461 : 	else Con_Printf( S_ERROR "Tried to stuff bad command %s\n", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@EAGFDIFF@?$FO1Error?3?$FO7?5Tried?5to?5stuff?5bad?5c@
	call	_Con_Printf
	add	esp, 8
$LN1@pfnClientC:

; 2462 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnServerExecute
_TEXT	SEGMENT
_pfnServerExecute PROC					; COMDAT

; 2409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2410 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 2411 : 
; 2412 : 	if( svgame.config_executed )

	cmp	DWORD PTR _svgame+7924, 0
	je	SHORT $LN2@pfnServerE

; 2413 : 		return;

	jmp	SHORT $LN1@pfnServerE
$LN2@pfnServerE:

; 2414 : 
; 2415 : 	// here we restore arhcived cvars only from game.dll
; 2416 : 	host.apply_game_config = true;

	mov	DWORD PTR _host+34388, 1

; 2417 : 	Cbuf_AddText( "exec config.cfg\n" );

	push	OFFSET ??_C@_0BB@JIFJKOMC@exec?5config?4cfg?6@
	call	_Cbuf_AddText
	add	esp, 4

; 2418 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 2419 : 
; 2420 : 	if( host.sv_cvars_restored > 0 )

	cmp	DWORD PTR _host+34404, 0
	jle	SHORT $LN3@pfnServerE

; 2421 : 		Con_Reportf( "server executing ^2config.cfg^7 (%i cvars)\n", host.sv_cvars_restored );

	mov	eax, DWORD PTR _host+34404
	push	eax
	push	OFFSET ??_C@_0CM@OAOLJEAF@server?5executing?5?$FO2config?4cfg?$FO7@
	call	_Con_Reportf
	add	esp, 8
$LN3@pfnServerE:

; 2422 : 
; 2423 : 	host.apply_game_config = false;

	mov	DWORD PTR _host+34388, 0

; 2424 : 	svgame.config_executed = true;

	mov	DWORD PTR _svgame+7924, 1

; 2425 : 	host.sv_cvars_restored = 0;

	mov	DWORD PTR _host+34404, 0
$LN1@pfnServerE:

; 2426 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnServerCommand
_TEXT	SEGMENT
_str$ = 8						; size = 4
_pfnServerCommand PROC					; COMDAT

; 2396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2397 : 	if( !SV_IsValidCmd( str ))

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_SV_IsValidCmd
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 2398 : 		Con_Printf( S_ERROR "bad server command %s\n", str );

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@INNNGHJO@?$FO1Error?3?$FO7?5bad?5server?5command?5?$CF@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 2399 : 	else Cbuf_AddText( str );

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4
$LN1@pfnServerC:

; 2400 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetAimVector
_TEXT	SEGMENT
tv286 = -312						; size = 4
tv197 = -312						; size = 4
tv158 = -312						; size = 4
$T1 = -308						; size = 56
$T2 = -252						; size = 56
_ilength$3 = -132					; size = 4
_tr$ = -128						; size = 56
_j$ = -72						; size = 4
_i$ = -68						; size = 4
_bestdist$ = -64					; size = 4
_dist$ = -60						; size = 4
_bestdir$ = -56						; size = 12
_end$ = -44						; size = 12
_dir$ = -32						; size = 12
_start$ = -20						; size = 12
_check$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_speed$ = 12						; size = 4
_rgflReturn$ = 16					; size = 4
_pfnGetAimVector PROC					; COMDAT

; 2323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2324 : 	edict_t		*check;
; 2325 : 	vec3_t		start, dir, end, bestdir;
; 2326 : 	float		dist, bestdist;
; 2327 : 	int		i, j;
; 2328 : 	trace_t		tr;
; 2329 : 
; 2330 : 	VectorCopy( svgame.globals->v_forward, rgflReturn );	// assume failure if it returns early

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [esi+ecx+40]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19268
	mov	edx, DWORD PTR [esi+edx+40]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19268
	mov	eax, DWORD PTR [esi+eax+40]
	mov	DWORD PTR [edx+ecx], eax

; 2331 : 
; 2332 : 	if( !SV_IsValidEdict( ent ) || FBitSet( ent->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetAimVector@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN8@pfnGetAimV
$LN9@pfnGetAimV:

; 2333 : 		return;

	jmp	$LN1@pfnGetAimV
$LN8@pfnGetAimV:

; 2334 : 
; 2335 : 	VectorCopy( ent->v.origin, start );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _start$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _start$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _start$[ebp+ecx], eax

; 2336 : 	VectorAdd( start, ent->v.view_ofs, start );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+608]
	movss	DWORD PTR tv158[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR _start$[ebp+eax], xmm0

; 2337 : 
; 2338 : 	// try sending a trace straight
; 2339 : 	VectorCopy( svgame.globals->v_forward, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _dir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19268
	mov	edx, DWORD PTR [ecx+edx+40]
	mov	DWORD PTR _dir$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19268
	mov	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _dir$[ebp+ecx], eax

; 2340 : 	VectorMA( start, 2048, dir, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+eax]
	addss	xmm0, DWORD PTR _start$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+ecx]
	addss	xmm0, DWORD PTR _start$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+ecx]
	movss	xmm1, DWORD PTR _start$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv197[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv197[ebp]
	movss	DWORD PTR _end$[ebp+edx], xmm0

; 2341 : 	tr = SV_Move( start, vec3_origin, vec3_origin, end, MOVE_NORMAL, ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2342 : 
; 2343 : 	// don't aim at teammate
; 2344 : 	if( tr.ent && ( tr.ent->v.takedamage == DAMAGE_AIM || ent->v.team <= 0 || ent->v.team != tr.ent->v.team ))

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	SHORT $LN10@pfnGetAimV
	mov	eax, DWORD PTR _tr$[ebp+48]
	movss	xmm0, DWORD PTR [eax+600]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+664], 0
	jle	SHORT $LN11@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _tr$[ebp+48]
	mov	edx, DWORD PTR [eax+664]
	cmp	edx, DWORD PTR [ecx+664]
	je	SHORT $LN10@pfnGetAimV
$LN11@pfnGetAimV:

; 2345 : 		return;

	jmp	$LN1@pfnGetAimV
$LN10@pfnGetAimV:

; 2346 : 
; 2347 : 	// try all possible entities
; 2348 : 	VectorCopy( svgame.globals->v_forward, bestdir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _bestdir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19268
	mov	edx, DWORD PTR [ecx+edx+40]
	mov	DWORD PTR _bestdir$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19268
	mov	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _bestdir$[ebp+ecx], eax

; 2349 : 	bestdist = Cvar_VariableValue( "sv_aim" );

	push	OFFSET ??_C@_06MMOECJNC@sv_aim@
	call	_Cvar_VariableValue
	add	esp, 4
	fstp	DWORD PTR _bestdist$[ebp]

; 2350 : 
; 2351 : 	check = EDICT_NUM( 1 ); // start at first client

	push	1
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 2352 : 	for( i = 1; i < svgame.numEntities; i++, check++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnGetAimV
$LN2@pfnGetAimV:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 900				; 00000384H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@pfnGetAimV:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@pfnGetAimV

; 2353 : 	{
; 2354 : 		if( check->v.takedamage != DAMAGE_AIM )

	mov	eax, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [eax+600]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@pfnGetAimV

; 2355 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN12@pfnGetAimV:

; 2356 : 
; 2357 : 		if( FBitSet( check->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN13@pfnGetAimV

; 2358 :       			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN13@pfnGetAimV:

; 2359 : 
; 2360 : 		if( ent->v.team > 0 && ent->v.team == check->v.team )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+664], 0
	jle	SHORT $LN14@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [eax+664]
	cmp	edx, DWORD PTR [ecx+664]
	jne	SHORT $LN14@pfnGetAimV

; 2361 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN14@pfnGetAimV:

; 2362 : 
; 2363 : 		if( check == ent )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _ent$[ebp]
	jne	SHORT $LN15@pfnGetAimV

; 2364 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN15@pfnGetAimV:

; 2365 : 
; 2366 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@pfnGetAimV
$LN5@pfnGetAimV:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@pfnGetAimV:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@pfnGetAimV

; 2367 : 			end[j] = check->v.origin[j] + 0.5f * (check->v.mins[j] + check->v.maxs[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+352]
	addss	xmm0, DWORD PTR [esi+edx*4+364]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4+136]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end$[ebp+edx*4], xmm0
	jmp	SHORT $LN5@pfnGetAimV
$LN6@pfnGetAimV:

; 2368 : 
; 2369 : 		VectorSubtract( end, start, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _end$[ebp+ecx]
	subss	xmm0, DWORD PTR _start$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _end$[ebp+eax]
	subss	xmm0, DWORD PTR _start$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _end$[ebp+eax]
	subss	xmm0, DWORD PTR _start$[ebp+ecx]
	movss	DWORD PTR tv286[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv286[ebp]
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 2370 : 		VectorNormalize( dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _dir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR _dir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@pfnGetAimV
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN16@pfnGetAimV:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 2371 : 		dist = DotProduct( dir, svgame.globals->v_forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax+40]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _svgame+19268
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+40]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19268
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+40]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 2372 : 
; 2373 : 		if( dist < bestdist )

	movss	xmm0, DWORD PTR _bestdist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN17@pfnGetAimV

; 2374 : 			continue; // to far to turn

	jmp	$LN2@pfnGetAimV
$LN17@pfnGetAimV:

; 2375 : 
; 2376 : 		tr = SV_Move( start, vec3_origin, vec3_origin, end, MOVE_NORMAL, ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2377 : 
; 2378 : 		if( tr.ent == check )

	mov	eax, DWORD PTR _tr$[ebp+48]
	cmp	eax, DWORD PTR _check$[ebp]
	jne	SHORT $LN18@pfnGetAimV

; 2379 : 		{	
; 2380 : 			// can shoot at this one
; 2381 : 			VectorCopy( dir, bestdir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR _bestdir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR _bestdir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR _bestdir$[ebp+eax], ecx

; 2382 : 			bestdist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _bestdist$[ebp], xmm0
$LN18@pfnGetAimV:

; 2383 : 		}
; 2384 : 	}

	jmp	$LN2@pfnGetAimV
$LN3@pfnGetAimV:

; 2385 : 
; 2386 : 	VectorCopy( bestdir, rgflReturn );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	ecx, DWORD PTR _bestdir$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rgflReturn$[ebp]
	mov	edx, DWORD PTR _bestdir$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	eax, DWORD PTR _bestdir$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
$LN1@pfnGetAimV:

; 2387 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetAimVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceSphere
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_radius$ = 20						; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceSphere PROC					; COMDAT

; 2312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSphere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceTexture
_TEXT	SEGMENT
_pTextureEntity$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_pfnTraceTexture PROC					; COMDAT

; 2297 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2298 : 	if( !SV_IsValidEdict( pTextureEntity ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnTraceTexture@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pTextureEntity$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceTe

; 2299 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 2300 : 
; 2301 : 	return SV_TraceTexture( pTextureEntity, v1, v2 );

	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTextureEntity$[ebp]
	push	edx
	call	_SV_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 2302 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceModel
_TEXT	SEGMENT
_oldsolid$1 = -80					; size = 4
_oldmovetype$2 = -76					; size = 4
_trace$ = -72						; size = 56
_model$ = -16						; size = 4
_maxs$ = -12						; size = 4
_mins$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_hullNumber$ = 16					; size = 4
_pent$ = 20						; size = 4
_ptr$ = 24						; size = 4
_pfnTraceModel PROC					; COMDAT

; 2248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2249 : 	float	*mins, *maxs;
; 2250 : 	model_t	*model;
; 2251 : 	trace_t	trace;
; 2252 : 
; 2253 : 	if( !SV_IsValidEdict( pent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnTraceModel@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceMo

; 2254 : 		return;

	jmp	$LN1@pfnTraceMo
$LN2@pfnTraceMo:

; 2255 : 
; 2256 : 	if( hullNumber < 0 || hullNumber > 3 )

	cmp	DWORD PTR _hullNumber$[ebp], 0
	jl	SHORT $LN4@pfnTraceMo
	cmp	DWORD PTR _hullNumber$[ebp], 3
	jle	SHORT $LN3@pfnTraceMo
$LN4@pfnTraceMo:

; 2257 : 		hullNumber = 0;

	mov	DWORD PTR _hullNumber$[ebp], 0
$LN3@pfnTraceMo:

; 2258 : 
; 2259 : 	mins = sv.worldmodel->hulls[hullNumber].clip_mins;

	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+2595644
	lea	edx, DWORD PTR [ecx+eax+224]
	mov	DWORD PTR _mins$[ebp], edx

; 2260 : 	maxs = sv.worldmodel->hulls[hullNumber].clip_maxs;

	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+2595644
	lea	edx, DWORD PTR [ecx+eax+236]
	mov	DWORD PTR _maxs$[ebp], edx

; 2261 : 	model = SV_ModelHandle( pent->v.modelindex );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 2262 : 
; 2263 : 	if( pent->v.solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+400], 5
	jne	SHORT $LN5@pfnTraceMo

; 2264 : 	{
; 2265 : 		// NOTE: always goes through custom clipping move
; 2266 : 		// even if our callbacks is not initialized
; 2267 : 		SV_CustomClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_CustomClipMoveToEntity
	add	esp, 24					; 00000018H

; 2268 : 	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 2269 : 	else if( model && model->type == mod_brush )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN7@pfnTraceMo
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN7@pfnTraceMo

; 2270 : 	{
; 2271 : 		int oldmovetype = pent->v.movetype;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR _oldmovetype$2[ebp], ecx

; 2272 : 		int oldsolid = pent->v.solid;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _oldsolid$1[ebp], ecx

; 2273 : 		pent->v.movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+396], 7

; 2274 : 		pent->v.solid = SOLID_BSP;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+400], 4

; 2275 : 
; 2276 :       		SV_ClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H

; 2277 : 
; 2278 : 		pent->v.movetype = oldmovetype;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR _oldmovetype$2[ebp]
	mov	DWORD PTR [eax+396], ecx

; 2279 : 		pent->v.solid = oldsolid;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR _oldsolid$1[ebp]
	mov	DWORD PTR [eax+400], ecx

; 2280 : 	}

	jmp	SHORT $LN6@pfnTraceMo
$LN7@pfnTraceMo:

; 2281 : 	else
; 2282 : 	{
; 2283 :       		SV_ClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H
$LN6@pfnTraceMo:

; 2284 : 	}
; 2285 : 
; 2286 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8
$LN1@pfnTraceMo:

; 2287 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceMonsterHull
_TEXT	SEGMENT
tv73 = -188						; size = 4
$T1 = -184						; size = 56
_trace$ = -64						; size = 56
_monsterClip$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_fNoMonsters$ = 20					; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceMonsterHull PROC				; COMDAT

; 2225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2226 : 	qboolean	monsterClip;
; 2227 : 	trace_t	trace;
; 2228 : 
; 2229 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnTraceMonsterHull@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceMo

; 2230 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnTraceMo
$LN2@pfnTraceMo:

; 2231 : 
; 2232 : 	monsterClip = FBitSet( pEdict->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN6@pfnTraceMo
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN7@pfnTraceMo
$LN6@pfnTraceMo:
	mov	DWORD PTR tv73[ebp], 0
$LN7@pfnTraceMo:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 2233 : 	trace = SV_Move( v1, pEdict->v.mins, pEdict->v.maxs, v2, fNoMonsters, pentToSkip, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pentToSkip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fNoMonsters$[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	add	ecx, 364				; 0000016cH
	push	ecx
	mov	edx, DWORD PTR _pEdict$[ebp]
	add	edx, 352				; 00000160H
	push	edx
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2234 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8

; 2235 : 
; 2236 : 	if( trace.allsolid || trace.fraction != 1.0f )

	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN4@pfnTraceMo
	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@pfnTraceMo
$LN4@pfnTraceMo:

; 2237 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnTraceMo
$LN3@pfnTraceMo:

; 2238 : 	return false;

	xor	eax, eax
$LN1@pfnTraceMo:

; 2239 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceMonsterHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceHull
_TEXT	SEGMENT
$T1 = -180						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_hullNumber$ = 20					; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceHull PROC					; COMDAT

; 2208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2209 : 	trace_t	trace;
; 2210 : 
; 2211 : 	if( hullNumber < 0 || hullNumber > 3 )

	cmp	DWORD PTR _hullNumber$[ebp], 0
	jl	SHORT $LN3@pfnTraceHu
	cmp	DWORD PTR _hullNumber$[ebp], 3
	jle	SHORT $LN2@pfnTraceHu
$LN3@pfnTraceHu:

; 2212 : 		hullNumber = 0;

	mov	DWORD PTR _hullNumber$[ebp], 0
$LN2@pfnTraceHu:

; 2213 : 
; 2214 : 	trace = SV_Move( v1, sv.worldmodel->hulls[hullNumber].clip_mins, sv.worldmodel->hulls[hullNumber].clip_maxs, v2, fNoMonsters, pentToSkip, false );

	push	0
	mov	eax, DWORD PTR _pentToSkip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fNoMonsters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+2595644
	lea	edx, DWORD PTR [ecx+eax+236]
	push	edx
	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+2595644
	lea	edx, DWORD PTR [ecx+eax+224]
	push	edx
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2215 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8

; 2216 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceToss
_TEXT	SEGMENT
$T1 = -180						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_pentToIgnore$ = 12					; size = 4
_ptr$ = 16						; size = 4
_pfnTraceToss PROC					; COMDAT

; 2191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2192 : 	trace_t	trace;
; 2193 : 
; 2194 : 	if( !SV_IsValidEdict( pent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnTraceToss@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceTo

; 2195 : 		return;

	jmp	SHORT $LN1@pfnTraceTo
$LN2@pfnTraceTo:

; 2196 : 
; 2197 : 	trace = SV_MoveToss( pent, pentToIgnore );

	mov	eax, DWORD PTR _pentToIgnore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_MoveToss
	add	esp, 12					; 0000000cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2198 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8
$LN1@pfnTraceTo:

; 2199 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceToss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnTraceLine
_TEXT	SEGMENT
$T1 = -180						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_pentToSkip$ = 20					; size = 4
_ptr$ = 24						; size = 4
_pfnTraceLine PROC					; COMDAT

; 2175 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2176 : 	trace_t	trace;
; 2177 : 
; 2178 : 	trace = SV_Move( v1, vec3_origin, vec3_origin, v2, fNoMonsters, pentToSkip, false );

	push	0
	mov	eax, DWORD PTR _pentToSkip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fNoMonsters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2179 : 	if( !SV_IsValidEdict( trace.ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnTraceLine@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceLi

; 2180 : 		trace.ent = svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	mov	DWORD PTR _trace$[ebp+48], eax
$LN2@pfnTraceLi:

; 2181 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8

; 2182 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEmitAmbientSound
_TEXT	SEGMENT
_msg_dest$ = -4						; size = 4
_ent$ = 8						; size = 4
_pos$ = 12						; size = 4
_sample$ = 16						; size = 4
_vol$ = 20						; size = 4
_attn$ = 24						; size = 4
_flags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_pfnEmitAmbientSound PROC				; COMDAT

; 2133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2134 : 	int	msg_dest;
; 2135 : 
; 2136 : 	if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	SHORT $LN2@pfnEmitAmb

; 2137 : 		SetBits( flags, SND_SPAWNING );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 256				; 00000100H
	mov	DWORD PTR _flags$[ebp], eax
$LN2@pfnEmitAmb:

; 2138 : 
; 2139 : 	if( FBitSet( flags, SND_SPAWNING ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN3@pfnEmitAmb

; 2140 : 		msg_dest = MSG_INIT;

	mov	DWORD PTR _msg_dest$[ebp], 3
	jmp	SHORT $LN4@pfnEmitAmb
$LN3@pfnEmitAmb:

; 2141 : 	else msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN4@pfnEmitAmb:

; 2142 : 
; 2143 : 	// always sending stop sound command
; 2144 : 	if( FBitSet( flags, SND_STOP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN5@pfnEmitAmb

; 2145 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN5@pfnEmitAmb:

; 2146 : 
; 2147 : 	if( SV_BuildSoundMsg( &sv.multicast, ent, CHAN_STATIC, sample, vol * 255, attn, flags, pitch, pos ))

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _sample$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	OFFSET _sv+2448128
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN6@pfnEmitAmb

; 2148 : 		SV_Multicast( msg_dest, pos, NULL, false, false );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg_dest$[ebp]
	push	ecx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN6@pfnEmitAmb:

; 2149 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEmitAmbientSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetOrigin
_TEXT	SEGMENT
_e$ = 8							; size = 4
_rgflOrigin$ = 12					; size = 4
_pfnSetOrigin PROC					; COMDAT

; 1974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1975 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetOrigin@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetOrig

; 1976 : 		return;

	jmp	SHORT $LN1@pfnSetOrig
$LN2@pfnSetOrig:

; 1977 : 
; 1978 : 	VectorCopy( rgflOrigin, e->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 1979 : 	SV_LinkEdict( e, false );

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN1@pfnSetOrig:

; 1980 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWalkMove
_TEXT	SEGMENT
tv162 = -96						; size = 8
tv156 = -88						; size = 8
tv95 = -84						; size = 4
_move$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_yaw$ = 12						; size = 4
_dist$ = 16						; size = 4
_iMode$ = 20						; size = 4
_pfnWalkMove PROC					; COMDAT

; 1943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1944 : 	vec3_t	move;
; 1945 : 
; 1946 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnWalkMove@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@pfnWalkMov

; 1947 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnWalkMov
$LN4@pfnWalkMov:

; 1948 : 
; 1949 : 	if( !FBitSet( ent->v.flags, FL_FLY|FL_SWIM|FL_ONGROUND ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 515				; 00000203H
	jne	SHORT $LN5@pfnWalkMov

; 1950 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnWalkMov
$LN5@pfnWalkMov:

; 1951 : 
; 1952 : 	yaw = DEG2RAD( yaw );

	movss	xmm0, DWORD PTR _yaw$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR _yaw$[ebp], xmm0

; 1953 : 	VectorSet( move, cos( yaw ) * dist, sin( yaw ) * dist, 0.0f );

	cvtss2sd xmm0, DWORD PTR _yaw$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv156[ebp]
	movsd	xmm0, QWORD PTR tv156[ebp]
	cvtss2sd xmm1, DWORD PTR _dist$[ebp]
	mulsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	cvtss2sd xmm0, DWORD PTR _yaw$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv162[ebp]
	movsd	xmm0, QWORD PTR tv162[ebp]
	cvtss2sd xmm1, DWORD PTR _dist$[ebp]
	mulsd	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _move$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _move$[ebp+eax], xmm0

; 1954 : 
; 1955 : 	switch( iMode )

	mov	eax, DWORD PTR _iMode$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 0
	je	SHORT $LN6@pfnWalkMov
	cmp	DWORD PTR tv95[ebp], 1
	je	SHORT $LN7@pfnWalkMov
	cmp	DWORD PTR tv95[ebp], 2
	je	SHORT $LN8@pfnWalkMov
	jmp	SHORT $LN2@pfnWalkMov
$LN6@pfnWalkMov:

; 1956 : 	{
; 1957 : 	case WALKMOVE_NORMAL:
; 1958 : 		return SV_MoveStep( ent, move, true );

	push	1
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN7@pfnWalkMov:

; 1959 : 	case WALKMOVE_WORLDONLY:
; 1960 : 		return SV_MoveTest( ent, move, true );

	push	1
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveTest
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN8@pfnWalkMov:

; 1961 : 	case WALKMOVE_CHECKONLY:
; 1962 : 		return SV_MoveStep( ent, move, false);

	push	0
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN2@pfnWalkMov:

; 1963 : 	}
; 1964 : 	return 0;

	xor	eax, eax
$LN1@pfnWalkMov:

; 1965 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWalkMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnDropToFloor
_TEXT	SEGMENT
tv73 = -200						; size = 4
$T1 = -196						; size = 56
_end$ = -76						; size = 12
_trace$ = -64						; size = 56
_monsterClip$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_pfnDropToFloor PROC					; COMDAT

; 1908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1909 : 	qboolean	monsterClip;
; 1910 : 	trace_t	trace;
; 1911 : 	vec3_t	end;
; 1912 : 
; 1913 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnDropToFloor@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnDropToF

; 1914 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDropToF
$LN2@pfnDropToF:

; 1915 : 
; 1916 : 	monsterClip = FBitSet( e->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN6@pfnDropToF
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN7@pfnDropToF
$LN6@pfnDropToF:
	mov	DWORD PTR tv73[ebp], 0
$LN7@pfnDropToF:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 1917 : 	VectorCopy( e->v.origin, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _end$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _end$[ebp+ecx], eax

; 1918 : 	end[2] -= 256.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _end$[ebp+eax]
	subss	xmm0, DWORD PTR __real@43800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _end$[ebp+ecx], xmm0

; 1919 : 
; 1920 : 	trace = SV_Move( e->v.origin, e->v.mins, e->v.maxs, end, MOVE_NORMAL, e, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1921 : 
; 1922 : 	if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN3@pfnDropToF

; 1923 : 		return -1;

	or	eax, -1
	jmp	$LN1@pfnDropToF
$LN3@pfnDropToF:

; 1924 : 
; 1925 : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnDropToF

; 1926 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDropToF
$LN4@pfnDropToF:

; 1927 : 
; 1928 : 	VectorCopy( trace.endpos, e->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 1929 : 	SV_LinkEdict( e, false );

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 1930 : 	SetBits( e->v.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1931 : 	e->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 1932 : 
; 1933 : 	return 1;

	mov	eax, 1
$LN1@pfnDropToF:

; 1934 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDropToFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEntIsOnFloor
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnEntIsOnFloor PROC					; COMDAT

; 1894 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1895 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnEntIsOnFloor@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnEntIsOn

; 1896 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnEntIsOn
$LN2@pfnEntIsOn:

; 1897 : 
; 1898 : 	return SV_CheckBottom( e, MOVE_NORMAL );

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckBottom
	add	esp, 8
$LN1@pfnEntIsOn:

; 1899 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEntIsOnFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnMakeStatic
_TEXT	SEGMENT
_state$ = -4						; size = 4
_ent$ = 8						; size = 4
_pfnMakeStatic PROC					; COMDAT

; 1868 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1869 : 	entity_state_t	*state;
; 1870 : 
; 1871 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnMakeStatic@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnMakeSta

; 1872 : 		return;

	jmp	$LN1@pfnMakeSta
$LN2@pfnMakeSta:

; 1873 : 
; 1874 : 	// fill the entity state
; 1875 : 	state = &svs.static_entities[sv.num_static_entities];	// allocate a new one

	imul	eax, DWORD PTR _sv+726212, 452
	add	eax, DWORD PTR _svs+33364
	mov	DWORD PTR _state$[ebp], eax

; 1876 : 	svgame.dllFuncs.pfnCreateBaseline( false, NUM_FOR_EDICT( ent ), state, ent, 0, vec3_origin, vec3_origin );

	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	push	eax
	push	0
	call	DWORD PTR _svgame+19432
	add	esp, 28					; 0000001cH

; 1877 : 	state->messagenum = ent->v.model; // member modelname

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+12], edx

; 1878 : 
; 1879 : 	if( SV_CreateStaticEntity( &sv.signon, sv.num_static_entities ))

	mov	eax, DWORD PTR _sv+726212
	push	eax
	push	OFFSET _sv+2456340
	call	_SV_CreateStaticEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@pfnMakeSta

; 1880 : 		sv.num_static_entities++;

	mov	eax, DWORD PTR _sv+726212
	add	eax, 1
	mov	DWORD PTR _sv+726212, eax
$LN3@pfnMakeSta:

; 1881 : 
; 1882 : 	// remove at end of the frame
; 1883 : 	SetBits( ent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN1@pfnMakeSta:

; 1884 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMakeStatic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnCreateNamedEntity
_TEXT	SEGMENT
_className$ = 8						; size = 4
_pfnCreateNamedEntity PROC				; COMDAT

; 1856 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1857 : 	return SV_CreateNamedEntity( NULL, className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	push	0
	call	_SV_CreateNamedEntity
	add	esp, 8

; 1858 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCreateNamedEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnMakeVectors
_TEXT	SEGMENT
_rgflVector$ = 8					; size = 4
_pfnMakeVectors PROC					; COMDAT

; 1823 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1824 : 	AngleVectors( rgflVector, svgame.globals->v_forward, svgame.globals->v_right, svgame.globals->v_up );

	mov	eax, DWORD PTR _svgame+19268
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _svgame+19268
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _svgame+19268
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _rgflVector$[ebp]
	push	eax
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1825 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMakeVectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnEntitiesInPVS
_TEXT	SEGMENT
tv128 = -100						; size = 4
_i$ = -32						; size = 4
_pent$ = -28						; size = 4
_viewpoint$ = -24					; size = 12
_ptest$ = -12						; size = 4
_pchain$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pview$ = 8						; size = 4
_pfnEntitiesInPVS PROC					; COMDAT

; 1783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1784 : 	edict_t	*pchain, *ptest;
; 1785 : 	vec3_t	viewpoint;
; 1786 : 	edict_t	*pent;
; 1787 : 	int	i;
; 1788 : 
; 1789 : 	if( !SV_IsValidEdict( pview ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnEntitiesInPVS@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pview$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@pfnEntitie

; 1790 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@pfnEntitie
$LN5@pfnEntitie:

; 1791 : 
; 1792 : 	VectorAdd( pview->v.origin, pview->v.view_ofs, viewpoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _viewpoint$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _viewpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv128[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR _viewpoint$[ebp+eax], xmm0

; 1793 : 	pchain = EDICT_NUM( 0 ); 

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pchain$[ebp], eax

; 1794 : 
; 1795 : 	for( i = 1; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnEntitie
$LN2@pfnEntitie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnEntitie:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@pfnEntitie

; 1796 : 	{
; 1797 : 		pent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 1798 : 
; 1799 : 		if( !SV_IsValidEdict( pent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnEntitiesInPVS@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnEntitie

; 1800 : 			continue;

	jmp	SHORT $LN2@pfnEntitie
$LN6@pfnEntitie:

; 1801 : 
; 1802 : 		if( pent->v.movetype == MOVETYPE_FOLLOW && SV_IsValidEdict( pent->v.aiment ))

	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+396], 12			; 0000000cH
	jne	SHORT $LN7@pfnEntitie
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnEntitiesInPVS@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@pfnEntitie

; 1803 : 			ptest = pent->v.aiment;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	DWORD PTR _ptest$[ebp], ecx
	jmp	SHORT $LN8@pfnEntitie
$LN7@pfnEntitie:

; 1804 : 		else ptest = pent;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR _ptest$[ebp], eax
$LN8@pfnEntitie:

; 1805 : 
; 1806 : 		if( SV_BoxInPVS( viewpoint, ptest->v.absmin, ptest->v.absmax ))

	mov	eax, DWORD PTR _ptest$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _ptest$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	lea	edx, DWORD PTR _viewpoint$[ebp]
	push	edx
	call	_SV_BoxInPVS
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@pfnEntitie

; 1807 : 		{
; 1808 : 			pent->v.chain = pchain;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR _pchain$[ebp]
	mov	DWORD PTR [eax+628], ecx

; 1809 : 			pchain = pent;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR _pchain$[ebp], eax
$LN9@pfnEntitie:

; 1810 : 		}
; 1811 : 	}

	jmp	$LN2@pfnEntitie
$LN3@pfnEntitie:

; 1812 : 
; 1813 : 	return pchain;

	mov	eax, DWORD PTR _pchain$[ebp]
$LN1@pfnEntitie:

; 1814 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEntitiesInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnFindClientInPVS
_TEXT	SEGMENT
tv238 = -104						; size = 4
tv220 = -104						; size = 4
tv193 = -104						; size = 4
tv169 = -104						; size = 4
tv76 = -104						; size = 4
_leaf$ = -36						; size = 4
_bMergePVS$ = -32					; size = 4
_mod$ = -28						; size = 4
_delta$ = -24						; size = 4
_view$ = -20						; size = 12
_pClient$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_pfnFindClientInPVS PROC				; COMDAT

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1725 : 	edict_t	*pClient;
; 1726 : 	vec3_t	view;
; 1727 : 	float	delta;
; 1728 : 	model_t	*mod;
; 1729 : 	qboolean	bMergePVS;
; 1730 : 	mleaf_t	*leaf;
; 1731 : 
; 1732 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnFindClientInPVS@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnFindCli

; 1733 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@pfnFindCli
$LN2@pfnFindCli:

; 1734 : 
; 1735 : 	delta = ( sv.time - sv.lastchecktime );

	movsd	xmm0, QWORD PTR _sv+16
	subsd	xmm0, QWORD PTR _sv+184
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _delta$[ebp], xmm0

; 1736 : 
; 1737 : 	// don't merge visibility for portal entity, only for monsters
; 1738 : 	bMergePVS = FBitSet( pEdict->v.flags, FL_MONSTER ) ? true : false;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 32					; 00000020H
	je	SHORT $LN10@pfnFindCli
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN11@pfnFindCli
$LN10@pfnFindCli:
	mov	DWORD PTR tv76[ebp], 0
$LN11@pfnFindCli:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _bMergePVS$[ebp], edx

; 1739 : 
; 1740 : 	// find a new check if on a new frame
; 1741 : 	if( delta < 0.0f || delta >= 0.1f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _delta$[ebp]
	ja	SHORT $LN4@pfnFindCli
	movss	xmm0, DWORD PTR _delta$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN3@pfnFindCli
$LN4@pfnFindCli:

; 1742 : 	{
; 1743 : 		sv.lastcheck = SV_CheckClientPVS( sv.lastcheck, bMergePVS );

	mov	eax, DWORD PTR _bMergePVS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sv+192
	push	ecx
	call	_SV_CheckClientPVS
	add	esp, 8
	mov	DWORD PTR _sv+192, eax

; 1744 : 		sv.lastchecktime = sv.time;

	movsd	xmm0, QWORD PTR _sv+16
	movsd	QWORD PTR _sv+184, xmm0
$LN3@pfnFindCli:

; 1745 : 	}
; 1746 : 
; 1747 : 	// return check if it might be visible	
; 1748 : 	pClient = EDICT_NUM( sv.lastcheck );

	mov	eax, DWORD PTR _sv+192
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pClient$[ebp], eax

; 1749 : 
; 1750 : 	if( !SV_ClientFromEdict( pClient, true ))

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@pfnFindCli

; 1751 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@pfnFindCli
$LN5@pfnFindCli:

; 1752 : 
; 1753 : 	mod = SV_ModelHandle( pEdict->v.modelindex );

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 1754 : 
; 1755 : 	// portals & monitors
; 1756 : 	// NOTE: this specific break "radiaton tick" in normal half-life. use only as feature
; 1757 : 	if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ) && mod && mod->type == mod_brush && !FBitSet( mod->flags, MODEL_HAS_ORIGIN ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 8
	je	$LN6@pfnFindCli
	cmp	DWORD PTR _mod$[ebp], 0
	je	$LN6@pfnFindCli
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	$LN6@pfnFindCli
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	jne	$LN6@pfnFindCli

; 1758 : 	{
; 1759 : 		// handle PVS origin for bmodels
; 1760 : 		VectorAverage( pEdict->v.mins, pEdict->v.maxs, view );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+352]
	addss	xmm0, DWORD PTR [esi+eax+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _view$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+352]
	addss	xmm0, DWORD PTR [esi+eax+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _view$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+352]
	addss	xmm0, DWORD PTR [esi+ecx+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv169[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR _view$[ebp+eax], xmm0

; 1761 : 		VectorAdd( view, pEdict->v.origin, view );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+136]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _view$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+136]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _view$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+136]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _view$[ebp+eax], xmm0

; 1762 : 	}

	jmp	$LN7@pfnFindCli
$LN6@pfnFindCli:

; 1763 : 	else
; 1764 : 	{
; 1765 : 		VectorAdd( pEdict->v.origin, pEdict->v.view_ofs, view );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _view$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _view$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv220[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR _view$[ebp+eax], xmm0
$LN7@pfnFindCli:

; 1766 : 	}
; 1767 : 
; 1768 : 	leaf = Mod_PointInLeaf( view, sv.worldmodel->nodes );

	mov	eax, DWORD PTR _sv+2595644
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _view$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 1769 : 
; 1770 : 	if( CHECKVISBIT( clientpvs, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN12@pfnFindCli
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	movzx	eax, BYTE PTR _clientpvs[edx]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv238[ebp], eax
	jmp	SHORT $LN13@pfnFindCli
$LN12@pfnFindCli:
	mov	DWORD PTR tv238[ebp], 0
$LN13@pfnFindCli:
	cmp	DWORD PTR tv238[ebp], 0
	je	SHORT $LN8@pfnFindCli

; 1771 : 		return pClient; // client which currently in PVS

	mov	eax, DWORD PTR _pClient$[ebp]
	jmp	SHORT $LN1@pfnFindCli
$LN8@pfnFindCli:

; 1772 : 
; 1773 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@pfnFindCli:

; 1774 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindClientInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CheckClientPVS
_TEXT	SEGMENT
tv67 = -116						; size = 4
tv194 = -112						; size = 4
tv147 = -112						; size = 4
tv66 = -112						; size = 4
_view$1 = -44						; size = 4
_ent$ = -40						; size = 4
_k$ = -36						; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_cl$ = -24						; size = 4
_vieworg$ = -20						; size = 12
_pvs$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_check$ = 8						; size = 4
_bMergePVS$ = 12					; size = 4
_SV_CheckClientPVS PROC					; COMDAT

; 1659 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1660 : 	byte		*pvs;
; 1661 : 	vec3_t		vieworg;
; 1662 : 	sv_client_t	*cl;
; 1663 : 	int		i, j, k;
; 1664 : 	edict_t		*ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 1665 : 
; 1666 : 	// cycle to the next one
; 1667 : 	check = bound( 1, check, svs.maxclients );

	cmp	DWORD PTR _check$[ebp], 1
	jl	SHORT $LN23@SV_CheckCl
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN21@SV_CheckCl
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $LN22@SV_CheckCl
$LN21@SV_CheckCl:
	mov	edx, DWORD PTR _svs+16
	mov	DWORD PTR tv66[ebp], edx
$LN22@SV_CheckCl:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN24@SV_CheckCl
$LN23@SV_CheckCl:
	mov	DWORD PTR tv67[ebp], 1
$LN24@SV_CheckCl:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _check$[ebp], ecx

; 1668 : 
; 1669 : 	if( check == svs.maxclients )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN11@SV_CheckCl

; 1670 : 		i = 1; // reset cycle

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN12@SV_CheckCl
$LN11@SV_CheckCl:

; 1671 : 	else i = check + 1;

	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@SV_CheckCl:

; 1672 : 
; 1673 : 	for( ;; i++ )

	jmp	SHORT $LN4@SV_CheckCl
$LN2@SV_CheckCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckCl:

; 1674 : 	{
; 1675 : 		if( i == ( svs.maxclients + 1 ))

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN13@SV_CheckCl

; 1676 : 			i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN13@SV_CheckCl:

; 1677 : 
; 1678 : 		ent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1679 : 		if( i == check ) break; // didn't find anything else

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _check$[ebp]
	jne	SHORT $LN14@SV_CheckCl
	jmp	SHORT $LN3@SV_CheckCl
$LN14@SV_CheckCl:

; 1680 : 
; 1681 : 		if( ent->free || !ent->pvPrivateData || FBitSet( ent->v.flags, FL_NOTARGET ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN16@SV_CheckCl
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN16@SV_CheckCl
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 128				; 00000080H
	je	SHORT $LN15@SV_CheckCl
$LN16@SV_CheckCl:

; 1682 : 			continue;

	jmp	SHORT $LN2@SV_CheckCl
$LN15@SV_CheckCl:

; 1683 : 
; 1684 : 		// anything that is a client, or has a client as an enemy
; 1685 : 		break;

	jmp	SHORT $LN3@SV_CheckCl

; 1686 : 	}

	jmp	SHORT $LN2@SV_CheckCl
$LN3@SV_CheckCl:

; 1687 : 
; 1688 : 	cl = SV_ClientFromEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax

; 1689 : 	memset( clientpvs, 0xFF, world.visbytes );

	mov	eax, DWORD PTR _world+2588
	push	eax
	push	255					; 000000ffH
	push	OFFSET _clientpvs
	call	_memset
	add	esp, 12					; 0000000cH

; 1690 : 
; 1691 : 	// get the PVS for the entity
; 1692 : 	VectorAdd( ent->v.origin, ent->v.view_ofs, vieworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv147[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0

; 1693 : 	pvs = Mod_GetPVSForPoint( vieworg );

	lea	eax, DWORD PTR _vieworg$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _pvs$[ebp], eax

; 1694 : 	if( pvs ) memcpy( clientpvs, pvs, world.visbytes );

	cmp	DWORD PTR _pvs$[ebp], 0
	je	SHORT $LN17@SV_CheckCl
	mov	eax, DWORD PTR _world+2588
	push	eax
	mov	ecx, DWORD PTR _pvs$[ebp]
	push	ecx
	push	OFFSET _clientpvs
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@SV_CheckCl:

; 1695 : 
; 1696 : 	// transition in progress
; 1697 : 	if( !cl ) return i;

	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN18@SV_CheckCl
	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN1@SV_CheckCl
$LN18@SV_CheckCl:

; 1698 : 
; 1699 : 	// now merge PVS with all the portal cameras
; 1700 : 	for( k = 0; k < cl->num_viewents && bMergePVS; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@SV_CheckCl
$LN5@SV_CheckCl:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@SV_CheckCl:
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+265468]
	jge	$LN6@SV_CheckCl
	cmp	DWORD PTR _bMergePVS$[ebp], 0
	je	$LN6@SV_CheckCl

; 1701 : 	{
; 1702 : 		edict_t	*view = cl->viewentity[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+264956]
	mov	DWORD PTR _view$1[ebp], edx

; 1703 : 
; 1704 : 		if( !SV_IsValidEdict( view ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_CheckClientPVS@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _view$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@SV_CheckCl

; 1705 : 			continue;

	jmp	SHORT $LN5@SV_CheckCl
$LN19@SV_CheckCl:

; 1706 : 
; 1707 : 		VectorAdd( view->v.origin, view->v.view_ofs, vieworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv194[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv194[ebp]
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0

; 1708 : 		pvs = Mod_GetPVSForPoint( vieworg );

	lea	eax, DWORD PTR _vieworg$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _pvs$[ebp], eax

; 1709 : 
; 1710 : 		for( j = 0; j < world.visbytes && pvs; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_CheckCl
$LN8@SV_CheckCl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_CheckCl:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _world+2588
	jae	SHORT $LN9@SV_CheckCl
	cmp	DWORD PTR _pvs$[ebp], 0
	je	SHORT $LN9@SV_CheckCl

; 1711 : 			SetBits( clientpvs[j], pvs[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR _clientpvs[eax]
	mov	edx, DWORD PTR _pvs$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	ecx, eax
	mov	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _clientpvs[edx], cl
	jmp	SHORT $LN8@SV_CheckCl
$LN9@SV_CheckCl:

; 1712 : 	}

	jmp	$LN5@SV_CheckCl
$LN6@SV_CheckCl:

; 1713 : 
; 1714 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_CheckCl:

; 1715 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckClientPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnFindEntityInSphere
_TEXT	SEGMENT
_ent$ = -20						; size = 4
_eorg$ = -16						; size = 4
_e$ = -12						; size = 4
_j$ = -8						; size = 4
_distSquared$ = -4					; size = 4
_pStartEdict$ = 8					; size = 4
_org$ = 12						; size = 4
_flRadius$ = 16						; size = 4
_pfnFindEntityInSphere PROC				; COMDAT

; 1609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1610 : 	float	distSquared;
; 1611 : 	int	j, e = 0;

	mov	DWORD PTR _e$[ebp], 0

; 1612 : 	float	eorg;
; 1613 : 	edict_t	*ent;
; 1614 : 
; 1615 : 	flRadius *= flRadius;

	movss	xmm0, DWORD PTR _flRadius$[ebp]
	mulss	xmm0, DWORD PTR _flRadius$[ebp]
	movss	DWORD PTR _flRadius$[ebp], xmm0

; 1616 : 
; 1617 : 	if( SV_IsValidEdict( pStartEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnFindEntityInSphere@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pStartEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@pfnFindEnt

; 1618 : 		e = NUM_FOR_EDICT( pStartEdict );

	mov	eax, DWORD PTR _pStartEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _e$[ebp], eax
$LN8@pfnFindEnt:

; 1619 : 
; 1620 : 	for( e++; e < svgame.numEntities; e++ )

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN4@pfnFindEnt
$LN2@pfnFindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$LN4@pfnFindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@pfnFindEnt

; 1621 : 	{
; 1622 : 		ent = EDICT_NUM( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1623 : 
; 1624 : 		if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnFindEntityInSphere@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnFindEnt

; 1625 : 			continue;

	jmp	SHORT $LN2@pfnFindEnt
$LN9@pfnFindEnt:

; 1626 : 
; 1627 : 		// ignore clients that not in a game
; 1628 : 		if( e <= svs.maxclients && !SV_ClientFromEdict( ent, true ))

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN10@pfnFindEnt
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@pfnFindEnt

; 1629 : 			continue;

	jmp	SHORT $LN2@pfnFindEnt
$LN10@pfnFindEnt:

; 1630 : 
; 1631 : 		distSquared = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _distSquared$[ebp], xmm0

; 1632 : 
; 1633 : 		for( j = 0; j < 3 && distSquared <= flRadius; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@pfnFindEnt
$LN5@pfnFindEnt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@pfnFindEnt:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@pfnFindEnt
	movss	xmm0, DWORD PTR _flRadius$[ebp]
	comiss	xmm0, DWORD PTR _distSquared$[ebp]
	jb	$LN6@pfnFindEnt

; 1634 : 		{
; 1635 : 			if( org[j] < ent->v.absmin[j] )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+328]
	comiss	xmm0, DWORD PTR [esi+edx*4]
	jbe	SHORT $LN11@pfnFindEnt

; 1636 : 				eorg = org[j] - ent->v.absmin[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4+328]
	movss	DWORD PTR _eorg$[ebp], xmm0
	jmp	SHORT $LN14@pfnFindEnt
$LN11@pfnFindEnt:

; 1637 : 			else if( org[j] > ent->v.absmax[j] )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR [esi+edx*4+340]
	jbe	SHORT $LN13@pfnFindEnt

; 1638 : 				eorg = org[j] - ent->v.absmax[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4+340]
	movss	DWORD PTR _eorg$[ebp], xmm0
	jmp	SHORT $LN14@pfnFindEnt
$LN13@pfnFindEnt:

; 1639 : 			else eorg = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _eorg$[ebp], xmm0
$LN14@pfnFindEnt:

; 1640 : 
; 1641 : 			distSquared += eorg * eorg;

	movss	xmm0, DWORD PTR _eorg$[ebp]
	mulss	xmm0, DWORD PTR _eorg$[ebp]
	addss	xmm0, DWORD PTR _distSquared$[ebp]
	movss	DWORD PTR _distSquared$[ebp], xmm0

; 1642 : 		}

	jmp	$LN5@pfnFindEnt
$LN6@pfnFindEnt:

; 1643 : 
; 1644 : 		if( distSquared < flRadius )

	movss	xmm0, DWORD PTR _flRadius$[ebp]
	comiss	xmm0, DWORD PTR _distSquared$[ebp]
	jbe	SHORT $LN15@pfnFindEnt

; 1645 : 			return ent;

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	SHORT $LN1@pfnFindEnt
$LN15@pfnFindEnt:

; 1646 : 	}

	jmp	$LN2@pfnFindEnt
$LN3@pfnFindEnt:

; 1647 : 
; 1648 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@pfnFindEnt:

; 1649 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindEntityInSphere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetEntityIllum
_TEXT	SEGMENT
_pEnt$ = 8						; size = 4
_pfnGetEntityIllum PROC					; COMDAT

; 1594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1595 : 	if( !SV_IsValidEdict( pEnt ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetEntityIllum@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEnt$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetEnti

; 1596 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetEnti
$LN2@pfnGetEnti:

; 1597 : 
; 1598 : 	return SV_LightForEntity( pEnt );

	mov	eax, DWORD PTR _pEnt$[ebp]
	push	eax
	call	_SV_LightForEntity
	add	esp, 4
$LN1@pfnGetEnti:

; 1599 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetEntityIllum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnChangePitch
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnChangePitch PROC					; COMDAT

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1503 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnChangePitch@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnChangeP

; 1504 : 		return;

	jmp	SHORT $LN1@pfnChangeP
$LN2@pfnChangeP:

; 1505 : 
; 1506 : 	ent->v.angles[PITCH] = SV_AngleMod( ent->v.idealpitch, ent->v.angles[PITCH], ent->v.pitch_speed );	

	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+296]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+292]
	movss	DWORD PTR [esp], xmm0
	call	_SV_AngleMod
	add	esp, 12					; 0000000cH
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [ecx+eax+208]
$LN1@pfnChangeP:

; 1507 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnChangePitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnChangeYaw
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnChangeYaw PROC					; COMDAT

; 1488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1489 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnChangeYaw@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnChangeY

; 1490 : 		return;

	jmp	SHORT $LN1@pfnChangeY
$LN2@pfnChangeY:

; 1491 : 
; 1492 : 	ent->v.angles[YAW] = SV_AngleMod( ent->v.ideal_yaw, ent->v.angles[YAW], ent->v.yaw_speed );

	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+304]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+208]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+300]
	movss	DWORD PTR [esp], xmm0
	call	_SV_AngleMod
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [edx+ecx+208]
$LN1@pfnChangeY:

; 1493 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnChangeYaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnMoveToOrigin
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pflGoal$ = 12						; size = 4
_dist$ = 16						; size = 4
_iMoveType$ = 20					; size = 4
_pfnMoveToOrigin PROC					; COMDAT

; 1474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1475 : 	if( !pflGoal || !SV_IsValidEdict( ent ))

	cmp	DWORD PTR _pflGoal$[ebp], 0
	je	SHORT $LN3@pfnMoveToO
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnMoveToOrigin@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnMoveToO
$LN3@pfnMoveToO:

; 1476 : 		return;

	jmp	SHORT $LN1@pfnMoveToO
$LN2@pfnMoveToO:

; 1477 : 
; 1478 : 	SV_MoveToOrigin( ent, pflGoal, dist, iMoveType );

	mov	eax, DWORD PTR _iMoveType$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pflGoal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_MoveToOrigin
	add	esp, 16					; 00000010H
$LN1@pfnMoveToO:

; 1479 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMoveToOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnVecToYaw
_TEXT	SEGMENT
_rgflVector$ = 8					; size = 4
_pfnVecToYaw PROC					; COMDAT

; 1463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1464 : 	return SV_VecToYaw( rgflVector );

	mov	eax, DWORD PTR _rgflVector$[ebp]
	push	eax
	call	_SV_VecToYaw
	add	esp, 4

; 1465 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnVecToYaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSaveSpawnParms
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnSaveSpawnParms PROC					; COMDAT

; 1453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1454 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSaveSpawnParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetSpawnParms
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnGetSpawnParms PROC					; COMDAT

; 1442 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1443 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetSpawnParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnChangeLevel
_TEXT	SEGMENT
$T1 = -140						; size = 4
_text$ = -72						; size = 4
_landname$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_landmark$ = 12						; size = 4
_pfnChangeLevel PROC					; COMDAT

; 1403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1404 : 	static uint	last_spawncount = 0;
; 1405 : 	char		landname[MAX_QPATH];
; 1406 : 	char		*text;
; 1407 : 
; 1408 : 	if( !COM_CheckString( level ) || sv.state != ss_active )

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@pfnChangeL
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN4@pfnChangeL
$LN5@pfnChangeL:

; 1409 : 		return; // ???

	jmp	$LN8@pfnChangeL
$LN4@pfnChangeL:

; 1410 : 
; 1411 : 	// make sure we don't issue two changelevels
; 1412 : 	if( svs.spawncount == last_spawncount )

	mov	eax, DWORD PTR _svs+33340
	cmp	eax, DWORD PTR ?last_spawncount@?1??pfnChangeLevel@@9@9
	jne	SHORT $LN6@pfnChangeL

; 1413 : 		return;

	jmp	$LN8@pfnChangeL
$LN6@pfnChangeL:

; 1414 : 	last_spawncount = svs.spawncount;

	mov	eax, DWORD PTR _svs+33340
	mov	DWORD PTR ?last_spawncount@?1??pfnChangeLevel@@9@9, eax

; 1415 : 	landname[0] ='\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 64			; 00000040H
	jae	SHORT $LN9@pfnChangeL
	jmp	SHORT $LN10@pfnChangeL
$LN9@pfnChangeL:
	call	___report_rangecheckfailure
$LN10@pfnChangeL:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _landname$[ebp+edx], 0

; 1416 : 
; 1417 : #ifdef HACKS_RELATED_HLMODS
; 1418 : 	// g-cont. some level-designers wrote landmark name with space
; 1419 : 	// and Cmd_TokenizeString separating all the after space as next argument
; 1420 : 	// emulate this bug for compatibility
; 1421 : 	if( COM_CheckString( landmark ))

	mov	eax, DWORD PTR _landmark$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@pfnChangeL

; 1422 : 	{
; 1423 : 		text = (char *)landname;

	lea	eax, DWORD PTR _landname$[ebp]
	mov	DWORD PTR _text$[ebp], eax
$LN2@pfnChangeL:

; 1424 : 		while( *landmark && ((byte)*landmark) != ' ' )

	mov	eax, DWORD PTR _landmark$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@pfnChangeL
	mov	eax, DWORD PTR _landmark$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN3@pfnChangeL

; 1425 : 			*text++ = *landmark++;

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR _landmark$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	mov	ecx, DWORD PTR _landmark$[ebp]
	add	ecx, 1
	mov	DWORD PTR _landmark$[ebp], ecx
	jmp	SHORT $LN2@pfnChangeL
$LN3@pfnChangeL:

; 1426 : 		*text = '\0';

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax], 0
$LN7@pfnChangeL:

; 1427 : 	}
; 1428 : #else
; 1429 : 	Q_strncpy( landname, landmark, sizeof( landname ));
; 1430 : #endif
; 1431 : 	SV_QueueChangeLevel( level, landname );

	lea	eax, DWORD PTR _landname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	_SV_QueueChangeLevel
	add	esp, 8
$LN8@pfnChangeL:

; 1432 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetSize
_TEXT	SEGMENT
_e$ = 8							; size = 4
_rgflMin$ = 12						; size = 4
_rgflMax$ = 16						; size = 4
_pfnSetSize PROC					; COMDAT

; 1389 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1390 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetSize@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetSize

; 1391 : 		return;

	jmp	SHORT $LN1@pfnSetSize
$LN2@pfnSetSize:

; 1392 : 
; 1393 : 	SV_SetMinMaxSize( e, rgflMin, rgflMax, true );

	push	1
	mov	eax, DWORD PTR _rgflMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rgflMin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
$LN1@pfnSetSize:

; 1394 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnModelFrames
_TEXT	SEGMENT
_pmodel$ = -4						; size = 4
_modelIndex$ = 8					; size = 4
_pfnModelFrames PROC					; COMDAT

; 1374 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1375 : 	model_t	*pmodel = SV_ModelHandle( modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax

; 1376 : 
; 1377 : 	if( pmodel != NULL )

	cmp	DWORD PTR _pmodel$[ebp], 0
	je	SHORT $LN2@pfnModelFr

; 1378 : 		return pmodel->numframes;

	mov	eax, DWORD PTR _pmodel$[ebp]
	mov	eax, DWORD PTR [eax+72]
	jmp	SHORT $LN1@pfnModelFr
$LN2@pfnModelFr:

; 1379 : 	return 1;

	mov	eax, 1
$LN1@pfnModelFr:

; 1380 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnModelFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetModel
_TEXT	SEGMENT
_i$ = -76						; size = 4
_mod$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_m$ = 12						; size = 4
_pfnSetModel PROC					; COMDAT

; 1285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1286 : 	char	name[MAX_QPATH];
; 1287 : 	model_t	*mod;
; 1288 : 	int	i;
; 1289 : 
; 1290 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetModel@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@pfnSetMode

; 1291 : 		return;

	jmp	$LN1@pfnSetMode
$LN5@pfnSetMode:

; 1292 : 
; 1293 : 	if( *m == '\\' || *m == '/' ) m++;

	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@pfnSetMode
	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@pfnSetMode
$LN7@pfnSetMode:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN6@pfnSetMode:

; 1294 : 	Q_strncpy( name, m, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1295 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1296 : 
; 1297 : 	if( COM_CheckString( name ))

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@pfnSetMode

; 1298 : 	{
; 1299 : 		// check to see if model was properly precached
; 1300 : 		for( i = 1; i < MAX_MODELS && sv.model_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnSetMode
$LN2@pfnSetMode:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnSetMode:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnSetMode
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+196]
	test	eax, eax
	je	SHORT $LN3@pfnSetMode

; 1301 : 		{
; 1302 : 			if( !Q_stricmp( sv.model_precache[i], name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnSetMode

; 1303 : 				break;

	jmp	SHORT $LN3@pfnSetMode
$LN9@pfnSetMode:

; 1304 : 		}

	jmp	SHORT $LN2@pfnSetMode
$LN3@pfnSetMode:

; 1305 : 
; 1306 : 		if( i == MAX_MODELS )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN8@pfnSetMode

; 1307 : 		{
; 1308 : 			Con_Printf( S_ERROR "no precache: %s\n", name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1309 : 			return;

	jmp	$LN1@pfnSetMode
$LN8@pfnSetMode:

; 1310 : 		}
; 1311 : 	}
; 1312 : 
; 1313 : 	if( e == svgame.edicts )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7928
	jne	SHORT $LN11@pfnSetMode

; 1314 : 	{
; 1315 : 		if( sv.state == ss_active )

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN12@pfnSetMode

; 1316 : 			Con_Printf( S_ERROR "world model can't be changed\n" );

	push	OFFSET ??_C@_0CJ@FCBGMNHP@?$FO1Error?3?$FO7?5world?5model?5can?8t?5be@
	call	_Con_Printf
	add	esp, 4
$LN12@pfnSetMode:

; 1317 : 		return;

	jmp	$LN1@pfnSetMode
$LN11@pfnSetMode:

; 1318 : 	}
; 1319 : 
; 1320 : 	if( COM_CheckString( name ))

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@pfnSetMode

; 1321 : 	{
; 1322 : 		e->v.model = MAKE_STRING( sv.model_precache[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196
	push	eax
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 1323 : 		e->v.modelindex = i;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+308], ecx

; 1324 : 		mod = sv.models[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sv[eax*4+722116]
	mov	DWORD PTR _mod$[ebp], ecx

; 1325 : 	}

	jmp	SHORT $LN14@pfnSetMode
$LN13@pfnSetMode:

; 1326 : 	else
; 1327 : 	{
; 1328 : 		// model will be cleared
; 1329 : 		e->v.model = e->v.modelindex = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+308], 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+312], 0

; 1330 : 		mod = NULL;

	mov	DWORD PTR _mod$[ebp], 0
$LN14@pfnSetMode:

; 1331 : 	}
; 1332 : 
; 1333 : 	// set the model size
; 1334 : 	if( mod && mod->type != mod_studio )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN15@pfnSetMode
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	je	SHORT $LN15@pfnSetMode

; 1335 : 		SV_SetMinMaxSize( e, mod->mins, mod->maxs, true );

	push	1
	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetMode
$LN15@pfnSetMode:

; 1336 : 	else SV_SetMinMaxSize( e, vec3_origin, vec3_origin, true );

	push	1
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
$LN1@pfnSetMode:

; 1337 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_IsValidCmd
_TEXT	SEGMENT
_len$ = -4						; size = 4
_pCmd$ = 8						; size = 4
_SV_IsValidCmd PROC					; COMDAT

; 1206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1207 : 	size_t	len = Q_strlen( pCmd );

	mov	eax, DWORD PTR _pCmd$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1208 : 
; 1209 : 	// valid commands all have a ';' or newline '\n' as their last character
; 1210 : 	if( len && ( pCmd[len-1] == '\n' || pCmd[len-1] == ';' ))

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN2@SV_IsValid
	mov	eax, DWORD PTR _pCmd$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN3@SV_IsValid
	mov	eax, DWORD PTR _pCmd$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN2@SV_IsValid
$LN3@SV_IsValid:

; 1211 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsValid
$LN2@SV_IsValid:

; 1212 : 	return false;

	xor	eax, eax
$LN1@SV_IsValid:

; 1213 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_IsValidCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_GetEntityClass
_TEXT	SEGMENT
_pszClassName$ = 8					; size = 4
_SV_GetEntityClass PROC					; COMDAT

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1057 : 	// allocate edict private memory (passed by dlls)
; 1058 : 	return (LINK_ENTITY_FUNC)COM_GetProcAddress( svgame.hInstance, pszClassName );

	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetEntityClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_ReadEntityScript
_TEXT	SEGMENT
tv84 = -1832						; size = 4
_f$ = -1572						; size = 4
_ft2$ = -1568						; size = 4
_ft1$ = -1564						; size = 4
_header$ = -1560					; size = 4
_buf$ = -1556						; size = 1024
_ents$ = -532						; size = 4
_lumplen$ = -528					; size = 4
_lumpofs$ = -524					; size = 4
_ver$ = -520						; size = 4
_entfilename$ = -516					; size = 256
_bspfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_flags$ = 12						; size = 4
_SV_ReadEntityScript PROC				; COMDAT

; 806  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1832				; 00000728H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 807  : 	string		bspfilename, entfilename;
; 808  : 	int		ver = -1, lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _ver$[ebp], -1
	mov	DWORD PTR _lumpofs$[ebp], 0
	mov	DWORD PTR _lumplen$[ebp], 0

; 809  : 	char		*ents = NULL;

	mov	DWORD PTR _ents$[ebp], 0

; 810  : 	byte		buf[1024];
; 811  : 	dheader_t		*header;
; 812  : 	size_t		ft1, ft2;
; 813  : 	file_t		*f;
; 814  : 
; 815  : 	*flags = 0;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax], 0

; 816  : 
; 817  : 	Q_strncpy( bspfilename, va( "maps/%s.bsp", filename ), sizeof( bspfilename ));			

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 818  : 	f = FS_Open( bspfilename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _bspfilename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 819  : 	if( !f ) return NULL;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@SV_ReadEnt
	xor	eax, eax
	jmp	$LN1@SV_ReadEnt
$LN2@SV_ReadEnt:

; 820  : 
; 821  : 	SetBits( *flags, MAP_IS_EXIST );

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edx], ecx

; 822  : 	memset( buf, 0, MAX_SYSPATH );

	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 823  : 	FS_Read( f, buf, MAX_SYSPATH );

	push	1024					; 00000400H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 824  : 	header = (dheader_t *)buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 825  : 
; 826  : 	// check all the lumps and some other errors
; 827  : 	if( !Mod_TestBmodelLumps( bspfilename, buf, (host_developer.value) ? false : true ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_ReadEnt
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN8@SV_ReadEnt
$LN7@SV_ReadEnt:
	mov	DWORD PTR tv84[ebp], 1
$LN8@SV_ReadEnt:
	mov	eax, DWORD PTR tv84[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bspfilename$[ebp]
	push	edx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_ReadEnt

; 828  : 	{
; 829  : 		SetBits( *flags, MAP_INVALID_VERSION );

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edx], ecx

; 830  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 831  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_ReadEnt
$LN3@SV_ReadEnt:

; 832  : 	}
; 833  : 
; 834  : 	// after call Mod_TestBmodelLumps we gurantee what map is valid
; 835  : 	lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lumpofs$[ebp], eax

; 836  : 	lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _lumplen$[ebp], eax

; 837  : 
; 838  : 	// check for entfile too
; 839  : 	Q_strncpy( entfilename, va( "maps/%s.ent", filename ), sizeof( entfilename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@NHJMLCCE@maps?1?$CFs?4ent@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _entfilename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 840  : 
; 841  : 	// make sure what entity patch is never than bsp
; 842  : 	ft1 = FS_FileTime( bspfilename, false );

	push	0
	lea	eax, DWORD PTR _bspfilename$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft1$[ebp], eax

; 843  : 	ft2 = FS_FileTime( entfilename, true );

	push	1
	lea	eax, DWORD PTR _entfilename$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft2$[ebp], eax

; 844  : 
; 845  : 	if( ft2 != -1 && ft1 < ft2 )

	cmp	DWORD PTR _ft2$[ebp], -1
	je	SHORT $LN4@SV_ReadEnt
	mov	eax, DWORD PTR _ft1$[ebp]
	cmp	eax, DWORD PTR _ft2$[ebp]
	jae	SHORT $LN4@SV_ReadEnt

; 846  : 	{
; 847  : 		// grab .ent files only from gamedir
; 848  : 		ents = FS_LoadFile( entfilename, NULL, true ); 

	push	1
	push	0
	lea	eax, DWORD PTR _entfilename$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ents$[ebp], eax
$LN4@SV_ReadEnt:

; 849  : 	}
; 850  : 
; 851  : 	// at least entities should contain "{ "classname" "worldspawn" }\0"
; 852  : 	// for correct spawn the level
; 853  : 	if( !ents && lumplen >= 32 )

	cmp	DWORD PTR _ents$[ebp], 0
	jne	SHORT $LN5@SV_ReadEnt
	cmp	DWORD PTR _lumplen$[ebp], 32		; 00000020H
	jl	SHORT $LN5@SV_ReadEnt

; 854  : 	{
; 855  : 		FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lumpofs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 856  : 		ents = Z_Calloc( lumplen + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ReadEntityScript@@9@9
	add	eax, 50					; 00000032H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _lumplen$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ents$[ebp], eax

; 857  : 		FS_Read( f, ents, lumplen );

	mov	eax, DWORD PTR _lumplen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
$LN5@SV_ReadEnt:

; 858  : 	}
; 859  : 	FS_Close( f ); // all done

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 860  : 
; 861  : 	return ents;

	mov	eax, DWORD PTR _ents$[ebp]
$LN1@SV_ReadEnt:

; 862  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ReadEntityScript ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_Multicast
_TEXT	SEGMENT
tv80 = -100						; size = 4
tv67 = -100						; size = 4
_numsends$ = -32					; size = 4
_specproxy$ = -28					; size = 4
_reliable$ = -24					; size = 4
_current$ = -20						; size = 4
_cl$ = -16						; size = 4
_numclients$ = -12					; size = 4
_j$ = -8						; size = 4
_mask$ = -4						; size = 4
_dest$ = 8						; size = 4
_origin$ = 12						; size = 4
_ent$ = 16						; size = 4
_usermessage$ = 20					; size = 4
_filter$ = 24						; size = 4
_SV_Multicast PROC					; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 326  : 	byte		*mask = NULL;

	mov	DWORD PTR _mask$[ebp], 0

; 327  : 	int		j, numclients = svs.maxclients;

	mov	eax, DWORD PTR _svs+16
	mov	DWORD PTR _numclients$[ebp], eax

; 328  : 	sv_client_t	*cl, *current = svs.clients;

	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], eax

; 329  : 	qboolean		reliable = false;

	mov	DWORD PTR _reliable$[ebp], 0

; 330  : 	qboolean		specproxy = false;

	mov	DWORD PTR _specproxy$[ebp], 0

; 331  : 	int		numsends = 0;

	mov	DWORD PTR _numsends$[ebp], 0

; 332  : 
; 333  : 	// some mods trying to send messages after SV_FinalMessage
; 334  : 	if( !svs.initialized || sv.state == ss_dead )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN8@SV_Multica
	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN7@SV_Multica
$LN8@SV_Multica:

; 335  : 	{
; 336  : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 337  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN7@SV_Multica:

; 338  : 	}
; 339  : 
; 340  : 	switch( dest )

	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 9
	ja	$LN25@SV_Multica
	mov	ecx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN45@SV_Multica[ecx*4]
$LN9@SV_Multica:

; 341  : 	{
; 342  : 	case MSG_INIT:
; 343  : 		if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	SHORT $LN10@SV_Multica

; 344  : 		{
; 345  : 			// copy to signon buffer
; 346  : 			MSG_WriteBits( &sv.signon, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	push	OFFSET _sv+2448128
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_GetData
	add	esp, 4
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 347  : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 348  : 			return 1;

	mov	eax, 1
	jmp	$LN1@SV_Multica
$LN10@SV_Multica:

; 349  : 		}
; 350  : 		// intentional fallthrough (in-game MSG_INIT it's a MSG_ALL reliable)
; 351  : 	case MSG_ALL:
; 352  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN12@SV_Multica:

; 353  : 		// intentional fallthrough
; 354  : 	case MSG_BROADCAST:
; 355  : 		// nothing to sort	
; 356  : 		break;

	jmp	$LN2@SV_Multica
$LN13@SV_Multica:

; 357  : 	case MSG_PAS_R:
; 358  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN14@SV_Multica:

; 359  : 		// intentional fallthrough
; 360  : 	case MSG_PAS:
; 361  : 		if( origin == NULL ) return false;

	cmp	DWORD PTR _origin$[ebp], 0
	jne	SHORT $LN15@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN15@SV_Multica:

; 362  : 		// NOTE: GoldSource not using PHS for singleplayer
; 363  : 		Mod_FatPVS( origin, FATPHS_RADIUS, fatphs, world.fatbytes, false, ( svs.maxclients == 1 ));

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN43@SV_Multica
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN44@SV_Multica
$LN43@SV_Multica:
	mov	DWORD PTR tv80[ebp], 0
$LN44@SV_Multica:
	mov	eax, DWORD PTR tv80[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 364  : 		mask = fatphs; // using the FatPVS like a PHS

	mov	DWORD PTR _mask$[ebp], OFFSET _fatphs

; 365  : 		break;

	jmp	$LN2@SV_Multica
$LN16@SV_Multica:

; 366  : 	case MSG_PVS_R:
; 367  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN17@SV_Multica:

; 368  : 		// intentional fallthrough
; 369  : 	case MSG_PVS:
; 370  : 		if( origin == NULL ) return 0;

	cmp	DWORD PTR _origin$[ebp], 0
	jne	SHORT $LN18@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN18@SV_Multica:

; 371  : 		mask = Mod_GetPVSForPoint( origin );

	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _mask$[ebp], eax

; 372  : 		break;

	jmp	$LN2@SV_Multica
$LN19@SV_Multica:

; 373  : 	case MSG_ONE:
; 374  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN20@SV_Multica:

; 375  : 		// intentional fallthrough
; 376  : 	case MSG_ONE_UNRELIABLE:
; 377  : 		if( !SV_IsValidEdict( ent )) return 0;

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Multicast@@9@9
	add	eax, 52					; 00000034H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN21@SV_Multica:

; 378  : 		j = NUM_FOR_EDICT( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _j$[ebp], eax

; 379  : 		if( j < 1 || j > numclients ) return 0;

	cmp	DWORD PTR _j$[ebp], 1
	jl	SHORT $LN23@SV_Multica
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numclients$[ebp]
	jle	SHORT $LN22@SV_Multica
$LN23@SV_Multica:
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN22@SV_Multica:

; 380  : 		current = svs.clients + (j - 1);

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	imul	ecx, eax, 289832
	add	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], ecx

; 381  : 		numclients = 1; // send to one

	mov	DWORD PTR _numclients$[ebp], 1

; 382  : 		break;

	jmp	SHORT $LN2@SV_Multica
$LN24@SV_Multica:

; 383  : 	case MSG_SPEC:
; 384  : 		specproxy = reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
	mov	eax, DWORD PTR _reliable$[ebp]
	mov	DWORD PTR _specproxy$[ebp], eax

; 385  : 		break;

	jmp	SHORT $LN2@SV_Multica
$LN25@SV_Multica:

; 386  : 	default:
; 387  : 		Host_Error( "SV_Multicast: bad dest: %i\n", dest );

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@GLEHBJII@SV_Multicast?3?5bad?5dest?3?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 388  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN2@SV_Multica:

; 389  : 	}
; 390  : 
; 391  : 	// send the data to all relevent clients (or once only)
; 392  : 	for( j = 0, cl = current; j < numclients; j++, cl++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN6@SV_Multica
$LN4@SV_Multica:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN6@SV_Multica:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numclients$[ebp]
	jge	$LN5@SV_Multica

; 393  : 	{
; 394  : 		if( cl->state == cs_free || cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN27@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN26@SV_Multica
$LN27@SV_Multica:

; 395  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN26@SV_Multica:

; 396  : 
; 397  : 		if( cl->state != cs_spawned && ( !reliable || usermessage ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN28@SV_Multica
	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN29@SV_Multica
	cmp	DWORD PTR _usermessage$[ebp], 0
	je	SHORT $LN28@SV_Multica
$LN29@SV_Multica:

; 398  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN28@SV_Multica:

; 399  : 
; 400  : 		if( specproxy && !FBitSet( cl->flags, FCL_HLTV_PROXY ))

	cmp	DWORD PTR _specproxy$[ebp], 0
	je	SHORT $LN30@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	jne	SHORT $LN30@SV_Multica

; 401  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN30@SV_Multica:

; 402  : 
; 403  : 		if( !cl->edict || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264948], 0
	je	SHORT $LN32@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN31@SV_Multica
$LN32@SV_Multica:

; 404  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN31@SV_Multica:

; 405  : 
; 406  : 		// reject step sounds while predicting is enabled
; 407  : 		// FIXME: make sure what this code doesn't cutoff something important!!!
; 408  : 		if( filter && cl == sv.current_client && FBitSet( sv.current_client->flags, FCL_PREDICT_MOVEMENT ))

	cmp	DWORD PTR _filter$[ebp], 0
	je	SHORT $LN33@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	eax, DWORD PTR _sv+40
	jne	SHORT $LN33@SV_Multica
	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 16					; 00000010H
	je	SHORT $LN33@SV_Multica

; 409  : 			continue;

	jmp	$LN4@SV_Multica
$LN33@SV_Multica:

; 410  : 
; 411  : 		if( SV_IsValidEdict( ent ) && ent->v.groupinfo && cl->edict->v.groupinfo )

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Multicast@@9@9
	add	eax, 86					; 00000056H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@SV_Multica
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN36@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	cmp	DWORD PTR [ecx+800], 0
	je	SHORT $LN36@SV_Multica

; 412  : 		{
; 413  : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( cl->edict->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN35@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+800]
	and	eax, DWORD PTR [edx+800]
	jne	SHORT $LN35@SV_Multica

; 414  : 				continue;

	jmp	$LN4@SV_Multica
$LN35@SV_Multica:

; 415  : 
; 416  : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( cl->edict->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN36@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+800]
	and	eax, DWORD PTR [edx+800]
	je	SHORT $LN36@SV_Multica

; 417  : 				continue;

	jmp	$LN4@SV_Multica
$LN36@SV_Multica:

; 418  : 		}
; 419  : 
; 420  : 		if( !SV_CheckClientVisiblity( cl, mask ))

	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_CheckClientVisiblity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@SV_Multica

; 421  : 			continue;

	jmp	$LN4@SV_Multica
$LN37@SV_Multica:

; 422  : 
; 423  : 		if( specproxy ) MSG_WriteBits( &sv.spec_datagram, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	cmp	DWORD PTR _specproxy$[ebp], 0
	je	SHORT $LN38@SV_Multica
	push	OFFSET _sv+2448128
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_GetData
	add	esp, 4
	push	eax
	push	OFFSET _sv+2587432
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN41@SV_Multica
$LN38@SV_Multica:

; 424  : 		else if( reliable ) MSG_WriteBits( &cl->netchan.message, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN40@SV_Multica
	push	OFFSET _sv+2448128
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN41@SV_Multica
$LN40@SV_Multica:

; 425  : 		else MSG_WriteBits( &cl->datagram, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	push	OFFSET _sv+2448128
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 265480				; 00040d08H
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
$LN41@SV_Multica:

; 426  : 		numsends++;

	mov	eax, DWORD PTR _numsends$[ebp]
	add	eax, 1
	mov	DWORD PTR _numsends$[ebp], eax

; 427  : 	}

	jmp	$LN4@SV_Multica
$LN5@SV_Multica:

; 428  : 
; 429  : 	MSG_Clear( &sv.multicast );

	push	OFFSET _sv+2448128
	call	_MSG_Clear
	add	esp, 4

; 430  : 
; 431  : 	return numsends; // just for debug

	mov	eax, DWORD PTR _numsends$[ebp]
$LN1@SV_Multica:

; 432  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN45@SV_Multica:
	DD	$LN12@SV_Multica
	DD	$LN19@SV_Multica
	DD	$LN10@SV_Multica
	DD	$LN9@SV_Multica
	DD	$LN17@SV_Multica
	DD	$LN14@SV_Multica
	DD	$LN16@SV_Multica
	DD	$LN13@SV_Multica
	DD	$LN20@SV_Multica
	DD	$LN24@SV_Multica
_SV_Multicast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CheckClientVisiblity
_TEXT	SEGMENT
tv233 = -100						; size = 4
tv215 = -100						; size = 4
tv175 = -100						; size = 4
_view$1 = -32						; size = 4
_leaf$ = -28						; size = 4
_vieworg$ = -24						; size = 12
_clientnum$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_mask$ = 12						; size = 4
_SV_CheckClientVisiblity PROC				; COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 273  : 	int	i, clientnum;
; 274  : 	vec3_t	vieworg;
; 275  : 	mleaf_t	*leaf;
; 276  : 
; 277  : 	if( !mask ) return true; // GoldSrc rules

	cmp	DWORD PTR _mask$[ebp], 0
	jne	SHORT $LN5@SV_CheckCl
	mov	eax, 1
	jmp	$LN1@SV_CheckCl
$LN5@SV_CheckCl:

; 278  : 
; 279  : 	clientnum = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	mov	DWORD PTR _clientnum$[ebp], eax

; 280  : 	VectorCopy( viewPoint[clientnum], vieworg );

	imul	eax, DWORD PTR _clientnum$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR _viewPoint[eax+edx]
	mov	DWORD PTR _vieworg$[ebp+ecx], edx
	imul	eax, DWORD PTR _clientnum$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _viewPoint[eax+ecx]
	mov	DWORD PTR _vieworg$[ebp+edx], eax
	imul	ecx, DWORD PTR _clientnum$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _viewPoint[ecx+edx]
	mov	DWORD PTR _vieworg$[ebp+eax], ecx

; 281  : 
; 282  : 	// Invasion issues: wrong camera position received in ENGINE_SET_PVS
; 283  : 	if( cl->pViewEntity && !VectorCompare( vieworg, cl->pViewEntity->v.origin ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264952], 0
	je	$LN6@SV_CheckCl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264952]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _vieworg$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_CheckCl
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264952]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vieworg$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_CheckCl
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264952]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vieworg$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_CheckCl
$LN7@SV_CheckCl:

; 284  : 		VectorCopy( cl->pViewEntity->v.origin, vieworg );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264952]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR _vieworg$[ebp+edx], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264952]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _vieworg$[ebp+ecx], edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264952]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _vieworg$[ebp+eax], ecx
$LN6@SV_CheckCl:

; 285  : 
; 286  : 	leaf = Mod_PointInLeaf( vieworg, sv.worldmodel->nodes );

	mov	eax, DWORD PTR _sv+2595644
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 287  : 
; 288  : 	if( CHECKVISBIT( mask, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN12@SV_CheckCl
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	mov	eax, DWORD PTR _mask$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv175[ebp], ecx
	jmp	SHORT $LN13@SV_CheckCl
$LN12@SV_CheckCl:
	mov	DWORD PTR tv175[ebp], 0
$LN13@SV_CheckCl:
	cmp	DWORD PTR tv175[ebp], 0
	je	SHORT $LN8@SV_CheckCl

; 289  : 		return true; // visible from player view or camera view

	mov	eax, 1
	jmp	$LN1@SV_CheckCl
$LN8@SV_CheckCl:

; 290  : 
; 291  : 	// now check all the portal cameras
; 292  : 	for( i = 0; i < cl->num_viewents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckCl
$LN2@SV_CheckCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckCl:
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+265468]
	jge	$LN3@SV_CheckCl

; 293  : 	{
; 294  : 		edict_t	*view = cl->viewentity[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+264956]
	mov	DWORD PTR _view$1[ebp], edx

; 295  : 
; 296  : 		if( !SV_IsValidEdict( view ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_CheckClientVisiblity@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _view$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_CheckCl

; 297  : 			continue;

	jmp	SHORT $LN2@SV_CheckCl
$LN9@SV_CheckCl:

; 298  : 
; 299  : 		VectorAdd( view->v.origin, view->v.view_ofs, vieworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv215[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv215[ebp]
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0

; 300  : 		leaf = Mod_PointInLeaf( vieworg, sv.worldmodel->nodes );

	mov	eax, DWORD PTR _sv+2595644
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 301  : 
; 302  : 		if( CHECKVISBIT( mask, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN14@SV_CheckCl
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	mov	eax, DWORD PTR _mask$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv233[ebp], ecx
	jmp	SHORT $LN15@SV_CheckCl
$LN14@SV_CheckCl:
	mov	DWORD PTR tv233[ebp], 0
$LN15@SV_CheckCl:
	cmp	DWORD PTR tv233[ebp], 0
	je	SHORT $LN10@SV_CheckCl

; 303  : 			return true; // visible from portal camera view

	mov	eax, 1
	jmp	SHORT $LN1@SV_CheckCl
$LN10@SV_CheckCl:

; 304  : 	}

	jmp	$LN2@SV_CheckCl
$LN3@SV_CheckCl:

; 305  : 
; 306  : 	// not visible from any viewpoint
; 307  : 	return false;

	xor	eax, eax
$LN1@SV_CheckCl:

; 308  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckClientVisiblity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_ConvertTrace
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_SV_ConvertTrace PROC					; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 247  : 	if( !src || !dst ) return; 

	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN3@SV_Convert
	cmp	DWORD PTR _dst$[ebp], 0
	jne	SHORT $LN2@SV_Convert
$LN3@SV_Convert:
	jmp	$LN1@SV_Convert
$LN2@SV_Convert:

; 248  : 
; 249  : 	dst->fAllSolid = src->allsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 250  : 	dst->fStartSolid = src->startsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 251  : 	dst->fInOpen = src->inopen;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 252  : 	dst->fInWater = src->inwater;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 253  : 	dst->flFraction = src->fraction;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 254  : 	VectorCopy( src->endpos, dst->vecEndPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+ecx+20], eax

; 255  : 	dst->flPlaneDist = src->plane.dist;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+32], edx

; 256  : 	VectorCopy( src->plane.normal, dst->vecPlaneNormal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+32]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx+32]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+36], eax

; 257  : 	dst->pHit = src->ent;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 258  : 	dst->iHitgroup = src->hitgroup;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx

; 259  : 
; 260  : 	// g-cont: always reset config flags when trace is finished
; 261  : 	svgame.globals->trace_flags = 0;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+132], 0
$LN1@SV_Convert:

; 262  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ConvertTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_GetEntvarsDescirption
_TEXT	SEGMENT
_number$ = 8						; size = 4
_SV_GetEntvarsDescirption PROC				; COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 96   : 	if( number < 0 && number >= ENTVARS_COUNT )

	cmp	DWORD PTR _number$[ebp], 0
	jge	SHORT $LN2@SV_GetEntv
	cmp	DWORD PTR _number$[ebp], 14		; 0000000eH
	jb	SHORT $LN2@SV_GetEntv

; 97   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_GetEntv
$LN2@SV_GetEntv:

; 98   : 	return &gEntvarsDescription[number];

	mov	eax, DWORD PTR _number$[ebp]
	shl	eax, 4
	add	eax, OFFSET _gEntvarsDescription
$LN1@SV_GetEntv:

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetEntvarsDescirption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_Localinfo
_TEXT	SEGMENT
_SV_Localinfo PROC					; COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 137  : 	return svs.localinfo;

	mov	eax, OFFSET _svs+572

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Localinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_EdictNum
_TEXT	SEGMENT
_n$ = 8							; size = 4
_SV_EdictNum PROC					; COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 40   : 	if(( n >= 0 ) && ( n < GI->max_edicts ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@SV_EdictNu
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN2@SV_EdictNu

; 41   : 		return svgame.edicts + n;

	imul	eax, DWORD PTR _n$[ebp], 900
	add	eax, DWORD PTR _svgame+7928
	jmp	SHORT $LN1@SV_EdictNu
$LN2@SV_EdictNu:

; 42   : 	return NULL;	

	xor	eax, eax
$LN1@SV_EdictNu:

; 43   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EdictNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnGetCurrentPlayer
_TEXT	SEGMENT
_idx$ = -4						; size = 4
_pfnGetCurrentPlayer PROC				; COMDAT

; 4104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4105 : 	int	idx = sv.current_client - svs.clients;

	mov	eax, DWORD PTR _sv+40
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	mov	DWORD PTR _idx$[ebp], eax

; 4106 : 
; 4107 : 	if( idx < 0 || idx >= svs.maxclients )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@pfnGetCurr
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jl	SHORT $LN2@pfnGetCurr
$LN3@pfnGetCurr:

; 4108 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetCurr
$LN2@pfnGetCurr:

; 4109 : 	return idx;

	mov	eax, DWORD PTR _idx$[ebp]
$LN1@pfnGetCurr:

; 4110 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetCurrentPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_RestartStaticEnts
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_RestartStaticEnts PROC				; COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 553  : 	int	i;
; 554  : 
; 555  : 	// remove all the static entities on the client
; 556  : 	R_ClearStaticEntities();

	call	_R_ClearStaticEntities

; 557  : 
; 558  : 	// resend them again
; 559  : 	for( i = 0; i < sv.num_static_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _sv+726212
	jge	SHORT $LN1@SV_Restart

; 560  : 		SV_CreateStaticEntity( &sv.reliable_datagram, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET _sv+2431724
	call	_SV_CreateStaticEntity
	add	esp, 8
	jmp	SHORT $LN2@SV_Restart
$LN1@SV_Restart:

; 561  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartStaticEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_RestartDecals
_TEXT	SEGMENT
_i$ = -20						; size = 4
_msg$ = -16						; size = 4
_modelIndex$ = -12					; size = 4
_decalIndex$ = -8					; size = 4
_entry$ = -4						; size = 4
_SV_RestartDecals PROC					; COMDAT

; 610  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 611  : 	decallist_t	*entry;
; 612  : 	int		decalIndex;
; 613  : 	int		modelIndex;
; 614  : 	sizebuf_t		*msg;
; 615  : 	int		i;
; 616  : 
; 617  : 	if( !SV_Active( )) return;

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@SV_Restart
	jmp	$LN1@SV_Restart
$LN5@SV_Restart:

; 618  : 
; 619  : 	// g-cont. add space for studiodecals if present
; 620  : 	host.decalList = (decallist_t *)Z_Calloc( sizeof( decallist_t ) * MAX_RENDER_DECALS * 2 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_RestartDecals@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	1114112					; 00110000H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _host+34764, eax

; 621  : 	host.numdecals = R_CreateDecalList( host.decalList );

	mov	eax, DWORD PTR _host+34764
	push	eax
	call	_R_CreateDecalList
	add	esp, 4
	mov	DWORD PTR _host+34768, eax

; 622  : 
; 623  : 	// remove decals from map
; 624  : 	R_ClearAllDecals();

	call	_R_ClearAllDecals

; 625  : 
; 626  : 	// write decals into reliable datagram
; 627  : 	msg = SV_GetReliableDatagram();

	call	_SV_GetReliableDatagram
	mov	DWORD PTR _msg$[ebp], eax

; 628  : 
; 629  : 	// restore decals and write them into network message
; 630  : 	for( i = 0; i < host.numdecals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+34768
	jge	$LN3@SV_Restart

; 631  : 	{
; 632  : 		entry = &host.decalList[i];

	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, DWORD PTR _host+34764
	mov	DWORD PTR _entry$[ebp], eax

; 633  : 		modelIndex = pfnPEntityOfEntIndex( entry->entityIndex )->v.modelindex;

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	mov	edx, DWORD PTR [eax+308]
	mov	DWORD PTR _modelIndex$[ebp], edx

; 634  : 
; 635  : 		// game override
; 636  : 		if( SV_RestoreCustomDecal( entry, pfnPEntityOfEntIndex( entry->entityIndex ), false ))

	push	0
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_SV_RestoreCustomDecal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SV_Restart

; 637  : 			continue;

	jmp	SHORT $LN2@SV_Restart
$LN6@SV_Restart:

; 638  : 
; 639  : 		decalIndex = pfnDecalIndex( entry->name );

	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_pfnDecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 640  : 
; 641  : 		// studiodecals will be restored at game-side
; 642  : 		if( !FBitSet( entry->flags, FDECAL_STUDIO ))

	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN7@SV_Restart

; 643  : 			SV_CreateDecal( msg, entry->position, decalIndex, entry->entityIndex, modelIndex, entry->flags, entry->scale );

	mov	eax, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _entry$[ebp]
	movzx	edx, BYTE PTR [ecx+79]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	movsx	edx, WORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN7@SV_Restart:

; 644  : 	}

	jmp	$LN2@SV_Restart
$LN3@SV_Restart:

; 645  : 
; 646  : 	Z_Free( host.decalList );

	cmp	DWORD PTR _host+34764, 0
	je	SHORT $LN8@SV_Restart
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_RestartDecals@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _host+34764
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@SV_Restart:

; 647  : 	host.decalList = NULL;

	mov	DWORD PTR _host+34764, 0

; 648  : 	host.numdecals = 0;

	mov	DWORD PTR _host+34768, 0
$LN1@SV_Restart:

; 649  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_RestartAmbientSounds
_TEXT	SEGMENT
_si$1 = -29212						; size = 4
_onLoop$ = -29208					; size = 4
_numLoop$ = -29204					; size = 4
_position$ = -29200					; size = 4
_nSounds$ = -29196					; size = 4
_i$ = -29192						; size = 4
_looptrack$ = -29188					; size = 256
_curtrack$ = -28932					; size = 256
_soundInfo$ = -28676					; size = 28672
__$ArrayPad$ = -4					; size = 4
_SV_RestartAmbientSounds PROC				; COMDAT

; 571  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 29724				; 0000741cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 572  : 	soundlist_t	soundInfo[256];
; 573  : 	string		curtrack, looptrack;
; 574  : 	int		i, nSounds;
; 575  : 	long		position;
; 576  : 	int			numLoop;
; 577  : 	int			onLoop;
; 578  : 
; 579  : 	if( !SV_Active( )) return;

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@SV_Restart
	jmp	$LN8@SV_Restart
$LN5@SV_Restart:

; 580  : 
; 581  : 	nSounds = S_GetCurrentStaticSounds( soundInfo, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _soundInfo$[ebp]
	push	eax
	call	_S_GetCurrentStaticSounds
	add	esp, 8
	mov	DWORD PTR _nSounds$[ebp], eax

; 582  : 	
; 583  : 	for( i = 0; i < nSounds; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nSounds$[ebp]
	jge	$LN3@SV_Restart

; 584  : 	{
; 585  : 		soundlist_t *si = &soundInfo[i];

	imul	eax, DWORD PTR _i$[ebp], 112
	lea	ecx, DWORD PTR _soundInfo$[ebp+eax]
	mov	DWORD PTR _si$1[ebp], ecx

; 586  : 
; 587  : 		if( !si->looping || si->entnum == -1 )

	mov	eax, DWORD PTR _si$1[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN7@SV_Restart
	mov	eax, DWORD PTR _si$1[ebp]
	movsx	ecx, WORD PTR [eax+64]
	cmp	ecx, -1
	jne	SHORT $LN6@SV_Restart
$LN7@SV_Restart:

; 588  : 			continue;

	jmp	SHORT $LN2@SV_Restart
$LN6@SV_Restart:

; 589  : 
; 590  : 		S_StopSound( si->entnum, si->channel, si->name );

	mov	eax, DWORD PTR _si$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _si$1[ebp]
	movzx	edx, BYTE PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _si$1[ebp]
	movsx	ecx, WORD PTR [eax+64]
	push	ecx
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 591  : 		SV_StartSound( pfnPEntityOfEntIndex( si->entnum ), CHAN_STATIC, si->name, si->volume, si->attenuation, 0, si->pitch );

	mov	eax, DWORD PTR _si$1[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	push	0
	mov	edx, DWORD PTR _si$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+84]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _si$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _si$1[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _si$1[ebp]
	movsx	eax, WORD PTR [edx+64]
	push	eax
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 592  : 	}

	jmp	$LN2@SV_Restart
$LN3@SV_Restart:

; 593  : 
; 594  : 	// restart soundtrack
; 595  : 	if( S_StreamGetCurrentState( curtrack, looptrack, &position, &numLoop, &onLoop ))

	lea	eax, DWORD PTR _onLoop$[ebp]
	push	eax
	lea	ecx, DWORD PTR _numLoop$[ebp]
	push	ecx
	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	lea	eax, DWORD PTR _looptrack$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curtrack$[ebp]
	push	ecx
	call	_S_StreamGetCurrentState
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN8@SV_Restart

; 596  : 	{
; 597  : 		Con_Printf("Music has been restored!\n");

	push	OFFSET ??_C@_0BK@MLBIDEPC@Music?5has?5been?5restored?$CB?6@
	call	_Con_Printf
	add	esp, 4

; 598  : 		SV_StartMusic( curtrack, looptrack, position, numLoop, onLoop, true );

	push	1
	mov	eax, DWORD PTR _onLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	push	edx
	lea	eax, DWORD PTR _looptrack$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curtrack$[ebp]
	push	ecx
	call	_SV_StartMusic
	add	esp, 24					; 00000018H
$LN8@SV_Restart:

; 599  : 	}
; 600  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartAmbientSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnRemoveEntity
_TEXT	SEGMENT
tv77 = -68						; size = 4
_e$ = 8							; size = 4
_pfnRemoveEntity PROC					; COMDAT

; 1835 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1836 : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnRemoveEntity@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnRemoveE

; 1837 : 		return;

	jmp	SHORT $LN1@pfnRemoveE
$LN2@pfnRemoveE:

; 1838 : 
; 1839 : 	// never free client or world entity
; 1840 : 	if( NUM_FOR_EDICT( e ) < ( svs.maxclients + 1 ))

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	edx, DWORD PTR _svs+16
	add	edx, 1
	cmp	eax, edx
	jge	SHORT $LN3@pfnRemoveE

; 1841 : 	{
; 1842 : 		Con_Printf( S_ERROR "can't delete %s\n", ( e == EDICT_NUM( 0 )) ? "world" : "client" );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	cmp	DWORD PTR _e$[ebp], eax
	jne	SHORT $LN5@pfnRemoveE
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_05MCBCHHEJ@world@
	jmp	SHORT $LN6@pfnRemoveE
$LN5@pfnRemoveE:
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_06DGDLPBAN@client@
$LN6@pfnRemoveE:
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@ODNHFHLH@?$FO1Error?3?$FO7?5can?8t?5delete?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1843 : 		return;

	jmp	SHORT $LN1@pfnRemoveE
$LN3@pfnRemoveE:

; 1844 : 	}
; 1845 : 
; 1846 : 	SV_FreeEdict( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4
$LN1@pfnRemoveE:

; 1847 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRemoveEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnModelIndex
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_pfnModelIndex PROC					; COMDAT

; 1346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1347 : 	char	name[MAX_QPATH];
; 1348 : 	int	i;
; 1349 : 
; 1350 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnModelIn

; 1351 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnModelIn
$LN5@pfnModelIn:

; 1352 : 
; 1353 : 	if( *m == '\\' || *m == '/' ) m++;

	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@pfnModelIn
	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@pfnModelIn
$LN7@pfnModelIn:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN6@pfnModelIn:

; 1354 : 	Q_strncpy( name, m, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1355 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1356 : 
; 1357 : 	for( i = 1; i < MAX_MODELS && sv.model_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnModelIn
$LN2@pfnModelIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnModelIn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnModelIn
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+196]
	test	eax, eax
	je	SHORT $LN3@pfnModelIn

; 1358 : 	{
; 1359 : 		if( !Q_stricmp( sv.model_precache[i], name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnModelIn

; 1360 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@pfnModelIn
$LN8@pfnModelIn:

; 1361 : 	}

	jmp	SHORT $LN2@pfnModelIn
$LN3@pfnModelIn:

; 1362 : 
; 1363 : 	Con_Printf( S_ERROR "no precache: %s\n", name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@OEJNFNMH@?$FO1Error?3?$FO7?5no?5precache?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1364 : 	return 0; 

	xor	eax, eax
$LN1@pfnModelIn:

; 1365 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnModelIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPrecacheModel
_TEXT	SEGMENT
_i$ = -8						; size = 4
_optional$ = -4						; size = 4
_s$ = 8							; size = 4
_pfnPrecacheModel PROC					; COMDAT

; 1257 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1258 : 	qboolean	optional = false;

	mov	DWORD PTR _optional$[ebp], 0

; 1259 : 	int	i;
; 1260 : 
; 1261 : 	if( *s == '!' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN2@pfnPrecach

; 1262 : 	{
; 1263 : 		optional = true;

	mov	DWORD PTR _optional$[ebp], 1

; 1264 : 		*s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN2@pfnPrecach:

; 1265 : 	}
; 1266 : 
; 1267 : 	if(( i = SV_ModelIndex( s )) == 0 )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_SV_ModelIndex
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@pfnPrecach

; 1268 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnPrecach
$LN3@pfnPrecach:

; 1269 : 
; 1270 : 	sv.models[i] = Mod_ForName( sv.model_precache[i], false, true );

	push	1
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sv[ecx*4+722116], eax

; 1271 : 
; 1272 : 	if( !optional )

	cmp	DWORD PTR _optional$[ebp], 0
	jne	SHORT $LN4@pfnPrecach

; 1273 : 		SetBits( sv.model_precache_flags[i], RES_FATALIFMISSING );

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _sv[eax+721092]
	or	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _sv[edx+721092], cl
$LN4@pfnPrecach:

; 1274 : 
; 1275 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@pfnPrecach:

; 1276 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPrecacheModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetFatPAS
_TEXT	SEGMENT
tv174 = -100						; size = 4
tv153 = -100						; size = 4
_offset$1 = -32						; size = 12
_viewPos$2 = -20					; size = 12
_fullvis$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_pfnSetFatPAS PROC					; COMDAT

; 3989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3990 : 	qboolean	fullvis = false;

	mov	DWORD PTR _fullvis$[ebp], 0

; 3991 : 
; 3992 : 	if( !sv.worldmodel->visdata || sv_novis->value || !org || CL_DisableVisibility( ))

	mov	eax, DWORD PTR _sv+2595644
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN3@pfnSetFatP
	mov	eax, DWORD PTR _sv_novis
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@pfnSetFatP
	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@pfnSetFatP
	call	_CL_DisableVisibility
	test	eax, eax
	je	SHORT $LN2@pfnSetFatP
$LN3@pfnSetFatP:

; 3993 : 		fullvis = true;

	mov	DWORD PTR _fullvis$[ebp], 1
$LN2@pfnSetFatP:

; 3994 : 
; 3995 : 	ASSERT( pfnGetCurrentPlayer() != -1 );

	call	_pfnGetCurrentPlayer
	cmp	eax, -1
	jne	SHORT $LN4@pfnSetFatP
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetFatPAS@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@pfnSetFatP:

; 3996 : 
; 3997 : 	// portals can't change viewpoint!
; 3998 : 	if( !FBitSet( sv.hostflags, SVF_MERGE_VISIBILITY ))

	mov	eax, DWORD PTR _sv+44
	and	eax, 2
	jne	$LN5@pfnSetFatP

; 3999 : 	{
; 4000 : 		vec3_t	viewPos, offset;
; 4001 : 
; 4002 : 		// see code from client.cpp for understanding:
; 4003 : 		// org = pView->v.origin + pView->v.view_ofs;
; 4004 : 		// if ( pView->v.flags & FL_DUCKING )
; 4005 : 		// {
; 4006 : 		//	org = org + ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
; 4007 : 		// }
; 4008 : 		// so we have unneeded duck calculations who have affect when player
; 4009 : 		// is ducked into water. Remove offset to restore right PVS position
; 4010 : 		if( FBitSet( sv.current_client->edict->v.flags, FL_DUCKING ))

	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR [ecx+656]
	and	edx, 16384				; 00004000H
	je	$LN7@pfnSetFatP

; 4011 : 		{
; 4012 : 			VectorSubtract( svgame.pmove->player_mins[0], svgame.pmove->player_mins[1], offset );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$1[ebp+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [esi+eax+324856]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$1[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+324856]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv153[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv153[ebp]
	movss	DWORD PTR _offset$1[ebp+edx], xmm0

; 4013 : 			VectorSubtract( org, offset, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _viewPos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _viewPos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$1[ebp+ecx]
	movss	DWORD PTR tv174[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR _viewPos$2[ebp+eax], xmm0

; 4014 : 		}

	jmp	SHORT $LN8@pfnSetFatP
$LN7@pfnSetFatP:

; 4015 : 		else VectorCopy( org, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _viewPos$2[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _viewPos$2[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _viewPos$2[ebp+ecx], eax
$LN8@pfnSetFatP:

; 4016 : 
; 4017 : 		// build a new PHS frame
; 4018 : 		Mod_FatPVS( viewPos, FATPHS_RADIUS, fatphs, world.fatbytes, false, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _viewPos$2[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 4019 : 	}

	jmp	SHORT $LN6@pfnSetFatP
$LN5@pfnSetFatP:

; 4020 : 	else
; 4021 : 	{
; 4022 : 		// merge PHS
; 4023 : 		Mod_FatPVS( org, FATPHS_RADIUS, fatphs, world.fatbytes, true, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN6@pfnSetFatP:

; 4024 : 	}
; 4025 : 
; 4026 : 	return fatphs;

	mov	eax, OFFSET _fatphs

; 4027 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetFatPAS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnSetFatPVS
_TEXT	SEGMENT
tv214 = -100						; size = 4
tv174 = -100						; size = 4
tv153 = -100						; size = 4
_offset$1 = -32						; size = 12
_viewPos$2 = -20					; size = 12
_fullvis$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_pfnSetFatPVS PROC					; COMDAT

; 3939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3940 : 	qboolean	fullvis = false;

	mov	DWORD PTR _fullvis$[ebp], 0

; 3941 : 
; 3942 : 	if( !sv.worldmodel->visdata || sv_novis->value || !org || CL_DisableVisibility( ))

	mov	eax, DWORD PTR _sv+2595644
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN3@pfnSetFatP
	mov	eax, DWORD PTR _sv_novis
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@pfnSetFatP
	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@pfnSetFatP
	call	_CL_DisableVisibility
	test	eax, eax
	je	SHORT $LN2@pfnSetFatP
$LN3@pfnSetFatP:

; 3943 : 		fullvis = true;

	mov	DWORD PTR _fullvis$[ebp], 1
$LN2@pfnSetFatP:

; 3944 : 
; 3945 : 	ASSERT( pfnGetCurrentPlayer() != -1 );

	call	_pfnGetCurrentPlayer
	cmp	eax, -1
	jne	SHORT $LN4@pfnSetFatP
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSetFatPVS@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@pfnSetFatP:

; 3946 : 
; 3947 : 	// portals can't change viewpoint!
; 3948 : 	if( !FBitSet( sv.hostflags, SVF_MERGE_VISIBILITY ))

	mov	eax, DWORD PTR _sv+44
	and	eax, 2
	jne	$LN5@pfnSetFatP

; 3949 : 	{
; 3950 : 		vec3_t	viewPos, offset;
; 3951 : 
; 3952 : 		// see code from client.cpp for understanding:
; 3953 : 		// org = pView->v.origin + pView->v.view_ofs;
; 3954 : 		// if ( pView->v.flags & FL_DUCKING )
; 3955 : 		// {
; 3956 : 		//	org = org + ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
; 3957 : 		// }
; 3958 : 		// so we have unneeded duck calculations who have affect when player
; 3959 : 		// is ducked into water. Remove offset to restore right PVS position
; 3960 : 		if( FBitSet( sv.current_client->edict->v.flags, FL_DUCKING ))

	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR [ecx+656]
	and	edx, 16384				; 00004000H
	je	$LN7@pfnSetFatP

; 3961 : 		{
; 3962 : 			VectorSubtract( svgame.pmove->player_mins[0], svgame.pmove->player_mins[1], offset );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$1[ebp+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [esi+eax+324856]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$1[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+324856]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv153[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv153[ebp]
	movss	DWORD PTR _offset$1[ebp+edx], xmm0

; 3963 : 			VectorSubtract( org, offset, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _viewPos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _viewPos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$1[ebp+ecx]
	movss	DWORD PTR tv174[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR _viewPos$2[ebp+eax], xmm0

; 3964 : 		}

	jmp	SHORT $LN8@pfnSetFatP
$LN7@pfnSetFatP:

; 3965 : 		else VectorCopy( org, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _viewPos$2[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _viewPos$2[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _viewPos$2[ebp+ecx], eax
$LN8@pfnSetFatP:

; 3966 : 
; 3967 : 		// build a new PVS frame
; 3968 : 		Mod_FatPVS( viewPos, FATPVS_RADIUS, fatpvs, world.fatbytes, false, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatpvs
	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _viewPos$2[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 3969 : 		VectorCopy( viewPos, viewPoint[pfnGetCurrentPlayer()] );

	mov	eax, 4
	imul	esi, eax, 0
	call	_pfnGetCurrentPlayer
	imul	ecx, eax, 12
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _viewPos$2[ebp+esi]
	mov	DWORD PTR _viewPoint[ecx+eax], edx
	mov	esi, 4
	shl	esi, 0
	call	_pfnGetCurrentPlayer
	imul	eax, eax, 12
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _viewPos$2[ebp+esi]
	mov	DWORD PTR _viewPoint[eax+ecx], edx
	call	_pfnGetCurrentPlayer
	imul	eax, eax, 12
	mov	ecx, 4
	shl	ecx, 1
	lea	edx, DWORD PTR _viewPoint[eax+ecx]
	mov	DWORD PTR tv214[ebp], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR tv214[ebp]
	mov	edx, DWORD PTR _viewPos$2[ebp+eax]
	mov	DWORD PTR [ecx], edx

; 3970 : 	}

	jmp	SHORT $LN6@pfnSetFatP
$LN5@pfnSetFatP:

; 3971 : 	else
; 3972 : 	{
; 3973 : 		// merge PVS
; 3974 : 		Mod_FatPVS( org, FATPVS_RADIUS, fatpvs, world.fatbytes, true, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatpvs
	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN6@pfnSetFatP:

; 3975 : 	}
; 3976 : 
; 3977 : 	return fatpvs;

	mov	eax, OFFSET _fatpvs

; 3978 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetFatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnWriteBytes
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
_count$ = 12						; size = 4
_pfnWriteBytes PROC					; COMDAT

; 2800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2801 : 	MSG_WriteBytes( &sv.multicast, bytes, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	push	OFFSET _sv+2448128
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 2802 : 	svgame.msg_realsize += count;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _svgame+7888, eax

; 2803 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnIndexOfEdict
_TEXT	SEGMENT
_number$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_pfnIndexOfEdict PROC					; COMDAT

; 3100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3101 : 	int	number;
; 3102 : 
; 3103 : 	if( !pEdict ) return 0; // world ?

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $LN2@pfnIndexOf
	xor	eax, eax
	jmp	SHORT $LN1@pfnIndexOf
$LN2@pfnIndexOf:

; 3104 : 
; 3105 : 	number = NUM_FOR_EDICT( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _number$[ebp], eax

; 3106 : 	if( number < 0 || number > GI->max_edicts )

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN4@pfnIndexOf
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _number$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jle	SHORT $LN3@pfnIndexOf
$LN4@pfnIndexOf:

; 3107 : 		Host_Error( "bad entity number %d\n", number );

	mov	eax, DWORD PTR _number$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@JOJIMKK@bad?5entity?5number?5?$CFd?6@
	call	_Host_Error
	add	esp, 8
$LN3@pfnIndexOf:

; 3108 : 	return number;

	mov	eax, DWORD PTR _number$[ebp]
$LN1@pfnIndexOf:

; 3109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIndexOfEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_SendUserReg
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_user$ = 12						; size = 4
_SV_SendUserReg PROC					; COMDAT

; 3189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3190 : 	MSG_BeginServerCmd( msg, svc_usermessage );

	push	0
	push	1
	push	39					; 00000027H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3191 : 	MSG_WriteByte( msg, user->number );

	mov	eax, DWORD PTR _user$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 3192 : 	MSG_WriteWord( msg, (word)user->size );

	mov	eax, DWORD PTR _user$[ebp]
	movzx	ecx, WORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8

; 3193 : 	MSG_WriteString( msg, user->name );

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 3194 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendUserReg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CreateStaticEntity
_TEXT	SEGMENT
_offset$ = -468						; size = 4
_state$ = -464						; size = 4
_baseline$ = -460					; size = 4
_nullstate$ = -456					; size = 452
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_index$ = 12						; size = 4
_SV_CreateStaticEntity PROC				; COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 532				; 00000214H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 503  : 	entity_state_t	nullstate, *baseline;	
; 504  : 	entity_state_t	*state;
; 505  : 	int		offset;
; 506  : 
; 507  : 	if( index >= ( MAX_STATIC_ENTITIES - 1 ))

	cmp	DWORD PTR _index$[ebp], 3095		; 00000c17H
	jl	SHORT $LN2@SV_CreateS

; 508  : 	{
; 509  : 		if( !sv.static_ents_overflow )

	cmp	DWORD PTR _sv+2595668, 0
	jne	SHORT $LN3@SV_CreateS

; 510  : 		{
; 511  : 			Con_Printf( S_WARN "MAX_STATIC_ENTITIES limit exceeded (%d)\n", MAX_STATIC_ENTITIES );

	push	3096					; 00000c18H
	push	OFFSET ??_C@_0DG@DMOKJIDJ@?$FO3Warning?3?$FO7?5MAX_STATIC_ENTITIE@
	call	_Con_Printf
	add	esp, 8

; 512  : 			sv.static_ents_overflow = true;

	mov	DWORD PTR _sv+2595668, 1
$LN3@SV_CreateS:

; 513  : 		}
; 514  : 
; 515  : 		sv.ignored_static_ents++; // continue overflowed entities

	mov	eax, DWORD PTR _sv+2595660
	add	eax, 1
	mov	DWORD PTR _sv+2595660, eax

; 516  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CreateS
$LN2@SV_CreateS:

; 517  : 	}
; 518  : 
; 519  : 	// this can happens if serialized map contain too many static entities...
; 520  : 	if( MSG_GetNumBytesLeft( msg ) < 50 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN4@SV_CreateS

; 521  : 	{
; 522  : 		sv.ignored_static_ents++;

	mov	eax, DWORD PTR _sv+2595660
	add	eax, 1
	mov	DWORD PTR _sv+2595660, eax

; 523  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CreateS
$LN4@SV_CreateS:

; 524  : 	}
; 525  : 
; 526  : 	state = &svs.static_entities[index]; // allocate a new one

	imul	eax, DWORD PTR _index$[ebp], 452
	add	eax, DWORD PTR _svs+33364
	mov	DWORD PTR _state$[ebp], eax

; 527  : 	memset( &nullstate, 0, sizeof( nullstate ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _nullstate$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 528  : 	baseline = &nullstate;

	lea	eax, DWORD PTR _nullstate$[ebp]
	mov	DWORD PTR _baseline$[ebp], eax

; 529  : 
; 530  : 	// restore modelindex from modelname (already precached)
; 531  : 	state->modelindex = pfnModelIndex( STRING( state->messagenum ));

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	call	_pfnModelIndex
	add	esp, 4
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], eax

; 532  : 	state->entityType = ENTITY_NORMAL; // select delta-encode

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax], 1

; 533  : 	state->number = 0;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4], 0

; 534  : 
; 535  : 	// trying to compress with previous delta's
; 536  : 	offset = SV_FindBestBaselineForStatic( index, &baseline, state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	call	_SV_FindBestBaselineForStatic
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _offset$[ebp], eax

; 537  : 
; 538  : 	MSG_BeginServerCmd( msg, svc_spawnstatic );

	push	0
	push	1
	push	20					; 00000014H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 539  : 	MSG_WriteDeltaEntity( baseline, state, msg, true, DELTA_STATIC, sv.time, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseline$[ebp]
	push	eax
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 540  : 
; 541  : 	return true;

	mov	eax, 1
$LN1@SV_CreateS:

; 542  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_FindGlobalEntity
_TEXT	SEGMENT
_pent$ = -4						; size = 4
_classname$ = 8						; size = 4
_globalname$ = 12					; size = 4
_SV_FindGlobalEntity PROC				; COMDAT

; 1573 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1574 : 	edict_t *pent = SV_FindEntityByString( NULL,  "globalname", STRING( globalname ));

	mov	eax, DWORD PTR _globalname$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0L@JILCNGEO@globalname@
	push	0
	call	_SV_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pent$[ebp], eax

; 1575 : 
; 1576 : 	if( SV_IsValidEdict( pent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FindGlobalEntity@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_FindGlo

; 1577 : 	{
; 1578 : 		// don't spam about error - game code already tell us
; 1579 : 		if( Q_strcmp( SV_ClassName( pent ), STRING( classname )))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _classname$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_FindGlo

; 1580 : 			pent = NULL;

	mov	DWORD PTR _pent$[ebp], 0
$LN2@SV_FindGlo:

; 1581 : 	}
; 1582 : 
; 1583 : 	return pent;

	mov	eax, DWORD PTR _pent$[ebp]

; 1584 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindGlobalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_MapIsValid
_TEXT	SEGMENT
tv71 = -2648						; size = 4
_check_name$1 = -2324					; size = 256
_token$2 = -2068					; size = 2048
_need_landmark$3 = -20					; size = 4
_ents$ = -16						; size = 4
_pfile$ = -12						; size = 4
_flags$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_spawn_entity$ = 12					; size = 4
_landmark_name$ = 16					; size = 4
_SV_MapIsValid PROC					; COMDAT

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2648				; 00000a58H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 873  : 	int	flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 874  : 	char	*pfile;
; 875  : 	char	*ents;
; 876  : 
; 877  : 	ents = SV_ReadEntityScript( filename, &flags );

	lea	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_SV_ReadEntityScript
	add	esp, 8
	mov	DWORD PTR _ents$[ebp], eax

; 878  : 
; 879  : 	if( ents )

	cmp	DWORD PTR _ents$[ebp], 0
	je	$LN4@SV_MapIsVa

; 880  : 	{
; 881  : 		qboolean	need_landmark = Q_strlen( landmark_name ) > 0 ? true : false;

	mov	eax, DWORD PTR _landmark_name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN14@SV_MapIsVa
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN15@SV_MapIsVa
$LN14@SV_MapIsVa:
	mov	DWORD PTR tv71[ebp], 0
$LN15@SV_MapIsVa:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _need_landmark$3[ebp], ecx

; 882  : 		char	token[2048];
; 883  : 		string	check_name;
; 884  : 
; 885  : 		// g-cont. in-dev mode we can entering on map even without "info_player_start"
; 886  : 		if( !need_landmark && host_developer.value )

	cmp	DWORD PTR _need_landmark$3[ebp], 0
	jne	SHORT $LN5@SV_MapIsVa
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@SV_MapIsVa

; 887  : 		{
; 888  : 			// not transition 
; 889  : 			Mem_Free( ents );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_MapIsValid@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 890  : 
; 891  : 			// skip spawnpoint checks in devmode
; 892  : 			return (flags|MAP_HAS_SPAWNPOINT);

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	jmp	$LN1@SV_MapIsVa
$LN5@SV_MapIsVa:

; 893  : 		}
; 894  : 
; 895  : 		pfile = ents;

	mov	eax, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@SV_MapIsVa:

; 896  : 
; 897  : 		while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@SV_MapIsVa

; 898  : 		{
; 899  : 			if( !Q_strcmp( token, "classname" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09CNJINBGN@classname@
	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_MapIsVa

; 900  : 			{
; 901  : 				// check classname for spawn entity
; 902  : 				pfile = COM_ParseFile( pfile, check_name );

	lea	eax, DWORD PTR _check_name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 903  : 				if( !Q_strcmp( spawn_entity, check_name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _check_name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _spawn_entity$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_MapIsVa

; 904  : 				{
; 905  : 					SetBits( flags, MAP_HAS_SPAWNPOINT );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	mov	DWORD PTR _flags$[ebp], eax

; 906  : 
; 907  : 					// we already find landmark, stop the parsing
; 908  : 					if( need_landmark && FBitSet( flags, MAP_HAS_LANDMARK ))

	cmp	DWORD PTR _need_landmark$3[ebp], 0
	je	SHORT $LN9@SV_MapIsVa
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN9@SV_MapIsVa

; 909  : 						break;

	jmp	SHORT $LN3@SV_MapIsVa
$LN9@SV_MapIsVa:

; 910  : 				}
; 911  : 			}

	jmp	SHORT $LN12@SV_MapIsVa
$LN6@SV_MapIsVa:

; 912  : 			else if( need_landmark && !Q_strcmp( token, "targetname" ))

	cmp	DWORD PTR _need_landmark$3[ebp], 0
	je	SHORT $LN12@SV_MapIsVa
	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@FEPNPAJD@targetname@
	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_MapIsVa

; 913  : 			{
; 914  : 				// check targetname for landmark entity
; 915  : 				pfile = COM_ParseFile( pfile, check_name );

	lea	eax, DWORD PTR _check_name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 916  : 
; 917  : 				if( !Q_strcmp( landmark_name, check_name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _check_name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _landmark_name$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_MapIsVa

; 918  : 				{
; 919  : 					SetBits( flags, MAP_HAS_LANDMARK );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4
	mov	DWORD PTR _flags$[ebp], eax

; 920  : 
; 921  : 					// we already find spawnpoint, stop the parsing
; 922  : 					if( FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN12@SV_MapIsVa

; 923  : 						break;

	jmp	SHORT $LN3@SV_MapIsVa
$LN12@SV_MapIsVa:

; 924  : 				}
; 925  : 			}
; 926  : 		}

	jmp	$LN2@SV_MapIsVa
$LN3@SV_MapIsVa:

; 927  : 
; 928  : 		Mem_Free( ents );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_MapIsValid@@9@9
	add	eax, 56					; 00000038H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_MapIsVa:

; 929  : 	}
; 930  : 
; 931  : 	return flags;

	mov	eax, DWORD PTR _flags$[ebp]
$LN1@SV_MapIsVa:

; 932  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MapIsValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_ClientFromEdict
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_spawned_only$ = 12					; size = 4
_SV_ClientFromEdict PROC				; COMDAT

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1224 : 	int	i;
; 1225 : 
; 1226 : 	if( !SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClientFromEdict@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_ClientF

; 1227 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN2@SV_ClientF:

; 1228 : 
; 1229 : 	i = NUM_FOR_EDICT( pEdict ) - 1;

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1230 : 
; 1231 : 	if( i < 0 || i >= svs.maxclients )

	js	SHORT $LN4@SV_ClientF
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jl	SHORT $LN3@SV_ClientF
$LN4@SV_ClientF:

; 1232 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN3@SV_ClientF:

; 1233 : 
; 1234 : 	if( spawned_only )

	cmp	DWORD PTR _spawned_only$[ebp], 0
	je	SHORT $LN5@SV_ClientF

; 1235 : 	{
; 1236 : 		if( svs.clients[i].state != cs_spawned )

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 3
	je	SHORT $LN5@SV_ClientF

; 1237 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN5@SV_ClientF:

; 1238 : 	}
; 1239 : 
; 1240 : 	return (svs.clients + i);

	imul	eax, DWORD PTR _i$[ebp], 289832
	add	eax, DWORD PTR _svs+33344
$LN1@SV_ClientF:

; 1241 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClientFromEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_GetString
_TEXT	SEGMENT
_iString$ = 8						; size = 4
_SV_GetString PROC					; COMDAT

; 3052 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3053 : 	if( svgame.physFuncs.pfnGetString != NULL )

	cmp	DWORD PTR _svgame+19564, 0
	je	SHORT $LN2@SV_GetStri

; 3054 : 		return svgame.physFuncs.pfnGetString( iString );

	mov	eax, DWORD PTR _iString$[ebp]
	push	eax
	call	DWORD PTR _svgame+19564
	add	esp, 4
	jmp	SHORT $LN1@SV_GetStri
$LN2@SV_GetStri:

; 3055 : 	return (svgame.globals->pStringBase + iString);

	mov	eax, DWORD PTR _svgame+19268
	mov	eax, DWORD PTR [eax+156]
	add	eax, DWORD PTR _iString$[ebp]
$LN1@SV_GetStri:

; 3056 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_MakeString
_TEXT	SEGMENT
_szValue$ = 8						; size = 4
_SV_MakeString PROC					; COMDAT

; 3038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3039 : 	if( svgame.physFuncs.pfnMakeString != NULL )

	cmp	DWORD PTR _svgame+19560, 0
	je	SHORT $LN2@SV_MakeStr

; 3040 : 		return svgame.physFuncs.pfnMakeString( szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	call	DWORD PTR _svgame+19560
	add	esp, 4
	jmp	SHORT $LN1@SV_MakeStr
$LN2@SV_MakeStr:

; 3041 : 	return szValue - svgame.globals->pStringBase;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _szValue$[ebp]
	sub	ecx, DWORD PTR [eax+156]
	mov	eax, ecx
$LN1@SV_MakeStr:

; 3042 : }		

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MakeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_AllocString
_TEXT	SEGMENT
_l$ = -16						; size = 4
_i$ = -12						; size = 4
_out_p$ = -8						; size = 4
_out$ = -4						; size = 4
_szString$ = 8						; size = 4
_SV_AllocString PROC					; COMDAT

; 3002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 3003 : 	char	*out, *out_p;
; 3004 : 	int	i, l;
; 3005 : 
; 3006 : 	if( svgame.physFuncs.pfnAllocString != NULL )

	cmp	DWORD PTR _svgame+19556, 0
	je	SHORT $LN5@SV_AllocSt

; 3007 : 		return svgame.physFuncs.pfnAllocString( szString );

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	call	DWORD PTR _svgame+19556
	add	esp, 4
	jmp	$LN1@SV_AllocSt
$LN5@SV_AllocSt:

; 3008 : 
; 3009 : 	if( !COM_CheckString( szString ))

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_AllocSt

; 3010 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_AllocSt
$LN6@SV_AllocSt:

; 3011 : 
; 3012 : 	l = Q_strlen( szString ) + 1;

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 3013 : 
; 3014 : 	out = out_p = Mem_Calloc( svgame.stringspool, l );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_AllocString@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+19592
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out_p$[ebp], eax
	mov	eax, DWORD PTR _out_p$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 3015 : 	for( i = 0; i < l; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_AllocSt
$LN2@SV_AllocSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_AllocSt:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	jge	SHORT $LN3@SV_AllocSt

; 3016 : 	{
; 3017 : 		if( szString[i] == '\\' && i < l - 1 )

	mov	eax, DWORD PTR _szString$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN7@SV_AllocSt
	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN7@SV_AllocSt

; 3018 : 		{
; 3019 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 3020 : 			if( szString[i] == 'n')

	mov	eax, DWORD PTR _szString$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 110				; 0000006eH
	jne	SHORT $LN9@SV_AllocSt

; 3021 : 				*out_p++ = '\n';

	mov	eax, DWORD PTR _out_p$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _out_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out_p$[ebp], ecx
	jmp	SHORT $LN10@SV_AllocSt
$LN9@SV_AllocSt:

; 3022 : 			else *out_p++ = '\\';

	mov	eax, DWORD PTR _out_p$[ebp]
	mov	BYTE PTR [eax], 92			; 0000005cH
	mov	ecx, DWORD PTR _out_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out_p$[ebp], ecx
$LN10@SV_AllocSt:

; 3023 : 		}

	jmp	SHORT $LN8@SV_AllocSt
$LN7@SV_AllocSt:

; 3024 : 		else *out_p++ = szString[i];

	mov	eax, DWORD PTR _szString$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out_p$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _out_p$[ebp], eax
$LN8@SV_AllocSt:

; 3025 : 	}

	jmp	SHORT $LN2@SV_AllocSt
$LN3@SV_AllocSt:

; 3026 : 
; 3027 : 	return out - svgame.globals->pStringBase;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR [eax+156]
	mov	eax, ecx
$LN1@SV_AllocSt:

; 3028 : }		

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CreateNamedEntity
_TEXT	SEGMENT
_ed$ = -4						; size = 4
_ent$ = 8						; size = 4
_className$ = 12					; size = 4
_SV_CreateNamedEntity PROC				; COMDAT

; 1125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1126 : 	edict_t *ed = SV_AllocPrivateData( ent, className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_AllocPrivateData
	add	esp, 8
	mov	DWORD PTR _ed$[ebp], eax

; 1127 : 	
; 1128 : 	// for some reasons this flag should be immediately cleared
; 1129 : 	if( ed ) ClearBits( ed->v.flags, FL_CUSTOMENTITY );

	cmp	DWORD PTR _ed$[ebp], 0
	je	SHORT $LN2@SV_CreateN
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -536870913				; dfffffffH
	mov	edx, DWORD PTR _ed$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN2@SV_CreateN:

; 1130 : 
; 1131 : 	return ed;

	mov	eax, DWORD PTR _ed$[ebp]

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateNamedEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_AllocPrivateData
_TEXT	SEGMENT
_SpawnEdict$ = -8					; size = 4
_pszClassName$ = -4					; size = 4
_ent$ = 8						; size = 4
_className$ = 12					; size = 4
_SV_AllocPrivateData PROC				; COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1070 : 	const char	*pszClassName;
; 1071 : 	LINK_ENTITY_FUNC	SpawnEdict;
; 1072 : 
; 1073 : 	pszClassName = STRING( className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pszClassName$[ebp], eax

; 1074 : 
; 1075 : 	if( !ent )

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN2@SV_AllocPr

; 1076 : 	{
; 1077 : 		// allocate a new one
; 1078 : 		ent = SV_AllocEdict();

	call	_SV_AllocEdict
	mov	DWORD PTR _ent$[ebp], eax

; 1079 : 	}

	jmp	SHORT $LN3@SV_AllocPr
$LN2@SV_AllocPr:

; 1080 : 	else if( ent->free )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@SV_AllocPr

; 1081 : 	{
; 1082 : 		SV_InitEdict( ent ); // re-init edict

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4
$LN3@SV_AllocPr:

; 1083 : 	}
; 1084 : 
; 1085 : 	ent->v.classname = className;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _className$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 1086 : 	ent->v.pContainingEntity = ent; // re-link

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+744], ecx

; 1087 : 	
; 1088 : 	// allocate edict private memory (passed by dlls)
; 1089 : 	SpawnEdict = SV_GetEntityClass( pszClassName );

	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	_SV_GetEntityClass
	add	esp, 4
	mov	DWORD PTR _SpawnEdict$[ebp], eax

; 1090 : 
; 1091 : 	if( !SpawnEdict )

	cmp	DWORD PTR _SpawnEdict$[ebp], 0
	jne	SHORT $LN5@SV_AllocPr

; 1092 : 	{
; 1093 : 		// attempt to create custom entity (Xash3D extension)
; 1094 : 		if( svgame.physFuncs.SV_CreateEntity && svgame.physFuncs.SV_CreateEntity( ent, pszClassName ) != -1 )

	cmp	DWORD PTR _svgame+19496, 0
	je	SHORT $LN6@SV_AllocPr
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19496
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN6@SV_AllocPr

; 1095 : 			return ent;

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	SHORT $LN1@SV_AllocPr
$LN6@SV_AllocPr:

; 1096 : 
; 1097 : 		SpawnEdict = SV_GetEntityClass( "custom" );

	push	OFFSET ??_C@_06EKNFNOKI@custom@
	call	_SV_GetEntityClass
	add	esp, 4
	mov	DWORD PTR _SpawnEdict$[ebp], eax

; 1098 : 
; 1099 : 		if( !SpawnEdict )

	cmp	DWORD PTR _SpawnEdict$[ebp], 0
	jne	SHORT $LN7@SV_AllocPr

; 1100 : 		{
; 1101 : 			Con_Printf( S_ERROR "No spawn function for %s\n", STRING( className ));

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CF@HONNHMII@?$FO1Error?3?$FO7?5No?5spawn?5function?5fo@
	call	_Con_Printf
	add	esp, 8

; 1102 : 
; 1103 : 			// free entity immediately
; 1104 : 			SV_FreeEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4

; 1105 : 
; 1106 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_AllocPr
$LN7@SV_AllocPr:

; 1107 : 		}
; 1108 : 
; 1109 : 		SetBits( ent->v.flags, FL_CUSTOMENTITY ); // it's a custom entity but not a beam!

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN5@SV_AllocPr:

; 1110 : 	}
; 1111 : 
; 1112 : 	SpawnEdict( &ent->v );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	DWORD PTR _SpawnEdict$[ebp]
	add	esp, 4

; 1113 : 
; 1114 : 	return ent;

	mov	eax, DWORD PTR _ent$[ebp]
$LN1@SV_AllocPr:

; 1115 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_SpawnEntities
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_mapname$ = 8						; size = 4
_SV_SpawnEntities PROC					; COMDAT

; 4744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4745 : 	edict_t	*ent;
; 4746 : 
; 4747 : 	// reset misc parms
; 4748 : 	Cvar_Reset( "sv_zmax" );

	push	OFFSET ??_C@_07BOLPGMIP@sv_zmax@
	call	_Cvar_Reset
	add	esp, 4

; 4749 : 	Cvar_Reset( "sv_wateramp" );

	push	OFFSET ??_C@_0M@COFDEJEF@sv_wateramp@
	call	_Cvar_Reset
	add	esp, 4

; 4750 : 	Cvar_Reset( "sv_wateralpha" );

	push	OFFSET ??_C@_0O@IFEMIFOJ@sv_wateralpha@
	call	_Cvar_Reset
	add	esp, 4

; 4751 : 
; 4752 : 	// reset sky parms	
; 4753 : 	Cvar_Reset( "sv_skycolor_r" );

	push	OFFSET ??_C@_0O@CGCGGHO@sv_skycolor_r@
	call	_Cvar_Reset
	add	esp, 4

; 4754 : 	Cvar_Reset( "sv_skycolor_g" );

	push	OFFSET ??_C@_0O@DFNHIAGK@sv_skycolor_g@
	call	_Cvar_Reset
	add	esp, 4

; 4755 : 	Cvar_Reset( "sv_skycolor_b" );

	push	OFFSET ??_C@_0O@EIKAHECP@sv_skycolor_b@
	call	_Cvar_Reset
	add	esp, 4

; 4756 : 	Cvar_Reset( "sv_skyvec_x" );

	push	OFFSET ??_C@_0M@JBBFCNJL@sv_skyvec_x@
	call	_Cvar_Reset
	add	esp, 4

; 4757 : 	Cvar_Reset( "sv_skyvec_y" );

	push	OFFSET ??_C@_0M@IIAOBMNK@sv_skyvec_y@
	call	_Cvar_Reset
	add	esp, 4

; 4758 : 	Cvar_Reset( "sv_skyvec_z" );

	push	OFFSET ??_C@_0M@KDCDEPBJ@sv_skyvec_z@
	call	_Cvar_Reset
	add	esp, 4

; 4759 : 	Cvar_Reset( "sv_skyname" );

	push	OFFSET ??_C@_0L@NPFKENCH@sv_skyname@
	call	_Cvar_Reset
	add	esp, 4

; 4760 : 	Cvar_Reset("sv_skydir_x");

	push	OFFSET ??_C@_0M@PCFOFDPA@sv_skydir_x@
	call	_Cvar_Reset
	add	esp, 4

; 4761 : 	Cvar_Reset("sv_skydir_y");

	push	OFFSET ??_C@_0M@OLEFGCLB@sv_skydir_y@
	call	_Cvar_Reset
	add	esp, 4

; 4762 : 	Cvar_Reset("sv_skydir_z");

	push	OFFSET ??_C@_0M@MAGIDBHC@sv_skydir_z@
	call	_Cvar_Reset
	add	esp, 4

; 4763 : 	Cvar_Reset("sv_skyangle");

	push	OFFSET ??_C@_0M@KODFIOCL@sv_skyangle@
	call	_Cvar_Reset
	add	esp, 4

; 4764 : 	Cvar_Reset("sv_skyspeed");

	push	OFFSET ??_C@_0M@IDDIMGBN@sv_skyspeed@
	call	_Cvar_Reset
	add	esp, 4

; 4765 : 
; 4766 : 	ent = EDICT_NUM( 0 );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 4767 : 	if( ent->free ) SV_InitEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SV_SpawnEn
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4
$LN2@SV_SpawnEn:

; 4768 : 	ent->v.model = MAKE_STRING( sv.model_precache[1] );

	mov	eax, 64					; 00000040H
	shl	eax, 0
	add	eax, OFFSET _sv+196
	push	eax
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 4769 : 	ent->v.modelindex = WORLD_INDEX; // world model

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+308], 1

; 4770 : 	ent->v.solid = SOLID_BSP;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+400], 4

; 4771 : 	ent->v.movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+396], 7

; 4772 : 	svgame.movevars.fog_settings = 0;

	mov	DWORD PTR _svgame+8088, 0

; 4773 : 
; 4774 : 	svgame.globals->maxEntities = GI->max_edicts;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1656]
	mov	DWORD PTR [eax+152], edx

; 4775 : 	svgame.globals->mapname = MAKE_STRING( sv.name );

	push	OFFSET _sv+56
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _svgame+19268
	mov	DWORD PTR [ecx+12], eax

; 4776 : 	svgame.globals->startspot = MAKE_STRING( sv.startspot );

	push	OFFSET _sv+120
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _svgame+19268
	mov	DWORD PTR [ecx+16], eax

; 4777 : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 4778 : 
; 4779 : 	// spawn the rest of the entities on the map
; 4780 : 	SV_LoadFromFile( mapname, sv.worldmodel->entities );

	mov	eax, DWORD PTR _sv+2595644
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	mov	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_SV_LoadFromFile
	add	esp, 8

; 4781 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SpawnEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_AngleMod
_TEXT	SEGMENT
_move$ = -4						; size = 4
_ideal$ = 8						; size = 4
_current$ = 12						; size = 4
_speed$ = 16						; size = 4
_SV_AngleMod PROC					; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 149  : 	float	move;
; 150  : 
; 151  : 	current = anglemod( current );

	push	ecx
	movss	xmm0, DWORD PTR _current$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	fstp	DWORD PTR _current$[ebp]

; 152  : 
; 153  : 	if( current == ideal ) // already there?

	movss	xmm0, DWORD PTR _current$[ebp]
	ucomiss	xmm0, DWORD PTR _ideal$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SV_AngleMo

; 154  : 		return current; 

	fld	DWORD PTR _current$[ebp]
	jmp	$LN1@SV_AngleMo
$LN2@SV_AngleMo:

; 155  : 
; 156  : 	move = ideal - current;

	movss	xmm0, DWORD PTR _ideal$[ebp]
	subss	xmm0, DWORD PTR _current$[ebp]
	movss	DWORD PTR _move$[ebp], xmm0

; 157  : 
; 158  : 	if( ideal > current )

	movss	xmm0, DWORD PTR _ideal$[ebp]
	comiss	xmm0, DWORD PTR _current$[ebp]
	jbe	SHORT $LN3@SV_AngleMo

; 159  : 	{
; 160  : 		if( move >= 180 )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jb	SHORT $LN5@SV_AngleMo

; 161  : 			move = move - 360;

	movss	xmm0, DWORD PTR _move$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _move$[ebp], xmm0
$LN5@SV_AngleMo:

; 162  : 	}

	jmp	SHORT $LN6@SV_AngleMo
$LN3@SV_AngleMo:

; 163  : 	else
; 164  : 	{
; 165  : 		if( move <= -180 )

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _move$[ebp]
	jb	SHORT $LN6@SV_AngleMo

; 166  : 			move = move + 360;

	movss	xmm0, DWORD PTR _move$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _move$[ebp], xmm0
$LN6@SV_AngleMo:

; 167  : 	}
; 168  : 
; 169  : 	if( move > 0 )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@SV_AngleMo

; 170  : 	{
; 171  : 		if( move > speed )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN9@SV_AngleMo

; 172  : 			move = speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _move$[ebp], xmm0
$LN9@SV_AngleMo:

; 173  : 	}

	jmp	SHORT $LN10@SV_AngleMo
$LN7@SV_AngleMo:

; 174  : 	else
; 175  : 	{
; 176  : 		if( move < -speed )

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _move$[ebp]
	jbe	SHORT $LN10@SV_AngleMo

; 177  : 			move = -speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _move$[ebp], xmm0
$LN10@SV_AngleMo:

; 178  : 	}
; 179  : 
; 180  : 	return anglemod( current + move );

	movss	xmm0, DWORD PTR _current$[ebp]
	addss	xmm0, DWORD PTR _move$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
$LN1@SV_AngleMo:

; 181  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AngleMod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_WriteEntityPatch
_TEXT	SEGMENT
_entities$1 = -1308					; size = 4
_f$ = -1304						; size = 4
_header$ = -1300					; size = 4
_bspfilename$ = -1296					; size = 256
_buf$ = -1040						; size = 1024
_lumplen$ = -16						; size = 4
_lumpofs$ = -12						; size = 4
_ver$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_WriteEntityPatch PROC				; COMDAT

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1500				; 000005dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 759  : 	int		ver = -1, lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _ver$[ebp], -1
	mov	DWORD PTR _lumpofs$[ebp], 0
	mov	DWORD PTR _lumplen$[ebp], 0

; 760  : 	byte		buf[MAX_SYSPATH]; // 1 kb
; 761  : 	string		bspfilename;
; 762  : 	dheader_t		*header;
; 763  : 	file_t		*f;
; 764  : 
; 765  : 	Q_strncpy( bspfilename, va( "maps/%s.bsp", filename ), sizeof( bspfilename ));			

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 766  : 	f = FS_Open( bspfilename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _bspfilename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 767  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@SV_WriteEn
	jmp	$LN1@SV_WriteEn
$LN2@SV_WriteEn:

; 768  : 
; 769  : 	memset( buf, 0, MAX_SYSPATH );

	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 770  : 	FS_Read( f, buf, MAX_SYSPATH );

	push	1024					; 00000400H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 771  : 	header = (dheader_t *)buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 772  : 
; 773  : 	// check all the lumps and some other errors
; 774  : 	if( !Mod_TestBmodelLumps( bspfilename, buf, true ))

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_WriteEn

; 775  : 	{
; 776  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 777  : 		return;

	jmp	$LN1@SV_WriteEn
$LN3@SV_WriteEn:

; 778  : 	}
; 779  : 
; 780  : 	lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lumpofs$[ebp], eax

; 781  : 	lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _lumplen$[ebp], eax

; 782  : 
; 783  : 	if( lumplen >= 10 )

	cmp	DWORD PTR _lumplen$[ebp], 10		; 0000000aH
	jl	$LN4@SV_WriteEn

; 784  : 	{
; 785  : 		char	*entities = NULL;

	mov	DWORD PTR _entities$1[ebp], 0

; 786  : 		
; 787  : 		FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lumpofs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 788  : 		entities = (char *)Z_Calloc( lumplen + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_WriteEntityPatch@@9@9
	add	eax, 30					; 0000001eH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _lumplen$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _entities$1[ebp], eax

; 789  : 		FS_Read( f, entities, lumplen );

	mov	eax, DWORD PTR _lumplen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entities$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 790  : 		FS_WriteFile( va( "maps/%s.ent", filename ), entities, lumplen );

	mov	eax, DWORD PTR _lumplen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entities$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@NHJMLCCE@maps?1?$CFs?4ent@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 791  : 		Con_Printf( "Write 'maps/%s.ent'\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@KEIEKBBM@Write?5?8maps?1?$CFs?4ent?8?6@
	call	_Con_Printf
	add	esp, 8

; 792  : 		Mem_Free( entities );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_WriteEntityPatch@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _entities$1[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_WriteEn:

; 793  : 	}
; 794  : 
; 795  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@SV_WriteEn:

; 796  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteEntityPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_QueueChangeLevel
_TEXT	SEGMENT
_spawn_entity$ = -80					; size = 4
_mapname$ = -76						; size = 64
_smooth$ = -12						; size = 4
_flags$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_landname$ = 12						; size = 4
_SV_QueueChangeLevel PROC				; COMDAT

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 674  : 	int	flags, smooth = false;

	mov	DWORD PTR _smooth$[ebp], 0

; 675  : 	char	mapname[MAX_QPATH];
; 676  : 	char	*spawn_entity;
; 677  : 
; 678  : 	// hold mapname to other place
; 679  : 	Q_strncpy( mapname, level, sizeof( mapname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 680  : 	COM_StripExtension( mapname );

	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 681  : 
; 682  : 	if( COM_CheckString( landname ))

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SV_QueueCh

; 683  : 		smooth = true;

	mov	DWORD PTR _smooth$[ebp], 1
$LN2@SV_QueueCh:

; 684  : 
; 685  : 	// determine spawn entity classname
; 686  : 	if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN3@SV_QueueCh

; 687  : 		spawn_entity = GI->sp_entity;

	mov	eax, DWORD PTR _SI+768
	add	eax, 1304				; 00000518H
	mov	DWORD PTR _spawn_entity$[ebp], eax
	jmp	SHORT $LN4@SV_QueueCh
$LN3@SV_QueueCh:

; 688  : 	else spawn_entity = GI->mp_entity;

	mov	eax, DWORD PTR _SI+768
	add	eax, 1336				; 00000538H
	mov	DWORD PTR _spawn_entity$[ebp], eax
$LN4@SV_QueueCh:

; 689  : 
; 690  : 	flags = SV_MapIsValid( mapname, spawn_entity, landname );

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spawn_entity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 691  : 
; 692  : 	if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN5@SV_QueueCh

; 693  : 	{
; 694  : 		Con_Printf( S_ERROR "changelevel: %s is invalid or not supported\n", mapname );

	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@GMIJDHAN@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5is?5i@
	call	_Con_Printf
	add	esp, 8

; 695  : 		return;

	jmp	$LN16@SV_QueueCh
$LN5@SV_QueueCh:

; 696  : 	}
; 697  : 	
; 698  : 	if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	jne	SHORT $LN6@SV_QueueCh

; 699  : 	{
; 700  : 		Con_Printf( S_ERROR "changelevel: map %s doesn't exist\n", mapname );

	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@FDLMDCIC@?$FO1Error?3?$FO7?5changelevel?3?5map?5?$CFs?5@
	call	_Con_Printf
	add	esp, 8

; 701  : 		return;

	jmp	$LN16@SV_QueueCh
$LN6@SV_QueueCh:

; 702  : 	}
; 703  : 
; 704  : 	if( smooth && !FBitSet( flags, MAP_HAS_LANDMARK ))

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN8@SV_QueueCh
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN8@SV_QueueCh

; 705  : 	{
; 706  : 		if( sv_validate_changelevel->value )

	mov	eax, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SV_QueueCh

; 707  : 		{
; 708  : 			// NOTE: we find valid map but specified landmark it's doesn't exist
; 709  : 			// run simple changelevel like in q1, throw warning
; 710  : 			Con_Printf( S_WARN "changelevel: %s doesn't contain landmark [%s]. smooth transition was disabled\n", mapname, landname );

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FM@HPNEIPFC@?$FO3Warning?3?$FO7?5changelevel?3?5?$CFs?5do@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 711  : 			smooth = false;

	mov	DWORD PTR _smooth$[ebp], 0
$LN8@SV_QueueCh:

; 712  : 		}
; 713  : 	}
; 714  : 
; 715  : 	if( svs.maxclients > 1 )

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN9@SV_QueueCh

; 716  : 		smooth = false; // multiplayer doesn't support smooth transition

	mov	DWORD PTR _smooth$[ebp], 0
$LN9@SV_QueueCh:

; 717  : 
; 718  : 	if( smooth && !Q_stricmp( sv.name, level ))

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN10@SV_QueueCh
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET _sv+56
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SV_QueueCh

; 719  : 	{
; 720  : 		Con_Printf( S_ERROR "can't changelevel with same map. Ignored.\n" );

	push	OFFSET ??_C@_0DG@GJJHOCIH@?$FO1Error?3?$FO7?5can?8t?5changelevel?5wi@
	call	_Con_Printf
	add	esp, 4

; 721  : 		return;	

	jmp	$LN16@SV_QueueCh
$LN10@SV_QueueCh:

; 722  : 	}
; 723  : 
; 724  : 	if( !smooth && !FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	cmp	DWORD PTR _smooth$[ebp], 0
	jne	SHORT $LN12@SV_QueueCh
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	SHORT $LN12@SV_QueueCh

; 725  : 	{
; 726  : 		if( sv_validate_changelevel->value )

	mov	eax, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_QueueCh

; 727  : 		{
; 728  : 			Con_Printf( S_ERROR "changelevel: %s doesn't have a valid spawnpoint. Ignored.\n", mapname );

	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET ??_C@_0EG@OMEDMDNK@?$FO1Error?3?$FO7?5changelevel?3?5?$CFs?5does@
	call	_Con_Printf
	add	esp, 8

; 729  : 			return;	

	jmp	SHORT $LN16@SV_QueueCh
$LN12@SV_QueueCh:

; 730  : 		}
; 731  : 	}
; 732  : 
; 733  : 	// bad changelevel position invoke enables in one-way transition
; 734  : 	if( sv.framecount < 15 )

	cmp	DWORD PTR _sv+36, 15			; 0000000fH
	jge	SHORT $LN14@SV_QueueCh

; 735  : 	{
; 736  : 		if( sv_validate_changelevel->value )

	mov	eax, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@SV_QueueCh

; 737  : 		{
; 738  : 			Con_Printf( S_WARN "an infinite changelevel was detected and will be disabled until a next save\\restore\n" );

	push	OFFSET ??_C@_0GC@ICGACPNE@?$FO3Warning?3?$FO7?5an?5infinite?5change@
	call	_Con_Printf
	add	esp, 4

; 739  : 			return; // lock with svs.spawncount here

	jmp	SHORT $LN16@SV_QueueCh
$LN14@SV_QueueCh:

; 740  : 		}
; 741  : 	}
; 742  : 
; 743  : 	SV_SkipUpdates ();

	call	_SV_SkipUpdates

; 744  : 
; 745  : 	// changelevel will be executed on a next frame
; 746  : 	if( smooth ) COM_ChangeLevel( mapname, landname, sv.background );	// Smoothed Half-Life changelevel

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN15@SV_QueueCh
	mov	eax, DWORD PTR _sv+4
	push	eax
	mov	ecx, DWORD PTR _landname$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_COM_ChangeLevel
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@SV_QueueCh
$LN15@SV_QueueCh:

; 747  : 	else COM_ChangeLevel( mapname, NULL, sv.background );		// Classic Quake changlevel

	mov	eax, DWORD PTR _sv+4
	push	eax
	push	0
	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	call	_COM_ChangeLevel
	add	esp, 12					; 0000000cH
$LN16@SV_QueueCh:

; 748  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_QueueChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_BoxInPVS
_TEXT	SEGMENT
_org$ = 8						; size = 4
_absmin$ = 12						; size = 4
_absmax$ = 16						; size = 4
_SV_BoxInPVS PROC					; COMDAT

; 659  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 660  : 	if( !Mod_BoxVisible( absmin, absmax, Mod_GetPVSForPoint( org )))

	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _absmax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _absmin$[ebp]
	push	edx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_BoxInPV

; 661  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_BoxInPV
$LN2@SV_BoxInPV:

; 662  : 	return true;

	mov	eax, 1
$LN1@SV_BoxInPV:

; 663  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BoxInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_BuildSoundMsg
_TEXT	SEGMENT
tv95 = -84						; size = 4
tv87 = -84						; size = 4
tv80 = -84						; size = 4
tv71 = -84						; size = 4
tv169 = -80						; size = 4
tv94 = -80						; size = 4
tv86 = -80						; size = 4
tv79 = -80						; size = 4
tv70 = -80						; size = 4
_spawn$ = -12						; size = 4
_sound_idx$ = -8					; size = 4
_entityIndex$ = -4					; size = 4
_msg$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_sample$ = 20						; size = 4
_vol$ = 24						; size = 4
_attn$ = 28						; size = 4
_flags$ = 32						; size = 4
_pitch$ = 36						; size = 4
_pos$ = 40						; size = 4
_SV_BuildSoundMsg PROC					; COMDAT

; 1989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1990 : 	int	entityIndex;
; 1991 : 	int	sound_idx;
; 1992 : 	qboolean	spawn;
; 1993 : 
; 1994 : 	if( vol < 0 || vol > 255 )

	cmp	DWORD PTR _vol$[ebp], 0
	jl	SHORT $LN3@SV_BuildSo
	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	jle	SHORT $LN2@SV_BuildSo
$LN3@SV_BuildSo:

; 1995 : 	{
; 1996 : 		Con_Reportf( S_ERROR "SV_StartSound: volume = %i\n", vol );

	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@DPGAHNFB@?$FO1Error?3?$FO7?5SV_StartSound?3?5volum@
	call	_Con_Reportf
	add	esp, 8

; 1997 : 		vol = bound( 0, vol, 255 );

	cmp	DWORD PTR _vol$[ebp], 0
	jl	SHORT $LN34@SV_BuildSo
	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	jge	SHORT $LN32@SV_BuildSo
	mov	eax, DWORD PTR _vol$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN33@SV_BuildSo
$LN32@SV_BuildSo:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN33@SV_BuildSo:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN35@SV_BuildSo
$LN34@SV_BuildSo:
	mov	DWORD PTR tv71[ebp], 0
$LN35@SV_BuildSo:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _vol$[ebp], edx
$LN2@SV_BuildSo:

; 1998 : 	}
; 1999 : 
; 2000 : 	if( attn < 0.0f || attn > 4.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _attn$[ebp]
	ja	SHORT $LN5@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN4@SV_BuildSo
$LN5@SV_BuildSo:

; 2001 : 	{
; 2002 : 		Con_Reportf( S_ERROR "SV_StartSound: attenuation %g must be in range 0-4\n", attn );

	cvtss2sd xmm0, DWORD PTR _attn$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0DP@DGGLGLAC@?$FO1Error?3?$FO7?5SV_StartSound?3?5atten@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2003 : 		attn = bound( 0.0f, attn, 4.0f );

	movss	xmm0, DWORD PTR _attn$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN38@SV_BuildSo
	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR _attn$[ebp]
	jbe	SHORT $LN36@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN37@SV_BuildSo
$LN36@SV_BuildSo:
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR tv79[ebp], xmm0
$LN37@SV_BuildSo:
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN39@SV_BuildSo
$LN38@SV_BuildSo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[ebp], xmm0
$LN39@SV_BuildSo:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR _attn$[ebp], xmm0
$LN4@SV_BuildSo:

; 2004 : 	}
; 2005 : 
; 2006 : 	if( chan < CHAN_MIN_NORMAL || chan > CHAN_MAX_NORMAL )

	cmp	DWORD PTR _chan$[ebp], 0
	jl	SHORT $LN7@SV_BuildSo
	cmp	DWORD PTR _chan$[ebp], 15		; 0000000fH
	jle	SHORT $LN6@SV_BuildSo
$LN7@SV_BuildSo:

; 2007 : 	{
; 2008 : 		Con_Reportf( S_ERROR "SV_StartSound: channel must be in range 0-7\n" );

	push	OFFSET ??_C@_0DI@DIDLBLOO@?$FO1Error?3?$FO7?5SV_StartSound?3?5chann@
	call	_Con_Reportf
	add	esp, 4

; 2009 : 		chan = bound(CHAN_MIN_NORMAL, chan, CHAN_MAX_NORMAL);

	cmp	DWORD PTR _chan$[ebp], 0
	jl	SHORT $LN42@SV_BuildSo
	cmp	DWORD PTR _chan$[ebp], 15		; 0000000fH
	jge	SHORT $LN40@SV_BuildSo
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN41@SV_BuildSo
$LN40@SV_BuildSo:
	mov	DWORD PTR tv86[ebp], 15			; 0000000fH
$LN41@SV_BuildSo:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], ecx
	jmp	SHORT $LN43@SV_BuildSo
$LN42@SV_BuildSo:
	mov	DWORD PTR tv87[ebp], 0
$LN43@SV_BuildSo:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _chan$[ebp], edx
$LN6@SV_BuildSo:

; 2010 : 	}
; 2011 : 
; 2012 : 	if( pitch < 0 || pitch > 255 )

	cmp	DWORD PTR _pitch$[ebp], 0
	jl	SHORT $LN9@SV_BuildSo
	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jle	SHORT $LN8@SV_BuildSo
$LN9@SV_BuildSo:

; 2013 : 	{
; 2014 : 		Con_Reportf( S_ERROR "SV_StartSound: pitch = %i\n", pitch );

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	push	OFFSET ??_C@_0CG@KAOAFKMC@?$FO1Error?3?$FO7?5SV_StartSound?3?5pitch@
	call	_Con_Reportf
	add	esp, 8

; 2015 : 		pitch = bound( 0, pitch, 255 );

	cmp	DWORD PTR _pitch$[ebp], 0
	jl	SHORT $LN46@SV_BuildSo
	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jge	SHORT $LN44@SV_BuildSo
	mov	eax, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN45@SV_BuildSo
$LN44@SV_BuildSo:
	mov	DWORD PTR tv94[ebp], 255		; 000000ffH
$LN45@SV_BuildSo:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	jmp	SHORT $LN47@SV_BuildSo
$LN46@SV_BuildSo:
	mov	DWORD PTR tv95[ebp], 0
$LN47@SV_BuildSo:
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _pitch$[ebp], edx
$LN8@SV_BuildSo:

; 2016 : 	}
; 2017 : 
; 2018 : 	if( !COM_CheckString( sample ))

	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@SV_BuildSo

; 2019 : 	{
; 2020 : 		Con_Reportf( S_ERROR "SV_StartSound: passed NULL sample\n" );

	push	OFFSET ??_C@_0CO@PHKOJBD@?$FO1Error?3?$FO7?5SV_StartSound?3?5passe@
	call	_Con_Reportf
	add	esp, 4

; 2021 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_BuildSo
$LN10@SV_BuildSo:

; 2022 : 	}
; 2023 : 
; 2024 : 	if( sample[0] == '!' && Q_isdigit( sample + 1 ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sample$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN11@SV_BuildSo
	mov	eax, DWORD PTR _sample$[ebp]
	add	eax, 1
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@SV_BuildSo

; 2025 : 	{
; 2026 : 		sound_idx = Q_atoi( sample + 1 );

	mov	eax, DWORD PTR _sample$[ebp]
	add	eax, 1
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax

; 2027 : 
; 2028 : 		if( sound_idx >= MAX_SOUNDS )

	cmp	DWORD PTR _sound_idx$[ebp], 8192	; 00002000H
	jl	SHORT $LN13@SV_BuildSo

; 2029 : 		{
; 2030 : 			SetBits( flags, SND_SENTENCE|SND_SEQUENCE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 20					; 00000014H
	mov	DWORD PTR _flags$[ebp], eax

; 2031 : 			sound_idx -= MAX_SOUNDS;

	mov	eax, DWORD PTR _sound_idx$[ebp]
	sub	eax, 8192				; 00002000H
	mov	DWORD PTR _sound_idx$[ebp], eax

; 2032 : 		}

	jmp	SHORT $LN14@SV_BuildSo
$LN13@SV_BuildSo:

; 2033 : 		else SetBits( flags, SND_SENTENCE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _flags$[ebp], eax
$LN14@SV_BuildSo:

; 2034 : 	}

	jmp	SHORT $LN16@SV_BuildSo
$LN11@SV_BuildSo:

; 2035 : 	else if( sample[0] == '#' && Q_isdigit( sample + 1 ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sample$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN15@SV_BuildSo
	mov	eax, DWORD PTR _sample$[ebp]
	add	eax, 1
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@SV_BuildSo

; 2036 : 	{
; 2037 : 		SetBits( flags, SND_SENTENCE|SND_SEQUENCE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 20					; 00000014H
	mov	DWORD PTR _flags$[ebp], eax

; 2038 : 		sound_idx = Q_atoi( sample + 1 );

	mov	eax, DWORD PTR _sample$[ebp]
	add	eax, 1
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax

; 2039 : 	}

	jmp	SHORT $LN16@SV_BuildSo
$LN15@SV_BuildSo:

; 2040 : 	else
; 2041 : 	{
; 2042 : 		// TESTTEST
; 2043 : 		if( *sample == '*' ) chan = CHAN_AUTO;

	mov	eax, DWORD PTR _sample$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN17@SV_BuildSo
	mov	DWORD PTR _chan$[ebp], 0
$LN17@SV_BuildSo:

; 2044 : 
; 2045 : 		// precache_sound can be used twice: cache sounds when loading
; 2046 : 		// and return sound index when server is active
; 2047 : 		sound_idx = SV_SoundIndex( sample );

	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	call	_SV_SoundIndex
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax
$LN16@SV_BuildSo:

; 2048 : 	}
; 2049 : 
; 2050 : 	if( !sound_idx )

	cmp	DWORD PTR _sound_idx$[ebp], 0
	jne	SHORT $LN18@SV_BuildSo

; 2051 : 	{
; 2052 : 		Con_Printf( S_ERROR "SV_StartSound: %s not precached (%d)\n", sample, sound_idx );

	mov	eax, DWORD PTR _sound_idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sample$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DB@HNKDPEFJ@?$FO1Error?3?$FO7?5SV_StartSound?3?5?$CFs?5no@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2053 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_BuildSo
$LN18@SV_BuildSo:

; 2054 : 	}
; 2055 : 
; 2056 : 	spawn = FBitSet( flags, SND_RESTORE_POSITION ) ? false : true;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN48@SV_BuildSo
	mov	DWORD PTR tv169[ebp], 0
	jmp	SHORT $LN49@SV_BuildSo
$LN48@SV_BuildSo:
	mov	DWORD PTR tv169[ebp], 1
$LN49@SV_BuildSo:
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR _spawn$[ebp], ecx

; 2057 : 
; 2058 : 	if( SV_IsValidEdict( ent ) && SV_IsValidEdict( ent->v.aiment ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_BuildSoundMsg@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@SV_BuildSo
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_BuildSoundMsg@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@SV_BuildSo

; 2059 : 		entityIndex = NUM_FOR_EDICT( ent->v.aiment );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+640]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN22@SV_BuildSo
$LN19@SV_BuildSo:

; 2060 : 	else if( SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_BuildSoundMsg@@9@9
	add	eax, 71					; 00000047H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_BuildSo

; 2061 : 		entityIndex = NUM_FOR_EDICT( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN22@SV_BuildSo
$LN21@SV_BuildSo:

; 2062 : 	else entityIndex = 0; // assume world

	mov	DWORD PTR _entityIndex$[ebp], 0
$LN22@SV_BuildSo:

; 2063 : 
; 2064 : 	if( vol != 255 ) SetBits( flags, SND_VOLUME );

	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	je	SHORT $LN23@SV_BuildSo
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1
	mov	DWORD PTR _flags$[ebp], eax
$LN23@SV_BuildSo:

; 2065 : 	if( attn != ATTN_NONE ) SetBits( flags, SND_ATTENUATION );

	movss	xmm0, DWORD PTR _attn$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SV_BuildSo
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	mov	DWORD PTR _flags$[ebp], eax
$LN24@SV_BuildSo:

; 2066 : 	if( pitch != PITCH_NORM ) SetBits( flags, SND_PITCH );

	cmp	DWORD PTR _pitch$[ebp], 100		; 00000064H
	je	SHORT $LN25@SV_BuildSo
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 8
	mov	DWORD PTR _flags$[ebp], eax
$LN25@SV_BuildSo:

; 2067 : 
; 2068 : 	// not sending (because this is out of range)
; 2069 : 	ClearBits( flags, SND_RESTORE_POSITION );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -4097				; ffffefffH
	mov	DWORD PTR _flags$[ebp], eax

; 2070 : 	ClearBits( flags, SND_FILTER_CLIENT );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -2049				; fffff7ffH
	mov	DWORD PTR _flags$[ebp], eax

; 2071 : 	ClearBits( flags, SND_SPAWNING );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -257				; fffffeffH
	mov	DWORD PTR _flags$[ebp], eax

; 2072 : 
; 2073 : 	if( spawn ) MSG_BeginServerCmd( msg, svc_sound );

	cmp	DWORD PTR _spawn$[ebp], 0
	je	SHORT $LN26@SV_BuildSo
	push	0
	push	1
	push	6
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
	jmp	SHORT $LN27@SV_BuildSo
$LN26@SV_BuildSo:

; 2074 : 	else MSG_BeginServerCmd( msg, svc_restoresound );

	push	0
	push	1
	push	19					; 00000013H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
$LN27@SV_BuildSo:

; 2075 : 	MSG_WriteUBitLong( msg, flags, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2076 : 	MSG_WriteUBitLong( msg, sound_idx, MAX_SOUND_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _sound_idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2077 : 	MSG_WriteUBitLong( msg, chan, MAX_SND_CHAN_BITS );

	push	4
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2078 : 
; 2079 : 	if( FBitSet( flags, SND_VOLUME )) MSG_WriteByte( msg, vol );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN28@SV_BuildSo
	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN28@SV_BuildSo:

; 2080 : 	if( FBitSet( flags, SND_ATTENUATION )) MSG_WriteByte( msg, attn * 64 );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN29@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	mulss	xmm0, DWORD PTR __real@42800000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN29@SV_BuildSo:

; 2081 : 	if( FBitSet( flags, SND_PITCH )) MSG_WriteByte( msg, pitch );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN30@SV_BuildSo
	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN30@SV_BuildSo:

; 2082 : 
; 2083 : 	MSG_WriteUBitLong( msg, entityIndex, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2084 : 	MSG_WriteVec3Coord( msg, pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 2085 : 
; 2086 : 	return 1;

	mov	eax, 1
$LN1@SV_BuildSo:

; 2087 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BuildSoundMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_PlaybackReliableEvent
_TEXT	SEGMENT
_nullargs$ = -112					; size = 108
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_eventindex$ = 12					; size = 2
_delay$ = 16						; size = 4
_args$ = 20						; size = 4
_SV_PlaybackReliableEvent PROC				; COMDAT

; 1162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1163 : 	event_args_t nullargs;
; 1164 : 
; 1165 : 	memset( &nullargs, 0, sizeof( nullargs ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1166 : 
; 1167 : 	MSG_BeginServerCmd( msg, svc_event_reliable );

	push	0
	push	1
	push	21					; 00000015H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1168 : 
; 1169 : 	// send event index
; 1170 : 	MSG_WriteUBitLong( msg, eventindex, MAX_EVENT_BITS );

	push	10					; 0000000aH
	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1171 : 
; 1172 : 	if( delay )

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_Playbac

; 1173 : 	{
; 1174 : 		// send event delay
; 1175 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 1176 : 		MSG_WriteWord( msg, ( delay * 100.0f ));

	movss	xmm0, DWORD PTR _delay$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1177 : 	}

	jmp	SHORT $LN3@SV_Playbac
$LN2@SV_Playbac:

; 1178 : 	else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN3@SV_Playbac:

; 1179 : 
; 1180 : 	// reliable events not use delta-compression just null-compression
; 1181 : 	MSG_WriteDeltaEvent( msg, &nullargs, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nullargs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteDeltaEvent
	add	esp, 12					; 0000000cH

; 1182 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlaybackReliableEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_PlaybackEventFull
_TEXT	SEGMENT
tv371 = -228						; size = 4
tv283 = -228						; size = 4
tv277 = -228						; size = 4
_ev_name$1 = -160					; size = 4
_pvspoint$ = -156					; size = 12
_mask$ = -144						; size = 4
_invokerIndex$ = -140					; size = 4
_bestslot$ = -136					; size = 4
_slot$ = -132						; size = 4
_j$ = -128						; size = 4
_ei$ = -124						; size = 4
_args$ = -120						; size = 108
_es$ = -12						; size = 4
_cl$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
_pInvoker$ = 12						; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_vparam1$ = 56						; size = 4
_vparam2$ = 60						; size = 4
_aparam1$ = 64						; size = 4
_aparam2$ = 68						; size = 4
_aparam3$ = 72						; size = 1
_SV_PlaybackEventFull PROC				; COMDAT

; 3725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3726 : 	sv_client_t	*cl;
; 3727 : 	event_state_t	*es;
; 3728 : 	event_args_t	args;
; 3729 : 	event_info_t	*ei = NULL;

	mov	DWORD PTR _ei$[ebp], 0

; 3730 : 	int		j, slot, bestslot;
; 3731 : 	int		invokerIndex;
; 3732 : 	byte		*mask = NULL;

	mov	DWORD PTR _mask$[ebp], 0

; 3733 : 	vec3_t		pvspoint;
; 3734 : 
; 3735 : 	if( FBitSet( flags, FEV_CLIENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN11@SV_Playbac

; 3736 : 		return;	// someone stupid joke

	jmp	$LN3@SV_Playbac
$LN11@SV_Playbac:

; 3737 : 
; 3738 : 	// first check event for out of bounds
; 3739 : 	if( eventindex < 1 || eventindex > MAX_EVENTS )

	movzx	eax, WORD PTR _eventindex$[ebp]
	cmp	eax, 1
	jl	SHORT $LN13@SV_Playbac
	movzx	eax, WORD PTR _eventindex$[ebp]
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN12@SV_Playbac
$LN13@SV_Playbac:

; 3740 : 	{
; 3741 : 		Con_Printf( S_ERROR "EV_Playback: invalid eventindex %i\n", eventindex );

	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@PCBGDAKA@?$FO1Error?3?$FO7?5EV_Playback?3?5invalid@
	call	_Con_Printf
	add	esp, 8

; 3742 : 		return;

	jmp	$LN3@SV_Playbac
$LN12@SV_Playbac:

; 3743 : 	}
; 3744 : 
; 3745 : 	// check event for precached
; 3746 : 	if( !COM_CheckString( sv.event_precache[eventindex] ))

	movzx	eax, WORD PTR _eventindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+655556
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_Playbac

; 3747 : 	{
; 3748 : 		Con_Printf( S_ERROR "EV_Playback: event %i was not precached\n", eventindex );

	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@KNGIJMBL@?$FO1Error?3?$FO7?5EV_Playback?3?5event?5?$CF@
	call	_Con_Printf
	add	esp, 8

; 3749 : 		return;		

	jmp	$LN3@SV_Playbac
$LN14@SV_Playbac:

; 3750 : 	}
; 3751 : 
; 3752 : 	memset( &args, 0, sizeof( args ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3753 : 
; 3754 : 	if( origin && !VectorIsNull( origin ))

	cmp	DWORD PTR _origin$[ebp], 0
	je	$LN15@SV_Playbac
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@SV_Playbac
$LN16@SV_Playbac:

; 3755 : 	{
; 3756 : 		VectorCopy( origin, args.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+8], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+8], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+8], eax

; 3757 : 		args.flags |= FEVENT_ORIGIN;

	mov	eax, DWORD PTR _args$[ebp]
	or	eax, 1
	mov	DWORD PTR _args$[ebp], eax
$LN15@SV_Playbac:

; 3758 : 	}
; 3759 : 
; 3760 : 	if( angles && !VectorIsNull( angles ))

	cmp	DWORD PTR _angles$[ebp], 0
	je	$LN17@SV_Playbac
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@SV_Playbac
$LN18@SV_Playbac:

; 3761 : 	{
; 3762 : 		VectorCopy( angles, args.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+20], eax

; 3763 : 		args.flags |= FEVENT_ANGLES;

	mov	eax, DWORD PTR _args$[ebp]
	or	eax, 2
	mov	DWORD PTR _args$[ebp], eax
$LN17@SV_Playbac:

; 3764 : 	}
; 3765 : 
; 3766 : 	if (vparam1 && !VectorIsNull(vparam1))

	cmp	DWORD PTR _vparam1$[ebp], 0
	je	$LN19@SV_Playbac
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vparam1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vparam1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@SV_Playbac
$LN20@SV_Playbac:

; 3767 : 		VectorCopy(vparam1, args.vparam1);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vparam1$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+72], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam1$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+72], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vparam1$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+72], eax
$LN19@SV_Playbac:

; 3768 : 
; 3769 : 	if (vparam2 && !VectorIsNull(vparam2))

	cmp	DWORD PTR _vparam2$[ebp], 0
	je	$LN21@SV_Playbac
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vparam2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vparam2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@SV_Playbac
$LN22@SV_Playbac:

; 3770 : 		VectorCopy(vparam2, args.vparam2);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vparam2$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam2$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vparam2$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+84], eax
$LN21@SV_Playbac:

; 3771 : 
; 3772 : 	// copy other parms
; 3773 : 	args.fparam1 = fparam1;

	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR _args$[ebp+48], xmm0

; 3774 : 	args.fparam2 = fparam2;

	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR _args$[ebp+52], xmm0

; 3775 : 	args.iparam1 = iparam1;

	mov	eax, DWORD PTR _iparam1$[ebp]
	mov	DWORD PTR _args$[ebp+56], eax

; 3776 : 	args.iparam2 = iparam2;

	mov	eax, DWORD PTR _iparam2$[ebp]
	mov	DWORD PTR _args$[ebp+60], eax

; 3777 : 	args.bparam1 = bparam1;

	mov	eax, DWORD PTR _bparam1$[ebp]
	mov	DWORD PTR _args$[ebp+64], eax

; 3778 : 	args.bparam2 = bparam2;

	mov	eax, DWORD PTR _bparam2$[ebp]
	mov	DWORD PTR _args$[ebp+68], eax

; 3779 : 
; 3780 : 	args.aparam1 = aparam1;

	mov	eax, DWORD PTR _aparam1$[ebp]
	mov	DWORD PTR _args$[ebp+96], eax

; 3781 : 	args.aparam2 = aparam2;

	movss	xmm0, DWORD PTR _aparam2$[ebp]
	movss	DWORD PTR _args$[ebp+100], xmm0

; 3782 : 	args.aparam3 = aparam3;

	mov	al, BYTE PTR _aparam3$[ebp]
	mov	BYTE PTR _args$[ebp+104], al

; 3783 : 
; 3784 : 	VectorClear( pvspoint );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+eax], xmm0

; 3785 : 
; 3786 : 	if( SV_IsValidEdict( pInvoker ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PlaybackEventFull@@9@9
	add	eax, 61					; 0000003dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN23@SV_Playbac

; 3787 : 	{
; 3788 : 		// add the view_ofs to avoid problems with crossed contents line
; 3789 : 		VectorAdd( pInvoker->v.origin, pInvoker->v.view_ofs, pvspoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pvspoint$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pvspoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+608]
	movss	DWORD PTR tv277[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _pvspoint$[ebp+eax], xmm0

; 3790 : 		args.entindex = invokerIndex = NUM_FOR_EDICT( pInvoker );

	mov	eax, DWORD PTR _pInvoker$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _invokerIndex$[ebp], eax
	mov	edx, DWORD PTR _invokerIndex$[ebp]
	mov	DWORD PTR _args$[ebp+4], edx

; 3791 : 
; 3792 : 		// g-cont. allow 'ducking' param for all entities
; 3793 : 		args.ducking = FBitSet( pInvoker->v.flags, FL_DUCKING ) ? true : false;

	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN50@SV_Playbac
	mov	DWORD PTR tv283[ebp], 1
	jmp	SHORT $LN51@SV_Playbac
$LN50@SV_Playbac:
	mov	DWORD PTR tv283[ebp], 0
$LN51@SV_Playbac:
	mov	edx, DWORD PTR tv283[ebp]
	mov	DWORD PTR _args$[ebp+44], edx

; 3794 : 
; 3795 : 		// this will be send only for reliable event
; 3796 : 		if( !FBitSet( args.flags, FEVENT_ORIGIN ))

	mov	eax, DWORD PTR _args$[ebp]
	and	eax, 1
	jne	SHORT $LN25@SV_Playbac

; 3797 : 			VectorCopy( pInvoker->v.origin, args.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _args$[ebp+eax+8], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _args$[ebp+eax+8], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _args$[ebp+ecx+8], eax
$LN25@SV_Playbac:

; 3798 : 
; 3799 : 		// this will be send only for reliable event
; 3800 : 		if( !FBitSet( args.flags, FEVENT_ANGLES ))

	mov	eax, DWORD PTR _args$[ebp]
	and	eax, 2
	jne	SHORT $LN26@SV_Playbac

; 3801 : 			VectorCopy( pInvoker->v.angles, args.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _args$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _args$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _args$[ebp+ecx+20], eax
$LN26@SV_Playbac:

; 3802 : 	}

	jmp	SHORT $LN24@SV_Playbac
$LN23@SV_Playbac:

; 3803 : 	else
; 3804 : 	{
; 3805 : 		VectorCopy( args.origin, pvspoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _args$[ebp+ecx+8]
	mov	DWORD PTR _pvspoint$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _args$[ebp+edx+8]
	mov	DWORD PTR _pvspoint$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _args$[ebp+edx+8]
	mov	DWORD PTR _pvspoint$[ebp+eax], ecx

; 3806 : 		args.entindex = 0;

	mov	DWORD PTR _args$[ebp+4], 0

; 3807 : 		invokerIndex = -1;

	mov	DWORD PTR _invokerIndex$[ebp], -1
$LN24@SV_Playbac:

; 3808 : 	}
; 3809 : 
; 3810 : 	if( !FBitSet( flags, FEV_GLOBAL ) && VectorIsNull( pvspoint ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN27@SV_Playbac
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _pvspoint$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _pvspoint$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _pvspoint$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@SV_Playbac

; 3811 :           {
; 3812 : 		Con_DPrintf( S_ERROR "%s: not a FEV_GLOBAL event missing origin. Ignored.\n", sv.event_precache[eventindex] );

	movzx	eax, WORD PTR _eventindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+655556
	push	eax
	push	OFFSET ??_C@_0EA@KCPAHPLE@?$FO1Error?3?$FO7?5?$CFs?3?5not?5a?5FEV_GLOBAL@
	call	_Con_DPrintf
	add	esp, 8

; 3813 : 		return;

	jmp	$LN3@SV_Playbac
$LN27@SV_Playbac:

; 3814 : 	}
; 3815 : 
; 3816 : 	// check event for some user errors
; 3817 : 	if( FBitSet( flags, FEV_NOTHOST|FEV_HOSTONLY ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 17					; 00000011H
	je	SHORT $LN31@SV_Playbac

; 3818 : 	{
; 3819 : 		if( !SV_ClientFromEdict( pInvoker, true ))

	push	1
	mov	eax, DWORD PTR _pInvoker$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@SV_Playbac

; 3820 : 		{
; 3821 : 			const char *ev_name = sv.event_precache[eventindex];

	movzx	eax, WORD PTR _eventindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+655556
	mov	DWORD PTR _ev_name$1[ebp], eax

; 3822 : 
; 3823 : 			if( FBitSet( flags, FEV_NOTHOST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN30@SV_Playbac

; 3824 : 			{
; 3825 : 				Con_DPrintf( S_WARN "%s: specified FEV_NOTHOST when invoker not a client\n", ev_name );

	mov	eax, DWORD PTR _ev_name$1[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@BKEFCDLJ@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@
	call	_Con_DPrintf
	add	esp, 8

; 3826 : 				ClearBits( flags, FEV_NOTHOST );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR _flags$[ebp], eax
$LN30@SV_Playbac:

; 3827 : 			}
; 3828 : 
; 3829 : 			if( FBitSet( flags, FEV_HOSTONLY ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN31@SV_Playbac

; 3830 : 			{
; 3831 : 				Con_DPrintf( S_WARN "%s: specified FEV_HOSTONLY when invoker not a client\n", ev_name );

	mov	eax, DWORD PTR _ev_name$1[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@FODMFBMN@?$FO3Warning?3?$FO7?5?$CFs?3?5specified?5FEV_@
	call	_Con_DPrintf
	add	esp, 8

; 3832 : 				ClearBits( flags, FEV_HOSTONLY );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -17				; ffffffefH
	mov	DWORD PTR _flags$[ebp], eax
$LN31@SV_Playbac:

; 3833 : 			}
; 3834 : 		}
; 3835 : 	}
; 3836 : 
; 3837 : 	SetBits( flags, FEV_SERVER );		// it's a server event!

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _flags$[ebp], eax

; 3838 : 	if( delay < 0.0f ) delay = 0.0f;	// fixup negative delays

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN32@SV_Playbac
	xorps	xmm0, xmm0
	movss	DWORD PTR _delay$[ebp], xmm0
$LN32@SV_Playbac:

; 3839 : 
; 3840 : 	// setup pvs cluster for invoker
; 3841 : 	if( !FBitSet( flags, FEV_GLOBAL ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN33@SV_Playbac

; 3842 : 	{
; 3843 : 		Mod_FatPVS( pvspoint, FATPHS_RADIUS, fatphs, world.fatbytes, false, ( svs.maxclients == 1 ));

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN52@SV_Playbac
	mov	DWORD PTR tv371[ebp], 1
	jmp	SHORT $LN53@SV_Playbac
$LN52@SV_Playbac:
	mov	DWORD PTR tv371[ebp], 0
$LN53@SV_Playbac:
	mov	eax, DWORD PTR tv371[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pvspoint$[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 3844 : 		mask = fatphs; // using the FatPVS like a PHS

	mov	DWORD PTR _mask$[ebp], OFFSET _fatphs
$LN33@SV_Playbac:

; 3845 : 	}
; 3846 : 
; 3847 : 	// process all the clients
; 3848 : 	for( slot = 0, cl = svs.clients; slot < svs.maxclients; slot++, cl++ )

	mov	DWORD PTR _slot$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Playbac
$LN2@SV_Playbac:
	mov	eax, DWORD PTR _slot$[ebp]
	add	eax, 1
	mov	DWORD PTR _slot$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_Playbac:
	mov	eax, DWORD PTR _slot$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_Playbac

; 3849 : 	{
; 3850 : 		if( cl->state != cs_spawned || !cl->edict || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN35@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264948], 0
	je	SHORT $LN35@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN34@SV_Playbac
$LN35@SV_Playbac:

; 3851 : 			continue;

	jmp	SHORT $LN2@SV_Playbac
$LN34@SV_Playbac:

; 3852 : 
; 3853 : 		if( SV_IsValidEdict( pInvoker ) && pInvoker->v.groupinfo && cl->edict->v.groupinfo )

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PlaybackEventFull@@9@9
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN38@SV_Playbac
	mov	eax, DWORD PTR _pInvoker$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN38@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	cmp	DWORD PTR [ecx+800], 0
	je	SHORT $LN38@SV_Playbac

; 3854 : 		{
; 3855 : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( cl->edict->v.groupinfo, pInvoker->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN37@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [ecx+800]
	and	eax, DWORD PTR [edx+800]
	jne	SHORT $LN37@SV_Playbac

; 3856 : 				continue;

	jmp	$LN2@SV_Playbac
$LN37@SV_Playbac:

; 3857 : 
; 3858 : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( cl->edict->v.groupinfo, pInvoker->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN38@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [ecx+800]
	and	eax, DWORD PTR [edx+800]
	je	SHORT $LN38@SV_Playbac

; 3859 : 				continue;

	jmp	$LN2@SV_Playbac
$LN38@SV_Playbac:

; 3860 : 		}
; 3861 : 
; 3862 : 		if( SV_IsValidEdict( pInvoker ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PlaybackEventFull@@9@9
	add	eax, 137				; 00000089H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN40@SV_Playbac

; 3863 : 		{
; 3864 : 			if( !SV_CheckClientVisiblity( cl, mask ))

	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_CheckClientVisiblity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@SV_Playbac

; 3865 : 				continue;

	jmp	$LN2@SV_Playbac
$LN40@SV_Playbac:

; 3866 : 		}
; 3867 : 
; 3868 : 		if( FBitSet( flags, FEV_NOTHOST ) && cl == sv.current_client && FBitSet( cl->flags, FCL_LOCAL_WEAPONS ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN41@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	eax, DWORD PTR _sv+40
	jne	SHORT $LN41@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 32					; 00000020H
	je	SHORT $LN41@SV_Playbac

; 3869 : 			continue;	// will be played on client side

	jmp	$LN2@SV_Playbac
$LN41@SV_Playbac:

; 3870 : 
; 3871 : 		if( FBitSet( flags, FEV_HOSTONLY ) && cl->edict != pInvoker )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN42@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	cmp	ecx, DWORD PTR _pInvoker$[ebp]
	je	SHORT $LN42@SV_Playbac

; 3872 : 			continue;	// sending only to invoker

	jmp	$LN2@SV_Playbac
$LN42@SV_Playbac:

; 3873 : 
; 3874 : 		// all checks passed, send the event
; 3875 : 
; 3876 : 		// reliable event
; 3877 : 		if( FBitSet( flags, FEV_RELIABLE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN43@SV_Playbac

; 3878 : 		{
; 3879 : 			// skipping queue, write direct into reliable datagram
; 3880 : 			SV_PlaybackReliableEvent( &cl->netchan.message, eventindex, delay, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _eventindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_SV_PlaybackReliableEvent
	add	esp, 16					; 00000010H

; 3881 : 			continue;

	jmp	$LN2@SV_Playbac
$LN43@SV_Playbac:

; 3882 : 		}
; 3883 : 
; 3884 : 		// unreliable event (stores in queue)
; 3885 : 		es = &cl->events;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 281888				; 00044d20H
	mov	DWORD PTR _es$[ebp], eax

; 3886 : 		bestslot = -1;

	mov	DWORD PTR _bestslot$[ebp], -1

; 3887 : 
; 3888 : 		if( FBitSet( flags, FEV_UPDATE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN6@SV_Playbac

; 3889 : 		{
; 3890 : 			for( j = 0; j < MAX_EVENT_QUEUE; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@SV_Playbac
$LN5@SV_Playbac:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@SV_Playbac:
	cmp	DWORD PTR _j$[ebp], 64			; 00000040H
	jge	SHORT $LN6@SV_Playbac

; 3891 : 			{
; 3892 : 				ei = &es->ei[j];

	imul	eax, DWORD PTR _j$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 3893 : 
; 3894 : 				if( ei->index == eventindex && invokerIndex != -1 && invokerIndex == ei->entity_index )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	movzx	edx, WORD PTR _eventindex$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN45@SV_Playbac
	cmp	DWORD PTR _invokerIndex$[ebp], -1
	je	SHORT $LN45@SV_Playbac
	mov	eax, DWORD PTR _ei$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _invokerIndex$[ebp], ecx
	jne	SHORT $LN45@SV_Playbac

; 3895 : 				{
; 3896 : 					bestslot = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestslot$[ebp], eax

; 3897 : 					break;

	jmp	SHORT $LN6@SV_Playbac
$LN45@SV_Playbac:

; 3898 : 				}
; 3899 : 			}

	jmp	SHORT $LN5@SV_Playbac
$LN6@SV_Playbac:

; 3900 : 		}
; 3901 : 
; 3902 : 		if( bestslot == -1 )

	cmp	DWORD PTR _bestslot$[ebp], -1
	jne	SHORT $LN9@SV_Playbac

; 3903 : 		{
; 3904 : 			for( j = 0; j < MAX_EVENT_QUEUE; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_Playbac
$LN8@SV_Playbac:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_Playbac:
	cmp	DWORD PTR _j$[ebp], 64			; 00000040H
	jge	SHORT $LN9@SV_Playbac

; 3905 : 			{
; 3906 : 				ei = &es->ei[j];

	imul	eax, DWORD PTR _j$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 3907 : 		
; 3908 : 				if( ei->index == 0 )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN47@SV_Playbac

; 3909 : 				{
; 3910 : 					// found an empty slot
; 3911 : 					bestslot = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestslot$[ebp], eax

; 3912 : 					break;

	jmp	SHORT $LN9@SV_Playbac
$LN47@SV_Playbac:

; 3913 : 				}
; 3914 : 			}

	jmp	SHORT $LN8@SV_Playbac
$LN9@SV_Playbac:

; 3915 : 		}
; 3916 : 				
; 3917 : 		// no slot found for this player, oh well
; 3918 : 		if( bestslot == -1 ) continue;

	cmp	DWORD PTR _bestslot$[ebp], -1
	jne	SHORT $LN48@SV_Playbac
	jmp	$LN2@SV_Playbac
$LN48@SV_Playbac:

; 3919 : 
; 3920 : 		// add event to queue
; 3921 : 		ei->index = eventindex;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	cx, WORD PTR _eventindex$[ebp]
	mov	WORD PTR [eax], cx

; 3922 : 		ei->fire_time = delay;

	mov	eax, DWORD PTR _ei$[ebp]
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 3923 : 		ei->entity_index = invokerIndex;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	cx, WORD PTR _invokerIndex$[ebp]
	mov	WORD PTR [eax+4], cx

; 3924 : 		ei->packet_index = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _ei$[ebp]
	mov	WORD PTR [ecx+2], ax

; 3925 : 		ei->flags = flags;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 3926 : 		ei->args = args;

	mov	edi, DWORD PTR _ei$[ebp]
	add	edi, 12					; 0000000cH
	mov	ecx, 27					; 0000001bH
	lea	esi, DWORD PTR _args$[ebp]
	rep movsd

; 3927 : 	}

	jmp	$LN2@SV_Playbac
$LN3@SV_Playbac:

; 3928 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_FindEntityByString
_TEXT	SEGMENT
tv75 = -92						; size = 4
tv136 = -88						; size = 4
tv131 = -88						; size = 4
tv72 = -88						; size = 4
_t$ = -20						; size = 4
_ed$ = -16						; size = 4
_desc$ = -12						; size = 4
_e$ = -8						; size = 4
_index$ = -4						; size = 4
_pStartEdict$ = 8					; size = 4
_pszField$ = 12						; size = 4
_pszValue$ = 16						; size = 4
_SV_FindEntityByString PROC				; COMDAT

; 1516 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1517 : 	int		index = 0, e = 0;

	mov	DWORD PTR _index$[ebp], 0
	mov	DWORD PTR _e$[ebp], 0

; 1518 : 	TYPEDESCRIPTION	*desc = NULL;

	mov	DWORD PTR _desc$[ebp], 0

; 1519 : 	edict_t		*ed;
; 1520 : 	const char	*t;
; 1521 : 
; 1522 : 	if( !COM_CheckString( pszValue ))

	mov	eax, DWORD PTR _pszValue$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@SV_FindEnt

; 1523 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@SV_FindEnt
$LN9@SV_FindEnt:

; 1524 : 
; 1525 : 	if( pStartEdict ) e = NUM_FOR_EDICT( pStartEdict );

	cmp	DWORD PTR _pStartEdict$[ebp], 0
	je	SHORT $LN2@SV_FindEnt
	mov	eax, DWORD PTR _pStartEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _e$[ebp], eax
$LN2@SV_FindEnt:

; 1526 : 
; 1527 : 	while(( desc = SV_GetEntvarsDescirption( index++ )) != NULL )

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_SV_GetEntvarsDescirption
	add	esp, 4
	mov	DWORD PTR _desc$[ebp], eax
	mov	edx, DWORD PTR _desc$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN3@SV_FindEnt

; 1528 : 	{
; 1529 : 		if( !Q_strcmp( pszField, desc->fieldName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pszField$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@SV_FindEnt

; 1530 : 			break;

	jmp	SHORT $LN3@SV_FindEnt
$LN11@SV_FindEnt:

; 1531 : 	}

	jmp	SHORT $LN2@SV_FindEnt
$LN3@SV_FindEnt:

; 1532 : 
; 1533 : 	if( desc == NULL )

	cmp	DWORD PTR _desc$[ebp], 0
	jne	SHORT $LN12@SV_FindEnt

; 1534 : 	{
; 1535 : 		Con_Printf( S_ERROR "FindEntityByString: field %s not a string\n", pszField );

	mov	eax, DWORD PTR _pszField$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@CMNBBMAL@?$FO1Error?3?$FO7?5FindEntityByString?3?5@
	call	_Con_Printf
	add	esp, 8

; 1536 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@SV_FindEnt
$LN12@SV_FindEnt:

; 1537 : 	}
; 1538 : 	
; 1539 : 	for( e++; e < svgame.numEntities; e++ )

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN6@SV_FindEnt
$LN4@SV_FindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$LN6@SV_FindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN5@SV_FindEnt

; 1540 : 	{
; 1541 : 		ed = EDICT_NUM( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ed$[ebp], eax

; 1542 : 		if( !SV_IsValidEdict( ed )) continue;

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FindEntityByString@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ed$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@SV_FindEnt
	jmp	SHORT $LN4@SV_FindEnt
$LN13@SV_FindEnt:

; 1543 : 
; 1544 : 		if( e <= svs.maxclients && !SV_ClientFromEdict( ed, ( svs.maxclients != 1 )))

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN14@SV_FindEnt
	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN21@SV_FindEnt
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN22@SV_FindEnt
$LN21@SV_FindEnt:
	mov	DWORD PTR tv131[ebp], 0
$LN22@SV_FindEnt:
	mov	eax, DWORD PTR tv131[ebp]
	push	eax
	mov	ecx, DWORD PTR _ed$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@SV_FindEnt

; 1545 : 			continue;

	jmp	$LN4@SV_FindEnt
$LN14@SV_FindEnt:

; 1546 : 
; 1547 : 		switch( desc->fieldType )

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv136[ebp], ecx
	cmp	DWORD PTR tv136[ebp], 1
	je	SHORT $LN17@SV_FindEnt
	cmp	DWORD PTR tv136[ebp], 17		; 00000011H
	je	SHORT $LN17@SV_FindEnt
	cmp	DWORD PTR tv136[ebp], 18		; 00000012H
	je	SHORT $LN17@SV_FindEnt
	jmp	SHORT $LN7@SV_FindEnt
$LN17@SV_FindEnt:

; 1548 : 		{
; 1549 : 		case FIELD_STRING:
; 1550 : 		case FIELD_MODELNAME:
; 1551 : 		case FIELD_SOUNDNAME:
; 1552 : 			t = STRING( *(string_t *)&((byte *)&ed->v)[desc->fieldOffset] );

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+ecx+128]
	push	eax
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _t$[ebp], eax

; 1553 : 			if( t != NULL && t != svgame.globals->pStringBase )

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN7@SV_FindEnt
	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR [eax+156]
	je	SHORT $LN7@SV_FindEnt

; 1554 : 			{
; 1555 : 				if( !Q_strcmp( t, pszValue ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SV_FindEnt

; 1556 : 					return ed;

	mov	eax, DWORD PTR _ed$[ebp]
	jmp	SHORT $LN1@SV_FindEnt
$LN7@SV_FindEnt:

; 1557 : 			}
; 1558 : 			break;
; 1559 : 		}
; 1560 : 	}

	jmp	$LN4@SV_FindEnt
$LN5@SV_FindEnt:

; 1561 : 
; 1562 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@SV_FindEnt:

; 1563 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEntityByString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_SetMinMaxSize
_TEXT	SEGMENT
tv172 = -72						; size = 4
_i$ = -4						; size = 4
_e$ = 8							; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_relink$ = 20						; size = 4
_SV_SetMinMaxSize PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 192  : 	int	i;
; 193  : 
; 194  : 	if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_SetMinMaxSize@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_SetMinM

; 195  : 		return;

	jmp	$LN8@SV_SetMinM
$LN5@SV_SetMinM:

; 196  : 
; 197  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SetMinM
$LN2@SV_SetMinM:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_SetMinM:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_SetMinM

; 198  : 	{
; 199  : 		if( mins[i] > maxs[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR [esi+edx*4]
	jbe	SHORT $LN6@SV_SetMinM

; 200  : 		{
; 201  : 			Con_Printf( S_ERROR "%s[%i] has backwards mins/maxs\n", SV_ClassName( e ), NUM_FOR_EDICT( e ));

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@DCCJHOGJ@?$FO1Error?3?$FO7?5?$CFs?$FL?$CFi?$FN?5has?5backwards@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 202  : 			if( relink ) SV_LinkEdict( e, false ); // just relink edict and exit

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN7@SV_SetMinM
	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN7@SV_SetMinM:

; 203  : 			return;

	jmp	$LN8@SV_SetMinM
$LN6@SV_SetMinM:

; 204  : 		}
; 205  : 	}

	jmp	SHORT $LN2@SV_SetMinM
$LN3@SV_SetMinM:

; 206  : 
; 207  : 	VectorCopy( mins, e->v.mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+352], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+352], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+352], eax

; 208  : 	VectorCopy( maxs, e->v.maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+364], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+364], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+364], eax

; 209  : 	VectorSubtract( maxs, mins, e->v.size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [edx+ecx+376], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [ecx+eax+376], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR [eax+edx+376], xmm0

; 210  : 	if( relink ) SV_LinkEdict( e, false );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN8@SV_SetMinM
	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN8@SV_SetMinM:

; 211  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetMinMaxSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CheckEdict
_TEXT	SEGMENT
tv72 = -72						; size = 4
_n$ = -4						; size = 4
_e$ = 8							; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_SV_CheckEdict PROC					; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 48   : 	int	n;
; 49   : 
; 50   : 	if( !e ) return false; // may be NULL

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN2@SV_CheckEd
	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckEd
$LN2@SV_CheckEd:

; 51   : 
; 52   : 	n = ((int)((edict_t *)(e) - svgame.edicts));

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _n$[ebp], eax

; 53   : 
; 54   : 	if(( n >= 0 ) && ( n < GI->max_edicts ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN3@SV_CheckEd
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN3@SV_CheckEd

; 55   : 		return !e->free;

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@SV_CheckEd
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN6@SV_CheckEd
$LN5@SV_CheckEd:
	mov	DWORD PTR tv72[ebp], 0
$LN6@SV_CheckEd:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@SV_CheckEd
$LN3@SV_CheckEd:

; 56   : 	Con_Printf( "bad entity %i (called at %s:%i)\n", n, file, line );

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	push	OFFSET ??_C@_0CB@EKNEPLEL@bad?5entity?5?$CFi?5?$CIcalled?5at?5?$CFs?3?$CFi?$CJ@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 57   : 
; 58   : 	return false;	

	xor	eax, eax
$LN1@SV_CheckEd:

; 59   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CopyTraceToGlobal
_TEXT	SEGMENT
_trace$ = 8						; size = 4
_SV_CopyTraceToGlobal PROC				; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 222  : 	svgame.globals->trace_allsolid = trace->allsolid;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx+76], xmm0

; 223  : 	svgame.globals->trace_startsolid = trace->startsolid;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx+80], xmm0

; 224  : 	svgame.globals->trace_fraction = trace->fraction;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+84], edx

; 225  : 	svgame.globals->trace_plane_dist = trace->plane.dist;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+112], edx

; 226  : 	svgame.globals->trace_inopen = trace->inopen;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx+120], xmm0

; 227  : 	svgame.globals->trace_inwater = trace->inwater;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx+124], xmm0

; 228  : 	VectorCopy( trace->endpos, svgame.globals->trace_endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [edx+eax+88], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax+88], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+ecx+88], eax

; 229  : 	VectorCopy( trace->plane.normal, svgame.globals->trace_plane_normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+32]
	mov	DWORD PTR [edx+eax+100], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+32]
	mov	DWORD PTR [ecx+eax+100], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19268
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+100], eax

; 230  : 	svgame.globals->trace_hitgroup = trace->hitgroup;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+128], edx

; 231  : 	svgame.globals->trace_flags = 0; // g-cont: always reset config flags when trace is finished

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+132], 0

; 232  : 
; 233  : 	if( SV_IsValidEdict( trace->ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_CopyTraceToGlobal@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_CopyTra

; 234  : 		svgame.globals->trace_ent = trace->ent;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+116], edx
	jmp	SHORT $LN3@SV_CopyTra
$LN2@SV_CopyTra:

; 235  : 	else svgame.globals->trace_ent = svgame.edicts;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _svgame+7928
	mov	DWORD PTR [eax+116], ecx
$LN3@SV_CopyTra:

; 236  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CopyTraceToGlobal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_FreePrivateData
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_SV_FreePrivateData PROC				; COMDAT

; 942  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 943  : 	if( !pEdict || !pEdict->pvPrivateData )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@SV_FreePri
	mov	eax, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN2@SV_FreePri
$LN3@SV_FreePri:

; 944  : 		return;

	jmp	SHORT $LN1@SV_FreePri
$LN2@SV_FreePri:

; 945  : 
; 946  : 	// NOTE: new interface can be missing
; 947  : 	if( svgame.dllFuncs2.pfnOnFreeEntPrivateData != NULL )

	cmp	DWORD PTR _svgame+19472, 0
	je	SHORT $LN4@SV_FreePri

; 948  : 		svgame.dllFuncs2.pfnOnFreeEntPrivateData( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR _svgame+19472
	add	esp, 4
$LN4@SV_FreePri:

; 949  : 
; 950  : 	if( Mem_IsAllocatedExt( svgame.mempool, pEdict->pvPrivateData ))

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _svgame+19588
	push	edx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@SV_FreePri

; 951  : 		Mem_Free( pEdict->pvPrivateData );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FreePrivateData@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@SV_FreePri:

; 952  : 
; 953  : 	pEdict->pvPrivateData = NULL;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+124], 0
$LN1@SV_FreePri:

; 954  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreePrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_ClassName
_TEXT	SEGMENT
_e$ = 8							; size = 4
_SV_ClassName PROC					; COMDAT

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1193 : 	if( !e ) return "(null)";

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN2@SV_ClassNa
	mov	eax, OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ@
	jmp	SHORT $LN1@SV_ClassNa
$LN2@SV_ClassNa:

; 1194 : 	if( e->free ) return "freed";

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@SV_ClassNa
	mov	eax, OFFSET ??_C@_05FAPHKBON@freed@
	jmp	SHORT $LN1@SV_ClassNa
$LN3@SV_ClassNa:

; 1195 : 	return STRING( e->v.classname );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
$LN1@SV_ClassNa:

; 1196 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClassName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_InitEdict
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pEdict$ = 8						; size = 4
_SV_InitEdict PROC					; COMDAT

; 964  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 965  : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@SV_InitEdi
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@SV_InitEdi
$LN3@SV_InitEdi:
	mov	DWORD PTR tv70[ebp], 0
$LN4@SV_InitEdi:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_InitEdict@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 966  : 
; 967  : 	SV_FreePrivateData( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_FreePrivateData
	add	esp, 4

; 968  : 	memset( &pEdict->v, 0, sizeof( entvars_t ));

	push	772					; 00000304H
	push	0
	mov	eax, DWORD PTR _pEdict$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 969  : 	pEdict->v.pContainingEntity = pEdict;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+744], ecx

; 970  : 	pEdict->v.controller[0] = 0x7F;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [edx+ecx+484], 127		; 0000007fH

; 971  : 	pEdict->v.controller[1] = 0x7F;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [ecx+eax+484], 127		; 0000007fH

; 972  : 	pEdict->v.controller[2] = 0x7F;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [ecx+eax+484], 127		; 0000007fH

; 973  : 	pEdict->v.controller[3] = 0x7F;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [edx+ecx+484], 127		; 0000007fH

; 974  : 	pEdict->free = false;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax], 0

; 975  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_FreeEdict
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pEdict$ = 8						; size = 4
_SV_FreeEdict PROC					; COMDAT

; 985  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 986  : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN4@SV_FreeEdi
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@SV_FreeEdi
$LN4@SV_FreeEdi:
	mov	DWORD PTR tv70[ebp], 0
$LN5@SV_FreeEdi:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FreeEdict@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 987  : 	if( pEdict->free ) return;

	mov	eax, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SV_FreeEdi
	jmp	$LN1@SV_FreeEdi
$LN2@SV_FreeEdi:

; 988  : 
; 989  : 	// unlink from world
; 990  : 	SV_UnlinkEdict( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_UnlinkEdict
	add	esp, 4

; 991  : 
; 992  : 	SV_FreePrivateData( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_FreePrivateData
	add	esp, 4

; 993  : 
; 994  : 	// mark edict as freed
; 995  : 	pEdict->freetime = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _pEdict$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 996  : 	pEdict->serialnumber++; // invalidate EHANDLE's

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 997  : 	pEdict->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+400], 0

; 998  : 	pEdict->v.flags = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+656], 0

; 999  : 	pEdict->v.model = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+312], 0

; 1000 : 	pEdict->v.takedamage = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+600], xmm0

; 1001 : 	pEdict->v.modelindex = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+308], 0

; 1002 : 	pEdict->v.nextthink = -1;

	mov	eax, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+392], xmm0

; 1003 : 	pEdict->v.colormap = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+660], 0

; 1004 : 	pEdict->v.frame = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+472], xmm0

; 1005 : 	pEdict->v.scale = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+492], xmm0

; 1006 : 	pEdict->v.gravity = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+452], xmm0

; 1007 : 	pEdict->v.skin = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+404], 0

; 1008 : 
; 1009 : 	VectorClear( pEdict->v.angles );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0

; 1010 : 	VectorClear( pEdict->v.origin );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0

; 1011 : 	pEdict->free = true;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax], 1
$LN1@SV_FreeEdi:

; 1012 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreeEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_AllocEdict
_TEXT	SEGMENT
_i$ = -8						; size = 4
_e$ = -4						; size = 4
_SV_AllocEdict PROC					; COMDAT

; 1022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1023 : 	edict_t	*e;
; 1024 : 	int	i;
; 1025 : 
; 1026 : 	for( i = svs.maxclients + 1; i < svgame.numEntities; i++ )

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_AllocEd
$LN2@SV_AllocEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_AllocEd:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	SHORT $LN3@SV_AllocEd

; 1027 : 	{
; 1028 : 		e = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 1029 : 		// the first couple seconds of server time can involve a lot of
; 1030 : 		// freeing and allocating, so relax the replacement policy
; 1031 : 		if( e->free && ( e->freetime < 2.0f || ( sv.time - e->freetime ) > 0.5f ))

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SV_AllocEd
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR [eax+120]
	ja	SHORT $LN6@SV_AllocEd
	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+120]
	movsd	xmm1, QWORD PTR _sv+16
	subsd	xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@3fe0000000000000
	jbe	SHORT $LN5@SV_AllocEd
$LN6@SV_AllocEd:

; 1032 : 		{
; 1033 : 			SV_InitEdict( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4

; 1034 : 			return e;

	mov	eax, DWORD PTR _e$[ebp]
	jmp	SHORT $LN1@SV_AllocEd
$LN5@SV_AllocEd:

; 1035 : 		}
; 1036 : 	}

	jmp	SHORT $LN2@SV_AllocEd
$LN3@SV_AllocEd:

; 1037 : 
; 1038 : 	if( i >= GI->max_edicts )

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jl	SHORT $LN7@SV_AllocEd

; 1039 : 		Host_Error( "ED_AllocEdict: no free edicts (max is %d)\n", GI->max_edicts );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1656]
	push	ecx
	push	OFFSET ??_C@_0CL@KBOCFNED@ED_AllocEdict?3?5no?5free?5edicts?5?$CI@
	call	_Host_Error
	add	esp, 8
$LN7@SV_AllocEd:

; 1040 : 
; 1041 : 	svgame.numEntities++;

	mov	eax, DWORD PTR _svgame+7932
	add	eax, 1
	mov	DWORD PTR _svgame+7932, eax

; 1042 : 	e = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 1043 : 	SV_InitEdict( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4

; 1044 : 
; 1045 : 	return e;

	mov	eax, DWORD PTR _e$[ebp]
$LN1@SV_AllocEd:

; 1046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_FreeEdicts
_TEXT	SEGMENT
_ent$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_FreeEdicts PROC					; COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1143 : 	int	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1144 : 	edict_t	*ent;
; 1145 : 
; 1146 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_FreeEdi
$LN2@SV_FreeEdi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_FreeEdi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	SHORT $LN1@SV_FreeEdi

; 1147 : 	{
; 1148 : 		ent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1149 : 		if( ent->free ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SV_FreeEdi
	jmp	SHORT $LN2@SV_FreeEdi
$LN5@SV_FreeEdi:

; 1150 : 		SV_FreeEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4

; 1151 : 	}

	jmp	SHORT $LN2@SV_FreeEdi
$LN1@SV_FreeEdi:

; 1152 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreeEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_UnloadProgs
_TEXT	SEGMENT
_SV_UnloadProgs PROC					; COMDAT

; 4784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4785 : 	if( !svgame.hInstance )

	cmp	DWORD PTR _svgame+7920, 0
	jne	SHORT $LN2@SV_UnloadP

; 4786 : 		return;

	jmp	$LN1@SV_UnloadP
$LN2@SV_UnloadP:

; 4787 : 
; 4788 : 	SV_DeactivateServer ();

	call	_SV_DeactivateServer

; 4789 : 	Delta_Shutdown ();

	call	_Delta_Shutdown

; 4790 : 	Mod_ClearUserData ();

	call	_Mod_ClearUserData

; 4791 : 
; 4792 : 	Mem_FreePool( &svgame.stringspool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_UnloadProgs@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _svgame+19592
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4793 : 
; 4794 : 	if( svgame.dllFuncs2.pfnGameShutdown != NULL )

	cmp	DWORD PTR _svgame+19476, 0
	je	SHORT $LN3@SV_UnloadP

; 4795 : 		svgame.dllFuncs2.pfnGameShutdown ();

	call	DWORD PTR _svgame+19476
$LN3@SV_UnloadP:

; 4796 : 
; 4797 : 	// now we can unload cvars
; 4798 : 	Cvar_FullSet( "host_gameloaded", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BA@HFMOEDOL@host_gameloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4799 : 	Cvar_FullSet( "sv_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4800 : 
; 4801 : 	// free entity baselines
; 4802 : 	Z_Free( svs.static_entities );

	cmp	DWORD PTR _svs+33364, 0
	je	SHORT $LN4@SV_UnloadP
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_UnloadProgs@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _svs+33364
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_UnloadP:

; 4803 : 	Z_Free( svs.baselines );

	cmp	DWORD PTR _svs+33360, 0
	je	SHORT $LN5@SV_UnloadP
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_UnloadProgs@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _svs+33360
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@SV_UnloadP:

; 4804 : 	svs.baselines = NULL;

	mov	DWORD PTR _svs+33360, 0

; 4805 : 
; 4806 : 	// remove server cmds
; 4807 : 	SV_KillOperatorCommands();

	call	_SV_KillOperatorCommands

; 4808 : 
; 4809 : 	// must unlink all game cvars,
; 4810 : 	// before pointers on them will be lost...
; 4811 : 	Cvar_Unlink( FCVAR_EXTDLL );

	push	8
	call	_Cvar_Unlink
	add	esp, 4

; 4812 : 	Cmd_Unlink( CMD_SERVERDLL );

	push	1
	call	_Cmd_Unlink
	add	esp, 4

; 4813 : 
; 4814 : 	Mod_ResetStudioAPI ();

	call	_Mod_ResetStudioAPI

; 4815 : 
; 4816 : 	COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4817 : 	Mem_FreePool( &svgame.mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_UnloadProgs@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _svgame+19588
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4818 : 	memset( &svgame, 0, sizeof( svgame ));

	push	19596					; 00004c8cH
	push	0
	push	OFFSET _svgame
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@SV_UnloadP:

; 4819 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UnloadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_LoadProgs
_TEXT	SEGMENT
_e$ = -12						; size = 4
_version$ = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_SV_LoadProgs PROC					; COMDAT

; 4822 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 4823 : 	int			i, version;
; 4824 : 	static APIFUNCTION		GetEntityAPI;
; 4825 : 	static APIFUNCTION2		GetEntityAPI2;
; 4826 : 	static GIVEFNPTRSTODLL	GiveFnptrsToDll;
; 4827 : 	static NEW_DLL_FUNCTIONS_FN	GiveNewDllFuncs;
; 4828 : 	static enginefuncs_t	gpEngfuncs;
; 4829 : 	static globalvars_t		gpGlobals;
; 4830 : 	static playermove_t		gpMove;
; 4831 : 	edict_t			*e;
; 4832 : 
; 4833 : 	if( svgame.hInstance ) SV_UnloadProgs();

	cmp	DWORD PTR _svgame+7920, 0
	je	SHORT $LN5@SV_LoadPro
	call	_SV_UnloadProgs
$LN5@SV_LoadPro:

; 4834 : 
; 4835 : 	// fill it in
; 4836 : 	svgame.pmove = &gpMove;

	mov	DWORD PTR _svgame+8256, OFFSET ?gpMove@?1??SV_LoadProgs@@9@9

; 4837 : 	svgame.globals = &gpGlobals;

	mov	DWORD PTR _svgame+19268, OFFSET ?gpGlobals@?1??SV_LoadProgs@@9@9

; 4838 : 	svgame.mempool = Mem_AllocPool( "Server Edicts Zone" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadProgs@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BD@JHKBCDAM@Server?5Edicts?5Zone@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+19588, eax

; 4839 : 	svgame.hInstance = COM_LoadLibrary( name, true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+7920, eax

; 4840 : 	if( !svgame.hInstance ) return false;

	cmp	DWORD PTR _svgame+7920, 0
	jne	SHORT $LN6@SV_LoadPro
	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN6@SV_LoadPro:

; 4841 : 
; 4842 : 	// make sure what new dll functions is cleared
; 4843 : 	memset( &svgame.dllFuncs2, 0, sizeof( svgame.dllFuncs2 ));

	push	20					; 00000014H
	push	0
	push	OFFSET _svgame+19472
	call	_memset
	add	esp, 12					; 0000000cH

; 4844 : 
; 4845 : 	// make sure what physic functions is cleared
; 4846 : 	memset( &svgame.physFuncs, 0, sizeof( svgame.physFuncs ));

	push	96					; 00000060H
	push	0
	push	OFFSET _svgame+19492
	call	_memset
	add	esp, 12					; 0000000cH

; 4847 : 
; 4848 : 	// make local copy of engfuncs to prevent overwrite it with bots.dll
; 4849 : 	memcpy( &gpEngfuncs, &gEngfuncs, sizeof( gpEngfuncs ));

	push	640					; 00000280H
	push	OFFSET _gEngfuncs
	push	OFFSET ?gpEngfuncs@?1??SV_LoadProgs@@9@9
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4850 : 
; 4851 : 	GetEntityAPI = (APIFUNCTION)COM_GetProcAddress( svgame.hInstance, "GetEntityAPI" );

	push	OFFSET ??_C@_0N@BOKHDMKE@GetEntityAPI@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9, eax

; 4852 : 	GetEntityAPI2 = (APIFUNCTION2)COM_GetProcAddress( svgame.hInstance, "GetEntityAPI2" );

	push	OFFSET ??_C@_0O@DMNFJELM@GetEntityAPI2@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, eax

; 4853 : 	GiveNewDllFuncs = (NEW_DLL_FUNCTIONS_FN)COM_GetProcAddress( svgame.hInstance, "GetNewDLLFunctions" );

	push	OFFSET ??_C@_0BD@CFIEBNAN@GetNewDLLFunctions@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9, eax

; 4854 : 
; 4855 : 	if( !GetEntityAPI && !GetEntityAPI2 )

	cmp	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN7@SV_LoadPro
	cmp	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN7@SV_LoadPro

; 4856 : 	{
; 4857 : 		COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4858 :          		Con_Printf( S_ERROR "SV_LoadProgs: failed to get address of GetEntityAPI proc\n" );

	push	OFFSET ??_C@_0EF@HCGHAGDG@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@
	call	_Con_Printf
	add	esp, 4

; 4859 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4860 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN7@SV_LoadPro:

; 4861 : 	}
; 4862 : 
; 4863 : 	GiveFnptrsToDll = (GIVEFNPTRSTODLL)COM_GetProcAddress( svgame.hInstance, "GiveFnptrsToDll" );

	push	OFFSET ??_C@_0BA@FAHPOONL@GiveFnptrsToDll@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9, eax

; 4864 : 
; 4865 : 	if( !GiveFnptrsToDll )

	cmp	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN8@SV_LoadPro

; 4866 : 	{
; 4867 : 		COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4868 : 		Con_Printf( S_ERROR "SV_LoadProgs: failed to get address of GiveFnptrsToDll proc\n" );

	push	OFFSET ??_C@_0EI@LJHOCIDJ@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5failed@
	call	_Con_Printf
	add	esp, 4

; 4869 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4870 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN8@SV_LoadPro:

; 4871 : 	}
; 4872 : 
; 4873 : 	GiveFnptrsToDll( &gpEngfuncs, svgame.globals );

	mov	eax, DWORD PTR _svgame+19268
	push	eax
	push	OFFSET ?gpEngfuncs@?1??SV_LoadProgs@@9@9
	call	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9

; 4874 : 
; 4875 : 	// get extended callbacks
; 4876 : 	if( GiveNewDllFuncs )

	cmp	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9, 0
	je	SHORT $LN9@SV_LoadPro

; 4877 : 	{
; 4878 : 		version = NEW_DLL_FUNCTIONS_VERSION;

	mov	DWORD PTR _version$[ebp], 1

; 4879 : 	
; 4880 : 		if( !GiveNewDllFuncs( &svgame.dllFuncs2, &version ))

	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19472
	call	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_LoadPro

; 4881 : 		{
; 4882 : 			if( version != NEW_DLL_FUNCTIONS_VERSION )

	cmp	DWORD PTR _version$[ebp], 1
	je	SHORT $LN11@SV_LoadPro

; 4883 : 				Con_Printf( S_WARN "SV_LoadProgs: new interface version %i should be %i\n", NEW_DLL_FUNCTIONS_VERSION, version );

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	1
	push	OFFSET ??_C@_0EC@MKPMDLBC@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5new?5@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN11@SV_LoadPro:

; 4884 : 			memset( &svgame.dllFuncs2, 0, sizeof( svgame.dllFuncs2 ));

	push	20					; 00000014H
	push	0
	push	OFFSET _svgame+19472
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@SV_LoadPro:

; 4885 : 		}
; 4886 : 	}
; 4887 : 
; 4888 : 	version = INTERFACE_VERSION;

	mov	DWORD PTR _version$[ebp], 140		; 0000008cH

; 4889 : 
; 4890 : 	if( GetEntityAPI2 )

	cmp	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, 0
	je	$LN12@SV_LoadPro

; 4891 : 	{
; 4892 : 		if( !GetEntityAPI2( &svgame.dllFuncs, &version ))

	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19272
	call	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@SV_LoadPro

; 4893 : 		{
; 4894 : 			Con_Printf( S_WARN "SV_LoadProgs: interface version %i should be %i\n", INTERFACE_VERSION, version );

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	140					; 0000008cH
	push	OFFSET ??_C@_0DO@PGAKJPDF@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5inte@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 4895 : 
; 4896 : 			// fallback to old API
; 4897 : 			if( !GetEntityAPI( &svgame.dllFuncs, version ))

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19272
	call	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@SV_LoadPro

; 4898 : 			{
; 4899 : 				COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4900 : 				Con_Printf( S_ERROR "SV_LoadProgs: couldn't get entity API\n" );

	push	OFFSET ??_C@_0DC@HKCPGJHF@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5couldn@
	call	_Con_Printf
	add	esp, 4

; 4901 : 				svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4902 : 				return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN16@SV_LoadPro:

; 4903 : 			}
; 4904 : 		}

	jmp	SHORT $LN15@SV_LoadPro
$LN14@SV_LoadPro:

; 4905 : 		else Con_Reportf( "SV_LoadProgs: ^2initailized extended EntityAPI ^7ver. %i\n", version );

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@CKBBBEDK@SV_LoadProgs?3?5?$FO2initailized?5ext@
	call	_Con_Reportf
	add	esp, 8
$LN15@SV_LoadPro:

; 4906 : 	}

	jmp	SHORT $LN13@SV_LoadPro
$LN12@SV_LoadPro:

; 4907 : 	else if( !GetEntityAPI( &svgame.dllFuncs, version ))

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19272
	call	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@SV_LoadPro

; 4908 : 	{
; 4909 : 		COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4910 : 		Con_Printf( S_ERROR "SV_LoadProgs: couldn't get entity API\n" );

	push	OFFSET ??_C@_0DC@HKCPGJHF@?$FO1Error?3?$FO7?5SV_LoadProgs?3?5couldn@
	call	_Con_Printf
	add	esp, 4

; 4911 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4912 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN13@SV_LoadPro:

; 4913 : 	}
; 4914 : 
; 4915 : 	SV_InitOperatorCommands();

	call	_SV_InitOperatorCommands

; 4916 : 	Mod_InitStudioAPI();

	call	_Mod_InitStudioAPI

; 4917 : 
; 4918 : 	if( !SV_InitPhysicsAPI( ))

	call	_SV_InitPhysicsAPI
	test	eax, eax
	jne	SHORT $LN18@SV_LoadPro

; 4919 : 	{
; 4920 : 		Con_Printf( S_WARN "SV_LoadProgs: couldn't get physics API\n" );

	push	OFFSET ??_C@_0DF@JPPJHCLE@?$FO3Warning?3?$FO7?5SV_LoadProgs?3?5coul@
	call	_Con_Printf
	add	esp, 4
$LN18@SV_LoadPro:

; 4921 : 	}
; 4922 : 
; 4923 : 	// grab function SV_SaveGameComment
; 4924 : 	SV_InitSaveRestore ();

	call	_SV_InitSaveRestore

; 4925 : 
; 4926 : 	svgame.globals->pStringBase = ""; // setup string base

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+156], OFFSET ??_C@_00CNPNBAHC@@

; 4927 : 
; 4928 : 	svgame.globals->maxEntities = GI->max_edicts;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1656]
	mov	DWORD PTR [eax+152], edx

; 4929 : 	svgame.globals->maxClients = svs.maxclients;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _svs+16
	mov	DWORD PTR [eax+148], ecx

; 4930 : 	svgame.edicts = Mem_Calloc( svgame.mempool, sizeof( edict_t ) * GI->max_edicts );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadProgs@@9@9
	add	eax, 108				; 0000006cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _SI+768
	imul	edx, DWORD PTR [ecx+1656], 900
	push	edx
	mov	eax, DWORD PTR _svgame+19588
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svgame+7928, eax

; 4931 : 	svs.static_entities = Z_Calloc( sizeof( entity_state_t ) * MAX_STATIC_ENTITIES );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadProgs@@9@9
	add	eax, 109				; 0000006dH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	1399392					; 00155a60H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svs+33364, eax

; 4932 : 	svs.baselines = Z_Calloc( sizeof( entity_state_t ) * GI->max_edicts );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadProgs@@9@9
	add	eax, 110				; 0000006eH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _SI+768
	imul	edx, DWORD PTR [ecx+1656], 452
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svs+33360, eax

; 4933 : 	svgame.numEntities = svs.maxclients + 1; // clients + world

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _svgame+7932, eax

; 4934 : 
; 4935 : 	for( i = 0, e = svgame.edicts; i < GI->max_edicts; i++, e++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svgame+7928
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN4@SV_LoadPro
$LN2@SV_LoadPro:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 900				; 00000384H
	mov	DWORD PTR _e$[ebp], ecx
$LN4@SV_LoadPro:
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN3@SV_LoadPro

; 4936 : 		e->free = true; // mark all edicts as freed

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN2@SV_LoadPro
$LN3@SV_LoadPro:

; 4937 : 
; 4938 : 	Cvar_FullSet( "host_gameloaded", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BA@HFMOEDOL@host_gameloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4939 : 	svgame.stringspool = Mem_AllocPool( "Server Strings" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LoadProgs@@9@9
	add	eax, 117				; 00000075H
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@HMJCFNPL@Server?5Strings@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+19592, eax

; 4940 : 
; 4941 : 	// fire once
; 4942 : 	Con_Printf( "Dll loaded for game ^2\"%s\"\n", svgame.dllFuncs.pfnGetGameDescription( ));

	call	DWORD PTR _svgame+19384
	push	eax
	push	OFFSET ??_C@_0BM@KKGMNAON@Dll?5loaded?5for?5game?5?$FO2?$CC?$CFs?$CC?6@
	call	_Con_Printf
	add	esp, 8

; 4943 : 
; 4944 : 	// all done, initialize game
; 4945 : 	svgame.dllFuncs.pfnGameInit();

	call	DWORD PTR _svgame+19272

; 4946 : 
; 4947 : 	// initialize pm_shared
; 4948 : 	SV_InitClientMove();

	call	_SV_InitClientMove

; 4949 : 
; 4950 : 	Delta_Init ();

	call	_Delta_Init

; 4951 : 
; 4952 : 	// register custom encoders
; 4953 : 	svgame.dllFuncs.pfnRegisterEncoders();

	call	DWORD PTR _svgame+19436

; 4954 : 
; 4955 : 	return true;

	mov	eax, 1
$LN1@SV_LoadPro:

; 4956 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 109  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesLeft PROC				; COMDAT

; 108  : _inline int MSG_GetNumBytesLeft( sizebuf_t *sb ) { return MSG_GetNumBitsLeft( sb ) >> 3; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_Serverinfo
_TEXT	SEGMENT
_SV_Serverinfo PROC					; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 125  : 	return svs.serverinfo;

	mov	eax, OFFSET _svs+60

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Serverinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_SysError
_TEXT	SEGMENT
_error_string$ = 8					; size = 4
_SV_SysError PROC					; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 110  : 	Log_Printf( "FATAL ERROR (shutting down): %s\n", error_string );

	mov	eax, DWORD PTR _error_string$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@CNPMFKGE@FATAL?5ERROR?5?$CIshutting?5down?$CJ?3?5?$CFs@
	call	_Log_Printf
	add	esp, 8

; 111  : 
; 112  : 	if( svgame.hInstance != NULL )

	cmp	DWORD PTR _svgame+7920, 0
	je	SHORT $LN1@SV_SysErro

; 113  : 		svgame.dllFuncs.pfnSys_Error( error_string );

	mov	eax, DWORD PTR _error_string$[ebp]
	push	eax
	call	DWORD PTR _svgame+19404
	add	esp, 4
$LN1@SV_SysErro:

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SysError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_RestoreCustomDecal
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_pEdict$ = 12						; size = 4
_adjacent$ = 16						; size = 4
_SV_RestoreCustomDecal PROC				; COMDAT

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 455  : 	if( svgame.physFuncs.pfnRestoreDecal != NULL )

	cmp	DWORD PTR _svgame+19568, 0
	je	SHORT $LN2@SV_Restore

; 456  : 	{
; 457  : 		if( !pEdict ) pEdict = EDICT_NUM( entry->entityIndex );

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $LN3@SV_Restore
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax
$LN3@SV_Restore:

; 458  : 		// true if decal was sucessfully restored at the game-side
; 459  : 		return svgame.physFuncs.pfnRestoreDecal( entry, pEdict, adjacent );

	mov	eax, DWORD PTR _adjacent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	DWORD PTR _svgame+19568
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@SV_Restore
$LN2@SV_Restore:

; 460  : 	}
; 461  : 	return false;

	xor	eax, eax
$LN1@SV_Restore:

; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestoreCustomDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_GetReliableDatagram
_TEXT	SEGMENT
_SV_GetReliableDatagram PROC				; COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 443  : 	return &sv.reliable_datagram;

	mov	eax, OFFSET _sv+2431724

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetReliableDatagram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_CreateDecal
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_origin$ = 12						; size = 4
_decalIndex$ = 16					; size = 4
_entityIndex$ = 20					; size = 4
_modelIndex$ = 24					; size = 4
_flags$ = 28						; size = 4
_scale$ = 32						; size = 4
_SV_CreateDecal PROC					; COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 473  : 	if( msg == &sv.signon && sv.state != ss_loading )

	cmp	DWORD PTR _msg$[ebp], OFFSET _sv+2456340
	jne	SHORT $LN2@SV_CreateD
	cmp	DWORD PTR _sv, 1
	je	SHORT $LN2@SV_CreateD

; 474  : 		return;

	jmp	$LN1@SV_CreateD
$LN2@SV_CreateD:

; 475  : 
; 476  : 	// this can happens if serialized map contain 4096 static decals...
; 477  : 	if( MSG_GetNumBytesLeft( msg ) < 20 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 20					; 00000014H
	jge	SHORT $LN3@SV_CreateD

; 478  : 	{
; 479  : 		sv.ignored_world_decals++;

	mov	eax, DWORD PTR _sv+2595664
	add	eax, 1
	mov	DWORD PTR _sv+2595664, eax

; 480  : 		return;

	jmp	$LN1@SV_CreateD
$LN3@SV_CreateD:

; 481  : 	}
; 482  : 
; 483  : 	// static decals are posters, it's always reliable
; 484  : 	MSG_BeginServerCmd( msg, svc_bspdecal );

	push	0
	push	1
	push	36					; 00000024H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 485  : 	MSG_WriteVec3Coord( msg, origin );

	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 486  : 	MSG_WriteWord( msg, decalIndex );

	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 487  : 	MSG_WriteShort( msg, entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8

; 488  : 	if( entityIndex > 0 )

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN4@SV_CreateD

; 489  : 		MSG_WriteWord( msg, modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8
$LN4@SV_CreateD:

; 490  : 	MSG_WriteByte( msg, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 491  : 	MSG_WriteWord( msg, scale * 4096 );

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@45800000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8
$LN1@SV_CreateD:

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_StartMusic
_TEXT	SEGMENT
tv90 = -72						; size = 4
tv76 = -72						; size = 4
tv87 = -68						; size = 4
tv73 = -68						; size = 4
_curtrack$ = 8						; size = 4
_looptrack$ = 12					; size = 4
_position$ = 16						; size = 4
_numLoop$ = 20						; size = 4
_onLoop$ = 24						; size = 4
_restored$ = 28						; size = 4
_SV_StartMusic PROC					; COMDAT

; 2158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2159 : 	MSG_BeginServerCmd( &sv.multicast, svc_stufftext );

	push	0
	push	1
	push	9
	push	OFFSET _sv+2448128
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2160 : 	if (numLoop < 0 || numLoop > 2)

	cmp	DWORD PTR _numLoop$[ebp], 0
	jl	SHORT $LN4@SV_StartMu
	cmp	DWORD PTR _numLoop$[ebp], 2
	jle	SHORT $LN2@SV_StartMu
$LN4@SV_StartMu:

; 2161 : 		MSG_WriteString( &sv.multicast, va( "music \"%s\" \"%s\" loop %d pos %i%s%s\n", curtrack, looptrack, numLoop, position, (onLoop) ? " onloop" : "", (restored) ? " restored" : ""));

	cmp	DWORD PTR _restored$[ebp], 0
	je	SHORT $LN6@SV_StartMu
	mov	DWORD PTR tv73[ebp], OFFSET ??_C@_09MNJMHLFH@?5restored@
	jmp	SHORT $LN7@SV_StartMu
$LN6@SV_StartMu:
	mov	DWORD PTR tv73[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN7@SV_StartMu:
	cmp	DWORD PTR _onLoop$[ebp], 0
	je	SHORT $LN8@SV_StartMu
	mov	DWORD PTR tv76[ebp], OFFSET ??_C@_07HPJIJIBE@?5onloop@
	jmp	SHORT $LN9@SV_StartMu
$LN8@SV_StartMu:
	mov	DWORD PTR tv76[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN9@SV_StartMu:
	mov	eax, DWORD PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	eax, DWORD PTR _numLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _looptrack$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curtrack$[ebp]
	push	edx
	push	OFFSET ??_C@_0CE@GIODLDCP@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@
	call	_va
	add	esp, 28					; 0000001cH
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN3@SV_StartMu
$LN2@SV_StartMu:

; 2162 : 	else
; 2163 : 		MSG_WriteString(&sv.multicast, va("music \"%s\" \"%s\" pos %i%s%s\n", curtrack, looptrack, position, (onLoop) ? " onloop" : "", (restored) ? " restored" : ""));

	cmp	DWORD PTR _restored$[ebp], 0
	je	SHORT $LN10@SV_StartMu
	mov	DWORD PTR tv87[ebp], OFFSET ??_C@_09MNJMHLFH@?5restored@
	jmp	SHORT $LN11@SV_StartMu
$LN10@SV_StartMu:
	mov	DWORD PTR tv87[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN11@SV_StartMu:
	cmp	DWORD PTR _onLoop$[ebp], 0
	je	SHORT $LN12@SV_StartMu
	mov	DWORD PTR tv90[ebp], OFFSET ??_C@_07HPJIJIBE@?5onloop@
	jmp	SHORT $LN13@SV_StartMu
$LN12@SV_StartMu:
	mov	DWORD PTR tv90[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN13@SV_StartMu:
	mov	eax, DWORD PTR tv87[ebp]
	push	eax
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	eax, DWORD PTR _looptrack$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curtrack$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@LLGKIMNB@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?$CFs?6@
	call	_va
	add	esp, 24					; 00000018H
	push	eax
	push	OFFSET _sv+2448128
	call	_MSG_WriteString
	add	esp, 8
$LN3@SV_StartMu:

; 2164 : 
; 2165 : 	SV_Multicast( MSG_ALL, NULL, NULL, false, false );

	push	0
	push	0
	push	0
	push	0
	push	2
	call	_SV_Multicast
	add	esp, 20					; 00000014H

; 2166 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StartMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _SV_StartSound
_TEXT	SEGMENT
tv171 = -92						; size = 4
tv164 = -92						; size = 4
tv140 = -92						; size = 4
_origin$ = -24						; size = 12
_msg_dest$ = -12					; size = 4
_filter$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_chan$ = 12						; size = 4
_sample$ = 16						; size = 4
_vol$ = 20						; size = 4
_attn$ = 24						; size = 4
_flags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_SV_StartSound PROC					; COMDAT

; 2096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2097 : 	qboolean	filter = false;

	mov	DWORD PTR _filter$[ebp], 0

; 2098 : 	int	msg_dest;
; 2099 : 	vec3_t	origin;
; 2100 : 
; 2101 : 	if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_StartSound@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_StartSo

; 2102 : 		return;

	jmp	$LN11@SV_StartSo
$LN2@SV_StartSo:

; 2103 : 
; 2104 : 	VectorAverage( ent->v.mins, ent->v.maxs, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+352]
	addss	xmm0, DWORD PTR [esi+eax+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+352]
	addss	xmm0, DWORD PTR [esi+eax+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+352]
	addss	xmm0, DWORD PTR [esi+ecx+364]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv140[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _origin$[ebp+eax], xmm0

; 2105 : 	VectorAdd( origin, ent->v.origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+136]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+136]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+136]
	movss	DWORD PTR tv164[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _origin$[ebp+eax], xmm0

; 2106 : 
; 2107 : 	if( FBitSet( flags, SND_SPAWNING ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN3@SV_StartSo

; 2108 : 		msg_dest = MSG_INIT;

	mov	DWORD PTR _msg_dest$[ebp], 3
	jmp	SHORT $LN8@SV_StartSo
$LN3@SV_StartSo:

; 2109 : 	else if( chan == CHAN_STATIC )

	cmp	DWORD PTR _chan$[ebp], 7
	jne	SHORT $LN5@SV_StartSo

; 2110 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
	jmp	SHORT $LN8@SV_StartSo
$LN5@SV_StartSo:

; 2111 : 	else if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	je	SHORT $LN7@SV_StartSo

; 2112 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
	jmp	SHORT $LN8@SV_StartSo
$LN7@SV_StartSo:

; 2113 : 	else msg_dest = (svs.maxclients <= 1 ) ? MSG_ALL : MSG_PAS_R;

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN13@SV_StartSo
	mov	DWORD PTR tv171[ebp], 2
	jmp	SHORT $LN14@SV_StartSo
$LN13@SV_StartSo:
	mov	DWORD PTR tv171[ebp], 7
$LN14@SV_StartSo:
	mov	eax, DWORD PTR tv171[ebp]
	mov	DWORD PTR _msg_dest$[ebp], eax
$LN8@SV_StartSo:

; 2114 : 
; 2115 : 	// always sending stop sound command
; 2116 : 	if( FBitSet( flags, SND_STOP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN9@SV_StartSo

; 2117 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN9@SV_StartSo:

; 2118 : 
; 2119 : 	if( FBitSet( flags, SND_FILTER_CLIENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN10@SV_StartSo

; 2120 : 		filter = true;

	mov	DWORD PTR _filter$[ebp], 1
$LN10@SV_StartSo:

; 2121 : 
; 2122 : 	if( SV_BuildSoundMsg( &sv.multicast, ent, chan, sample, vol * 255, attn, flags, pitch, origin ))

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _sample$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	OFFSET _sv+2448128
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN11@SV_StartSo

; 2123 : 		SV_Multicast( msg_dest, origin, NULL, false, filter );

	mov	eax, DWORD PTR _filter$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_dest$[ebp]
	push	edx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN11@SV_StartSo:

; 2124 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnNumberOfEntities
_TEXT	SEGMENT
_total$ = -8						; size = 4
_i$ = -4						; size = 4
_pfnNumberOfEntities PROC				; COMDAT

; 3562 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3563 : 	int	i, total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 3564 : 
; 3565 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnNumberO
$LN2@pfnNumberO:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnNumberO:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	SHORT $LN3@pfnNumberO

; 3566 : 	{
; 3567 : 		if( svgame.edicts[i].free )

	imul	eax, DWORD PTR _i$[ebp], 900
	mov	ecx, DWORD PTR _svgame+7928
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $LN5@pfnNumberO

; 3568 : 			continue;

	jmp	SHORT $LN2@pfnNumberO
$LN5@pfnNumberO:

; 3569 : 		total++;

	mov	eax, DWORD PTR _total$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax

; 3570 : 	}

	jmp	SHORT $LN2@pfnNumberO
$LN3@pfnNumberO:

; 3571 : 
; 3572 : 	return total;

	mov	eax, DWORD PTR _total$[ebp]

; 3573 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnNumberOfEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnIsMapValid
_TEXT	SEGMENT
_flags$ = -4						; size = 4
_filename$ = 8						; size = 4
_pfnIsMapValid PROC					; COMDAT

; 3463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3464 : 	int	flags = SV_MapIsValid( filename, GI->mp_entity, NULL );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 1336				; 00000538H
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 3465 : 
; 3466 : 	if( FBitSet( flags, MAP_IS_EXIST ) && FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@pfnIsMapVa
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN2@pfnIsMapVa

; 3467 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnIsMapVa
$LN2@pfnIsMapVa:

; 3468 : 	return false;

	xor	eax, eax
$LN1@pfnIsMapVa:

; 3469 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsMapValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnDecalIndex
_TEXT	SEGMENT
_i$ = -4						; size = 4
_m$ = 8							; size = 4
_pfnDecalIndex PROC					; COMDAT

; 2515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2516 : 	int	i;
; 2517 : 
; 2518 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnDecalIn

; 2519 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnDecalIn
$LN5@pfnDecalIn:

; 2520 : 
; 2521 : 	for( i = 1; i < MAX_DECALS && host.draw_decals[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnDecalIn
$LN2@pfnDecalIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnDecalIn:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@pfnDecalIn
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _host[eax+edx+1468]
	test	eax, eax
	je	SHORT $LN3@pfnDecalIn

; 2522 : 	{
; 2523 : 		if( !Q_stricmp( host.draw_decals[i], m ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _host+1468
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnDecalIn

; 2524 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@pfnDecalIn
$LN6@pfnDecalIn:

; 2525 : 	}

	jmp	SHORT $LN2@pfnDecalIn
$LN3@pfnDecalIn:

; 2526 : 
; 2527 : 	return -1;	

	or	eax, -1
$LN1@pfnDecalIn:

; 2528 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDecalIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_game.c
;	COMDAT _pfnPEntityOfEntIndex
_TEXT	SEGMENT
_pEdict$1 = -4						; size = 4
_iEntIndex$ = 8						; size = 4
_pfnPEntityOfEntIndex PROC				; COMDAT

; 3118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3119 : 	if( iEntIndex >= 0 && iEntIndex < GI->max_edicts )

	cmp	DWORD PTR _iEntIndex$[ebp], 0
	jl	$LN2@pfnPEntity
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _iEntIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	$LN2@pfnPEntity

; 3120 : 	{
; 3121 : 		edict_t	*pEdict = EDICT_NUM( iEntIndex );

	mov	eax, DWORD PTR _iEntIndex$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$1[ebp], eax

; 3122 : 
; 3123 : 		if( !iEntIndex || FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	cmp	DWORD PTR _iEntIndex$[ebp], 0
	je	SHORT $LN4@pfnPEntity
	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	je	SHORT $LN3@pfnPEntity
$LN4@pfnPEntity:

; 3124 : 			return pEdict; // just get access to array

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN3@pfnPEntity:

; 3125 : 
; 3126 : 		if( SV_IsValidEdict( pEdict ) && pEdict->pvPrivateData )

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPEntityOfEntIndex@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@pfnPEntity
	mov	eax, DWORD PTR _pEdict$1[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN5@pfnPEntity

; 3127 : 			return pEdict;

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN5@pfnPEntity:

; 3128 : 
; 3129 : 		// g-cont: world and clients can be acessed even without private data!
; 3130 : 		if( SV_IsValidEdict( pEdict ) && SV_IsPlayerIndex( iEntIndex ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPEntityOfEntIndex@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@HBHOCCCI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@pfnPEntity
	mov	eax, DWORD PTR _iEntIndex$[ebp]
	push	eax
	call	_SV_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@pfnPEntity

; 3131 : 			return pEdict;

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN2@pfnPEntity:

; 3132 : 	}
; 3133 : 
; 3134 : 	return NULL;

	xor	eax, eax
$LN1@pfnPEntity:

; 3135 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPEntityOfEntIndex ENDP
_TEXT	ENDS
END
