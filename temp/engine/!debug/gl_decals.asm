; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_decals.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_R_CreateDecalList
PUBLIC	_R_DecalRemoveAll
PUBLIC	_R_ClearAllDecals
PUBLIC	_DrawSurfaceDecals
PUBLIC	_R_DecalSetupVerts
PUBLIC	_DrawSingleDecal
PUBLIC	_R_EntityRemoveDecals
PUBLIC	_DrawDecalsBatch
PUBLIC	_R_ClearDecals
PUBLIC	_R_DecalShoot
PUBLIC	_R_DecalComputeBasis
PUBLIC	_R_SetupDecalTextureSpaceBasis
PUBLIC	_R_SetupDecalVertsForMSurface
PUBLIC	_R_SetupDecalClip
PUBLIC	_R_ClipInside
PUBLIC	_R_ClipIntersect
PUBLIC	_R_DoDecalSHClip
PUBLIC	_R_DecalVertsClip
PUBLIC	_R_DecalCreatePoly
PUBLIC	_R_DecalSurface
PUBLIC	?__LINE__Var@?0??R_DecalUnlink@@9@9		; `R_DecalUnlink'::`1'::__LINE__Var
PUBLIC	??_C@_0BP@BBPGPHGC@D_DecalUnlink?3?5bad?5decal?5list?6@ ; `string'
PUBLIC	??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??R_DecalCreatePoly@@9@9		; `R_DecalCreatePoly'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??R_DecalNode@@9@9		; `R_DecalNode'::`1'::__LINE__Var
PUBLIC	??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0CH@PKPNMMIJ@?$FO1Error?3?$FO7?5Decal?5has?5invalid?5te@ ; `string'
PUBLIC	??_C@_0CH@BHCFOIAO@?$FO1Error?3?$FO7?5Decals?5must?5hit?5mod_@ ; `string'
PUBLIC	?__LINE__Var@?0??DrawSurfaceDecals@@9@9		; `DrawSurfaceDecals'::`1'::__LINE__Var
PUBLIC	??_C@_09GMNCBEGH@e?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??DrawDecalsBatch@@9@9		; `DrawDecalsBatch'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40800000
PUBLIC	__real@41800000
PUBLIC	__real@46040000
PUBLIC	__real@bf800000
PUBLIC	__real@c0800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_com_studiocache:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glState:BYTE
EXTRN	_gl_polyoffset:DWORD
EXTRN	_r_decals:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_g_DecalClipVerts DD 0e0H DUP (?)
_g_DecalClipVerts2 DD 0e0H DUP (?)
_gDecalPool DB	03c000H DUP (?)
_gDecalCount DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0800000
CONST	SEGMENT
__real@c0800000 DD 0c0800000r			; -4
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@46040000
CONST	SEGMENT
__real@46040000 DD 046040000r			; 8448
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DrawDecalsBatch@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??DrawDecalsBatch@@9@9 DD 0411H		; `DrawDecalsBatch'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09GMNCBEGH@e?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_09GMNCBEGH@e?5?$CB?$DN?5NULL@ DB 'e != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DrawSurfaceDecals@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??DrawSurfaceDecals@@9@9 DD 0388H	; `DrawSurfaceDecals'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@BHCFOIAO@?$FO1Error?3?$FO7?5Decals?5must?5hit?5mod_@
CONST	SEGMENT
??_C@_0CH@BHCFOIAO@?$FO1Error?3?$FO7?5Decals?5must?5hit?5mod_@ DB '^1Erro'
	DB	'r:^7 Decals must hit mod_brush!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PKPNMMIJ@?$FO1Error?3?$FO7?5Decal?5has?5invalid?5te@
CONST	SEGMENT
??_C@_0CH@PKPNMMIJ@?$FO1Error?3?$FO7?5Decal?5has?5invalid?5te@ DB '^1Erro'
	DB	'r:^7 Decal has invalid texture!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@ DB 'node != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_DecalNode@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DecalNode@@9@9 DD 02c6H		; `R_DecalNode'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??R_DecalCreatePoly@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DecalCreatePoly@@9@9 DD 0202H	; `R_DecalCreatePoly'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_decals.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BBPGPHGC@D_DecalUnlink?3?5bad?5decal?5list?6@
CONST	SEGMENT
??_C@_0BP@BBPGPHGC@D_DecalUnlink?3?5bad?5decal?5list?6@ DB 'D_DecalUnlink'
	DB	': bad decal list', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_DecalUnlink@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DecalUnlink@@9@9 DD 044H		; `R_DecalUnlink'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01c0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	06daH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0b9dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	07dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0543H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0401H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0721H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _DecalDepthCompare
_TEXT	SEGMENT
_elem2$ = -8						; size = 4
_elem1$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_DecalDepthCompare PROC					; COMDAT

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1142 : 	const decallist_t	*elem1, *elem2;
; 1143 : 
; 1144 : 	elem1 = (const decallist_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _elem1$[ebp], eax

; 1145 : 	elem2 = (const decallist_t *)b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _elem2$[ebp], eax

; 1146 : 
; 1147 : 	if( elem1->depth > elem2->depth )

	mov	eax, DWORD PTR _elem1$[ebp]
	movzx	ecx, BYTE PTR [eax+78]
	mov	edx, DWORD PTR _elem2$[ebp]
	movzx	eax, BYTE PTR [edx+78]
	cmp	ecx, eax
	jle	SHORT $LN2@DecalDepth

; 1148 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@DecalDepth
$LN2@DecalDepth:

; 1149 : 	if( elem1->depth < elem2->depth )

	mov	eax, DWORD PTR _elem1$[ebp]
	movzx	ecx, BYTE PTR [eax+78]
	mov	edx, DWORD PTR _elem2$[ebp]
	movzx	eax, BYTE PTR [edx+78]
	cmp	ecx, eax
	jge	SHORT $LN3@DecalDepth

; 1150 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@DecalDepth
$LN3@DecalDepth:

; 1151 : 
; 1152 : 	return 0;

	xor	eax, eax
$LN1@DecalDepth:

; 1153 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DecalDepthCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _DecalListAdd
_TEXT	SEGMENT
tv213 = -96						; size = 8
tv148 = -92						; size = 4
_i$ = -24						; size = 4
_pdecal$ = -20						; size = 4
_tmp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pList$ = 8						; size = 4
_count$ = 12						; size = 4
_DecalListAdd PROC					; COMDAT

; 1118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1119 : 	vec3_t		tmp;
; 1120 : 	decallist_t	*pdecal;
; 1121 : 	int		i;
; 1122 : 
; 1123 : 	pdecal = pList + count;

	imul	eax, DWORD PTR _count$[ebp], 136
	add	eax, DWORD PTR _pList$[ebp]
	mov	DWORD PTR _pdecal$[ebp], eax

; 1124 : 
; 1125 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DecalListA
$LN2@DecalListA:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DecalListA:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@DecalListA

; 1126 : 	{
; 1127 : 		if( !Q_strcmp( pdecal->name, pList[i].name ) &&  pdecal->entityIndex == pList[i].entityIndex )

	push	99999					; 0001869fH
	imul	eax, DWORD PTR _i$[ebp], 136
	mov	ecx, DWORD PTR _pList$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	push	edx
	mov	eax, DWORD PTR _pdecal$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN6@DecalListA
	mov	eax, DWORD PTR _pdecal$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	imul	edx, DWORD PTR _i$[ebp], 136
	mov	eax, DWORD PTR _pList$[ebp]
	movsx	edx, WORD PTR [eax+edx+76]
	cmp	ecx, edx
	jne	$LN6@DecalListA

; 1128 : 		{
; 1129 : 			VectorSubtract( pdecal->position, pList[i].position, tmp );	// Merge

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, DWORD PTR _pList$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pdecal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _tmp$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 136
	add	ecx, DWORD PTR _pList$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pdecal$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _tmp$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, DWORD PTR _pList$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pdecal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR tv148[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _tmp$[ebp+ecx], xmm0

; 1130 : 
; 1131 : 			if( VectorLength( tmp ) < DECAL_OVERLAP_DISTANCE )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+ecx]
	mulss	xmm0, DWORD PTR _tmp$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _tmp$[ebp+ecx]
	mulss	xmm1, DWORD PTR _tmp$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _tmp$[ebp+eax]
	mulss	xmm1, DWORD PTR _tmp$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv213[ebp]
	movsd	xmm0, QWORD PTR __real@4000000000000000
	comisd	xmm0, QWORD PTR tv213[ebp]
	jbe	SHORT $LN6@DecalListA

; 1132 : 				return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $LN1@DecalListA
$LN6@DecalListA:

; 1133 : 		}
; 1134 : 	}

	jmp	$LN2@DecalListA
$LN3@DecalListA:

; 1135 : 
; 1136 : 	// this is a new decal
; 1137 : 	return count + 1;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
$LN1@DecalListA:

; 1138 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DecalListAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalUnProject
_TEXT	SEGMENT
tv149 = -68						; size = 4
_pdecal$ = 8						; size = 4
_entry$ = 12						; size = 4
_R_DecalUnProject PROC					; COMDAT

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1097 : 	if( !pdecal || !( pdecal->psurface ))

	cmp	DWORD PTR _pdecal$[ebp], 0
	je	SHORT $LN3@R_DecalUnP
	mov	eax, DWORD PTR _pdecal$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@R_DecalUnP
$LN3@R_DecalUnP:

; 1098 : 		return false;

	xor	eax, eax
	jmp	$LN1@R_DecalUnP
$LN2@R_DecalUnP:

; 1099 : 
; 1100 : 	VectorCopy( pdecal->position, entry->position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR _pdecal$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx], eax

; 1101 : 	entry->entityIndex = pdecal->entityIndex;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	dx, WORD PTR [ecx+24]
	mov	WORD PTR [eax+76], dx

; 1102 : 
; 1103 : 	// Grab surface plane equation
; 1104 : 	if( pdecal->psurface->flags & SURF_PLANEBACK )

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	je	$LN4@R_DecalUnP

; 1105 : 		VectorNegate( pdecal->psurface->plane->normal, entry->impactPlaneNormal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv149[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0
	jmp	SHORT $LN5@R_DecalUnP
$LN4@R_DecalUnP:

; 1106 : 	else VectorCopy( pdecal->psurface->plane->normal, entry->impactPlaneNormal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax+84], ecx
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+84], ecx
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+84], ecx
$LN5@R_DecalUnP:

; 1107 : 
; 1108 : 	return true;

	mov	eax, 1
$LN1@R_DecalUnP:

; 1109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalUnProject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalNode
_TEXT	SEGMENT
tv70 = -76						; size = 4
_dist$ = -8						; size = 4
_splitplane$ = -4					; size = 4
_model$ = 8						; size = 4
_node$ = 12						; size = 4
_decalinfo$ = 16					; size = 4
_R_DecalNode PROC					; COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 711  : 	mplane_t	*splitplane;
; 712  : 	float	dist;
; 713  : 	
; 714  : 	Assert( node != NULL );

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN9@R_DecalNod
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@R_DecalNod
$LN9@R_DecalNod:
	mov	DWORD PTR tv70[ebp], 0
$LN10@R_DecalNod:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DecalNode@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 715  : 
; 716  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN2@R_DecalNod

; 717  : 	{
; 718  : 		// hit a leaf
; 719  : 		return;

	jmp	$LN6@R_DecalNod
$LN2@R_DecalNod:

; 720  : 	}
; 721  : 
; 722  : 	splitplane = node->plane;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _splitplane$[ebp], ecx

; 723  : 	dist = DotProduct( decalinfo->m_Position, splitplane->normal ) - splitplane->dist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	mov	esi, DWORD PTR _splitplane$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	mov	esi, DWORD PTR _splitplane$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _decalinfo$[ebp]
	mov	esi, DWORD PTR _splitplane$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _splitplane$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _dist$[ebp], xmm0

; 724  : 
; 725  : 	// This is arbitrarily set to 10 right now. In an ideal world we'd have the 
; 726  : 	// exact surface but we don't so, this tells me which planes are "sort of 
; 727  : 	// close" to the gunshot -- the gunshot is actually 4 units in front of the 
; 728  : 	// wall (see dlls\weapons.cpp). We also need to check to see if the decal 
; 729  : 	// actually intersects the texture space of the surface, as this method tags
; 730  : 	// parallel surfaces in the same node always.
; 731  : 	// JAY: This still tags faces that aren't correct at edges because we don't 
; 732  : 	// have a surface normal
; 733  : 	if( dist > decalinfo->m_Size )

	mov	eax, DWORD PTR _decalinfo$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@R_DecalNod

; 734  : 	{
; 735  : 		R_DecalNode( model, node->children[0], decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_R_DecalNode
	add	esp, 12					; 0000000cH

; 736  : 	}

	jmp	$LN6@R_DecalNod
$LN3@R_DecalNod:

; 737  : 	else if( dist < -decalinfo->m_Size )

	mov	eax, DWORD PTR _decalinfo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	neg	ecx
	cvtsi2ss xmm0, ecx
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN5@R_DecalNod

; 738  : 	{
; 739  : 		R_DecalNode( model, node->children[1], decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	_R_DecalNode
	add	esp, 12					; 0000000cH

; 740  : 	}

	jmp	SHORT $LN6@R_DecalNod
$LN5@R_DecalNod:

; 741  : 	else 
; 742  : 	{
; 743  : 		if( dist < DECAL_DISTANCE && dist > -DECAL_DISTANCE )

	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN7@R_DecalNod
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@c0800000
	jbe	SHORT $LN7@R_DecalNod

; 744  : 			R_DecalNodeSurfaces( model, node, decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_R_DecalNodeSurfaces
	add	esp, 12					; 0000000cH
$LN7@R_DecalNod:

; 745  : 
; 746  : 		R_DecalNode( model, node->children[0], decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_R_DecalNode
	add	esp, 12					; 0000000cH

; 747  : 		R_DecalNode( model, node->children[1], decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	_R_DecalNode
	add	esp, 12					; 0000000cH
$LN6@R_DecalNod:

; 748  : 	}
; 749  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalNodeSurfaces
_TEXT	SEGMENT
_i$ = -8						; size = 4
_surf$ = -4						; size = 4
_model$ = 8						; size = 4
_node$ = 12						; size = 4
_decalinfo$ = 16					; size = 4
_R_DecalNodeSurfaces PROC				; COMDAT

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 685  : 	// iterate over all surfaces in the node
; 686  : 	msurface_t	*surf;
; 687  : 	int		i;
; 688  : 
; 689  : 	surf = model->surfaces + node->firstsurface;

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _model$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], edx

; 690  : 
; 691  : 	for( i = 0; i < node->numsurfaces; i++, surf++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DecalNod
$LN2@R_DecalNod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN4@R_DecalNod:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN1@R_DecalNod

; 692  : 	{
; 693  : 		// never apply decals on the water or sky surfaces
; 694  : 		if( surf->flags & (SURF_DRAWTURB|SURF_DRAWSKY|SURF_CONVEYOR))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 84					; 00000054H
	je	SHORT $LN5@R_DecalNod

; 695  : 			continue;

	jmp	SHORT $LN2@R_DecalNod
$LN5@R_DecalNod:

; 696  : 
; 697  : 		if( surf->flags & SURF_TRANSPARENT && !glState.stencilEnabled )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN6@R_DecalNod
	cmp	DWORD PTR _glState+568, 0
	jne	SHORT $LN6@R_DecalNod

; 698  : 			continue;

	jmp	SHORT $LN2@R_DecalNod
$LN6@R_DecalNod:

; 699  : 
; 700  : 		R_DecalSurface( surf, decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	call	_R_DecalSurface
	add	esp, 8

; 701  : 	}

	jmp	SHORT $LN2@R_DecalNod
$LN1@R_DecalNod:

; 702  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalNodeSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalSurface
_TEXT	SEGMENT
tv595 = -148						; size = 8
tv553 = -148						; size = 8
tv617 = -140						; size = 8
tv615 = -140						; size = 8
tv574 = -132						; size = 8
tv532 = -132						; size = 8
_h$ = -60						; size = 4
_w$ = -56						; size = 4
_t$ = -52						; size = 4
_s$ = -48						; size = 4
_textureV$ = -44					; size = 16
_textureU$ = -28					; size = 16
_decal$ = -12						; size = 4
_tex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_surf$ = 8						; size = 4
_decalinfo$ = 12					; size = 4
_R_DecalSurface PROC					; COMDAT

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 616  : 	// get the texture associated with this surface
; 617  : 	mtexinfo_t	*tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 618  : 	decal_t		*decal = surf->pdecals;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _decal$[ebp], ecx

; 619  : 	vec4_t		textureU, textureV;
; 620  : 	float		s, t, w, h;
; 621  : 
; 622  : 	// we in restore mode
; 623  : 	if( cls.state == ca_connected || cls.state == ca_validate )

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN5@R_DecalSur
	cmp	DWORD PTR _cls, 3
	jne	$LN3@R_DecalSur
$LN5@R_DecalSur:

; 624  : 	{
; 625  : 		// NOTE: we may have the decal on this surface that come from another level.
; 626  : 		// check duplicate with same position and texture
; 627  : 		while( decal != NULL )

	cmp	DWORD PTR _decal$[ebp], 0
	je	$LN3@R_DecalSur

; 628  : 		{
; 629  : 			if( VectorCompare( decal->position, decalinfo->m_Position ) && decal->texture == decalinfo->m_iTexture )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+28]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DecalSur
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _decal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+28]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DecalSur
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _decal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+28]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DecalSur
	mov	eax, DWORD PTR _decal$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	mov	edx, DWORD PTR _decalinfo$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jne	SHORT $LN6@R_DecalSur

; 630  : 				return; // decal already exists, don't place it again

	jmp	$LN1@R_DecalSur
$LN6@R_DecalSur:

; 631  : 			decal = decal->pnext;

	mov	eax, DWORD PTR _decal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _decal$[ebp], ecx

; 632  : 		}

	jmp	$LN5@R_DecalSur
$LN3@R_DecalSur:

; 633  : 	}
; 634  : 
; 635  : 	Vector4Copy( tex->vecs[0], textureU );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _tex$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _textureU$[ebp+edx], eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _tex$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _textureU$[ebp+ecx], edx
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _tex$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _textureU$[ebp+eax], ecx
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _tex$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 4
	imul	ecx, ecx, 3
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _textureU$[ebp+ecx], edx

; 636  : 	Vector4Copy( tex->vecs[1], textureV );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _tex$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _textureV$[ebp+ecx], edx
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _tex$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _textureV$[ebp+edx], eax
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _tex$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _textureV$[ebp+eax], ecx
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _tex$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, 4
	imul	eax, eax, 3
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _textureV$[ebp+eax], ecx

; 637  : 
; 638  : 	// project decal center into the texture space of the surface
; 639  : 	s = DotProduct( decalinfo->m_Position, textureU ) + textureU[3] - surf->texturemins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _textureU$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _textureU$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _textureU$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR _textureU$[ebp+ecx]
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax+20]
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 640  : 	t = DotProduct( decalinfo->m_Position, textureV ) + textureV[3] - surf->texturemins[1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _textureV$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _textureV$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _decalinfo$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _textureV$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR _textureV$[ebp+ecx]
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _surf$[ebp]
	movsx	ecx, WORD PTR [eax+edx+20]
	cvtsi2ss xmm1, ecx
	subss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 641  : 
; 642  : 	// Determine the decal basis (measured in world space)
; 643  : 	// Note that the decal basis vectors 0 and 1 will always lie in the same
; 644  : 	// plane as the texture space basis vectorstextureVecsTexelsPerWorldUnits.
; 645  : 	R_DecalComputeBasis( surf, decalinfo->m_Flags, decalinfo->m_Basis );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_R_DecalComputeBasis
	add	esp, 12					; 0000000cH

; 646  : 
; 647  : 	// Compute an effective width and height (axis aligned) in the parent texture space
; 648  : 	// How does this work? decalBasis[0] represents the u-direction (width)
; 649  : 	// of the decal measured in world space, decalBasis[1] represents the 
; 650  : 	// v-direction (height) measured in world space.
; 651  : 	// textureVecsTexelsPerWorldUnits[0] represents the u direction of 
; 652  : 	// the surface's texture space measured in world space (with the appropriate
; 653  : 	// scale factor folded in), and textureVecsTexelsPerWorldUnits[1]
; 654  : 	// represents the texture space v direction. We want to find the dimensions (w,h)
; 655  : 	// of a square measured in texture space, axis aligned to that coordinate system.
; 656  : 	// All we need to do is to find the components of the decal edge vectors
; 657  : 	// (decalWidth * decalBasis[0], decalHeight * decalBasis[1])
; 658  : 	// in texture coordinates:
; 659  : 
; 660  : 	w = fabs( decalinfo->m_decalWidth  * DotProduct( textureU, decalinfo->m_Basis[0] )) +

	mov	eax, DWORD PTR _decalinfo$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+36]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+44]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm1, DWORD PTR _textureU$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	lea	eax, DWORD PTR [edx+eax+44]
	mov	edx, 4
	shl	edx, 0
	movss	xmm2, DWORD PTR _textureU$[ebp+ecx]
	mulss	xmm2, DWORD PTR [eax+edx]
	addss	xmm1, xmm2
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [ecx+edx+44]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm2, DWORD PTR _textureU$[ebp+eax]
	mulss	xmm2, DWORD PTR [edx+ecx]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv532[ebp]
	movsd	xmm0, QWORD PTR tv532[ebp]
	mov	edx, DWORD PTR _decalinfo$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+40]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm2, DWORD PTR _textureU$[ebp+ecx]
	mulss	xmm2, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	shl	eax, 0
	movss	xmm3, DWORD PTR _textureU$[ebp+ecx]
	mulss	xmm3, DWORD PTR [edx+eax]
	addss	xmm2, xmm3
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	shl	eax, 1
	movss	xmm3, DWORD PTR _textureU$[ebp+ecx]
	mulss	xmm3, DWORD PTR [edx+eax]
	addss	xmm2, xmm3
	mulss	xmm1, xmm2
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv615[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv553[ebp]
	movsd	xmm0, QWORD PTR tv615[ebp]
	addsd	xmm0, QWORD PTR tv553[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _w$[ebp], xmm0

; 661  : 	    fabs( decalinfo->m_decalHeight * DotProduct( textureU, decalinfo->m_Basis[1] ));
; 662  : 	
; 663  : 	h = fabs( decalinfo->m_decalWidth  * DotProduct( textureV, decalinfo->m_Basis[0] )) +

	mov	eax, DWORD PTR _decalinfo$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+36]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+44]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm1, DWORD PTR _textureV$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	lea	eax, DWORD PTR [edx+eax+44]
	mov	edx, 4
	shl	edx, 0
	movss	xmm2, DWORD PTR _textureV$[ebp+ecx]
	mulss	xmm2, DWORD PTR [eax+edx]
	addss	xmm1, xmm2
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [ecx+edx+44]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm2, DWORD PTR _textureV$[ebp+eax]
	mulss	xmm2, DWORD PTR [edx+ecx]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv574[ebp]
	movsd	xmm0, QWORD PTR tv574[ebp]
	mov	edx, DWORD PTR _decalinfo$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+40]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm2, DWORD PTR _textureV$[ebp+ecx]
	mulss	xmm2, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	shl	eax, 0
	movss	xmm3, DWORD PTR _textureV$[ebp+ecx]
	mulss	xmm3, DWORD PTR [edx+eax]
	addss	xmm2, xmm3
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+44]
	mov	eax, 4
	shl	eax, 1
	movss	xmm3, DWORD PTR _textureV$[ebp+ecx]
	mulss	xmm3, DWORD PTR [edx+eax]
	addss	xmm2, xmm3
	mulss	xmm1, xmm2
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv617[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv595[ebp]
	movsd	xmm0, QWORD PTR tv617[ebp]
	addsd	xmm0, QWORD PTR tv595[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _h$[ebp], xmm0

; 664  : 	    fabs( decalinfo->m_decalHeight * DotProduct( textureV, decalinfo->m_Basis[1] ));
; 665  : 
; 666  : 	// move s,t to upper left corner
; 667  : 	s -= ( w * 0.5f );

	movss	xmm0, DWORD PTR _w$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 668  : 	t -= ( h * 0.5f );

	movss	xmm0, DWORD PTR _h$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _t$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 669  : 
; 670  : 	// Is this rect within the surface? -- tex width & height are unsigned
; 671  : 	if( s <= -w || t <= -h || s > (surf->extents[0] + w) || t > (surf->extents[1] + h))

	movss	xmm0, DWORD PTR _w$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _s$[ebp]
	jae	SHORT $LN8@R_DecalSur
	movss	xmm0, DWORD PTR _h$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _t$[ebp]
	jae	SHORT $LN8@R_DecalSur
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx+24]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR _w$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN8@R_DecalSur
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax+24]
	cvtsi2ss xmm0, edx
	addss	xmm0, DWORD PTR _h$[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@R_DecalSur
$LN8@R_DecalSur:

; 672  : 	{
; 673  : 		return; // nope

	jmp	SHORT $LN1@R_DecalSur
$LN7@R_DecalSur:

; 674  : 	}
; 675  : 
; 676  : 	// stamp it
; 677  : 	R_DecalCreate( decalinfo, surf, s, t );

	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	push	ecx
	call	_R_DecalCreate
	add	esp, 16					; 00000010H
$LN1@R_DecalSur:

; 678  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalCreate
_TEXT	SEGMENT
_vertCount$ = -16					; size = 4
_count$ = -12						; size = 4
_pold$ = -8						; size = 4
_pdecal$ = -4						; size = 4
_decalinfo$ = 8						; size = 4
_surf$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_R_DecalCreate PROC					; COMDAT

; 576  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 577  : 	decal_t	*pdecal, *pold;
; 578  : 	int	count, vertCount;
; 579  : 
; 580  : 	if( !surf ) return;	// ???

	cmp	DWORD PTR _surf$[ebp], 0
	jne	SHORT $LN2@R_DecalCre
	jmp	$LN1@R_DecalCre
$LN2@R_DecalCre:

; 581  : 	
; 582  : 	pold = R_DecalIntersect( decalinfo, surf, &count );

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalinfo$[ebp]
	push	edx
	call	_R_DecalIntersect
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pold$[ebp], eax

; 583  : 	if( count < MAX_OVERLAP_DECALS ) pold = NULL;

	cmp	DWORD PTR _count$[ebp], 6
	jge	SHORT $LN3@R_DecalCre
	mov	DWORD PTR _pold$[ebp], 0
$LN3@R_DecalCre:

; 584  : 
; 585  : 	pdecal = R_DecalAlloc( pold );

	mov	eax, DWORD PTR _pold$[ebp]
	push	eax
	call	_R_DecalAlloc
	add	esp, 4
	mov	DWORD PTR _pdecal$[ebp], eax

; 586  : 	if( !pdecal ) return; // r_decals == 0 ???

	cmp	DWORD PTR _pdecal$[ebp], 0
	jne	SHORT $LN4@R_DecalCre
	jmp	$LN1@R_DecalCre
$LN4@R_DecalCre:

; 587  : 
; 588  : 	pdecal->flags = decalinfo->m_Flags;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	dx, WORD PTR [ecx+24]
	mov	WORD PTR [eax+22], dx

; 589  : 
; 590  : 	VectorCopy( decalinfo->m_Position, pdecal->position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	esi, DWORD PTR _decalinfo$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+28], eax

; 591  : 
; 592  : 	pdecal->dx = x;

	mov	eax, DWORD PTR _pdecal$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 593  : 	pdecal->dy = y;

	mov	eax, DWORD PTR _pdecal$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 594  : 
; 595  : 	// set scaling
; 596  : 	pdecal->scale = decalinfo->m_scale;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 597  : 	pdecal->entityIndex = decalinfo->m_Entity;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	dx, WORD PTR [ecx+28]
	mov	WORD PTR [eax+24], dx

; 598  : 	pdecal->texture = decalinfo->m_iTexture;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR [eax+20], dx

; 599  : 
; 600  : 	// check to see if the decal actually intersects the surface
; 601  : 	// if not, then remove the decal
; 602  : 	R_DecalVertsClip( pdecal, surf, decalinfo->m_iTexture, &vertCount );

	lea	eax, DWORD PTR _vertCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdecal$[ebp]
	push	ecx
	call	_R_DecalVertsClip
	add	esp, 16					; 00000010H

; 603  : 	
; 604  : 	if( !vertCount )

	cmp	DWORD PTR _vertCount$[ebp], 0
	jne	SHORT $LN5@R_DecalCre

; 605  : 	{
; 606  : 		R_DecalUnlink( pdecal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	push	eax
	call	_R_DecalUnlink
	add	esp, 4

; 607  : 		return;

	jmp	SHORT $LN1@R_DecalCre
$LN5@R_DecalCre:

; 608  : 	}
; 609  : 
; 610  : 	// add to the surface's list
; 611  : 	R_AddDecalToSurface( pdecal, surf, decalinfo );

	mov	eax, DWORD PTR _decalinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdecal$[ebp]
	push	edx
	call	_R_AddDecalToSurface
	add	esp, 12					; 0000000cH
$LN1@R_DecalCre:

; 612  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_AddDecalToSurface
_TEXT	SEGMENT
_pold$ = -4						; size = 4
_pdecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_decalinfo$ = 16					; size = 4
_R_AddDecalToSurface PROC				; COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 548  : 	decal_t	*pold;
; 549  : 
; 550  : 	pdecal->pnext = NULL;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	DWORD PTR [eax], 0

; 551  : 	pold = surf->pdecals;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _pold$[ebp], ecx

; 552  : 
; 553  : 	if( pold ) 

	cmp	DWORD PTR _pold$[ebp], 0
	je	SHORT $LN4@R_AddDecal
$LN2@R_AddDecal:

; 554  : 	{
; 555  : 		while( pold->pnext ) 

	mov	eax, DWORD PTR _pold$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@R_AddDecal

; 556  : 			pold = pold->pnext;

	mov	eax, DWORD PTR _pold$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pold$[ebp], ecx
	jmp	SHORT $LN2@R_AddDecal
$LN3@R_AddDecal:

; 557  : 		pold->pnext = pdecal;

	mov	eax, DWORD PTR _pold$[ebp]
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	DWORD PTR [eax], ecx

; 558  : 	}

	jmp	SHORT $LN5@R_AddDecal
$LN4@R_AddDecal:

; 559  : 	else
; 560  : 	{
; 561  : 		surf->pdecals = pdecal;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	DWORD PTR [eax+88], ecx
$LN5@R_AddDecal:

; 562  : 	}
; 563  : 
; 564  : 	// tag surface
; 565  : 	pdecal->psurface = surf;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 566  : 
; 567  : 	// at this point decal are linked with surface
; 568  : 	// and will be culled, drawing and sorting
; 569  : 	// together with surface
; 570  : 
; 571  : 	// alloc clipped poly for decal
; 572  : 	R_DecalCreatePoly( decalinfo, pdecal, surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdecal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalinfo$[ebp]
	push	edx
	call	_R_DecalCreatePoly
	add	esp, 12					; 0000000cH

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AddDecalToSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalCreatePoly
_TEXT	SEGMENT
_i$ = -16						; size = 4
_v$ = -12						; size = 4
_poly$ = -8						; size = 4
_lnumverts$ = -4					; size = 4
_decalinfo$ = 8						; size = 4
_pdecal$ = 12						; size = 4
_surf$ = 16						; size = 4
_R_DecalCreatePoly PROC					; COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 515  : 	int		lnumverts;
; 516  : 	glpoly_t		*poly;
; 517  : 	float		*v;
; 518  : 	int		i;
; 519  : 
; 520  : 	if( pdecal->polys )	// already created?

	mov	eax, DWORD PTR _pdecal$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN5@R_DecalCre

; 521  : 		return pdecal->polys;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [eax+40]
	jmp	$LN1@R_DecalCre
$LN5@R_DecalCre:

; 522  : 
; 523  : 	v = R_DecalSetupVerts( pdecal, surf, pdecal->texture, &lnumverts );

	lea	eax, DWORD PTR _lnumverts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdecal$[ebp]
	movsx	edx, WORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdecal$[ebp]
	push	ecx
	call	_R_DecalSetupVerts
	add	esp, 16					; 00000010H
	mov	DWORD PTR _v$[ebp], eax

; 524  : 	if( !lnumverts ) return NULL;	// probably this never happens

	cmp	DWORD PTR _lnumverts$[ebp], 0
	jne	SHORT $LN6@R_DecalCre
	xor	eax, eax
	jmp	$LN1@R_DecalCre
$LN6@R_DecalCre:

; 525  : 
; 526  : 	// allocate glpoly
; 527  : 	poly = Mem_Calloc( com_studiocache, sizeof( glpoly_t ) + ( lnumverts - 4 ) * VERTEXSIZE * sizeof( float ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DecalCreatePoly@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _lnumverts$[ebp]
	sub	ecx, 4
	imul	edx, ecx, 7
	lea	eax, DWORD PTR [edx*4+128]
	push	eax
	mov	ecx, DWORD PTR _com_studiocache
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _poly$[ebp], eax

; 528  : 	poly->next = pdecal->polys;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax], edx

; 529  : 	poly->flags = surf->flags;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 530  : 	pdecal->polys = poly;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 531  : 	poly->numverts = lnumverts;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _lnumverts$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 532  : 
; 533  : 	for( i = 0; i < lnumverts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DecalCre
$LN2@R_DecalCre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN4@R_DecalCre:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _lnumverts$[ebp]
	jge	$LN3@R_DecalCre

; 534  : 	{
; 535  : 		VectorCopy( v, poly->verts[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	eax, DWORD PTR [ecx+eax+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 28
	mov	edx, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+16]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 536  : 		poly->verts[i][3] = v[3];

	mov	eax, 4
	imul	ecx, eax, 3
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 537  : 		poly->verts[i][4] = v[4];

	mov	eax, 4
	shl	eax, 2
	imul	ecx, DWORD PTR _i$[ebp], 28
	mov	edx, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+16]
	mov	edx, 4
	shl	edx, 2
	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 538  : 		poly->verts[i][5] = v[5];

	mov	eax, 4
	imul	ecx, eax, 5
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 5
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 539  : 		poly->verts[i][6] = v[6];

	mov	eax, 4
	imul	ecx, eax, 6
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 6
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 540  : 	}

	jmp	$LN2@R_DecalCre
$LN3@R_DecalCre:

; 541  : 
; 542  : 	return poly;

	mov	eax, DWORD PTR _poly$[ebp]
$LN1@R_DecalCre:

; 543  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalCreatePoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalIntersect
_TEXT	SEGMENT
tv558 = -228						; size = 4
tv538 = -228						; size = 4
tv548 = -224						; size = 4
tv528 = -224						; size = 4
tv518 = -224						; size = 4
tv446 = -224						; size = 4
tv410 = -224						; size = 4
tv374 = -224						; size = 4
tv302 = -224						; size = 4
tv266 = -224						; size = 4
tv217 = -224						; size = 4
tv160 = -224						; size = 4
_flArea$1 = -156					; size = 4
_vUnionMax$2 = -152					; size = 8
_vUnionMin$3 = -144					; size = 8
_vDecalMax$4 = -136					; size = 8
_vDecalMin$5 = -128					; size = 8
_testWorldScale$6 = -120				; size = 8
_testPosition$7 = -112					; size = 24
_testBasis$8 = -88					; size = 36
_mapSize$ = -52						; size = 8
_lastArea$ = -44					; size = 4
_decalExtents$ = -40					; size = 24
_pDecal$ = -16						; size = 4
_plast$ = -12						; size = 4
_texture$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_decalinfo$ = 8						; size = 4
_surf$ = 12						; size = 4
_pcount$ = 16						; size = 4
_R_DecalIntersect PROC					; COMDAT

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 427  : 	int		texture;
; 428  : 	decal_t		*plast, *pDecal;
; 429  : 	vec3_t		decalExtents[2];
; 430  : 	float		lastArea = 2;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _lastArea$[ebp], xmm0

; 431  : 	int		mapSize[2];
; 432  : 
; 433  : 	plast = NULL;

	mov	DWORD PTR _plast$[ebp], 0

; 434  : 	*pcount = 0;

	mov	eax, DWORD PTR _pcount$[ebp]
	mov	DWORD PTR [eax], 0

; 435  : 
; 436  : 	// (Same as R_SetupDecalClip).
; 437  : 	texture = decalinfo->m_iTexture;

	mov	eax, DWORD PTR _decalinfo$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _texture$[ebp], ecx

; 438  : 	
; 439  : 	// precalculate the extents of decalinfo's decal in world space.
; 440  : 	R_GetDecalDimensions( texture, &mapSize[0], &mapSize[1] );

	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _mapSize$[ebp+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _mapSize$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	call	_R_GetDecalDimensions
	add	esp, 12					; 0000000cH

; 441  : 	VectorScale( decalinfo->m_Basis[0], ((mapSize[0] / decalinfo->m_scale) * 0.5f), decalExtents[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	lea	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+ecx]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _decalExtents$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	eax, eax, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+eax]
	mov	eax, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _decalExtents$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	ecx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+ecx]
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv160[ebp], xmm1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _decalExtents$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 442  : 	VectorScale( decalinfo->m_Basis[1], ((mapSize[1] / decalinfo->m_scale) * 0.5f), decalExtents[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _decalinfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	shl	eax, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+eax]
	mov	eax, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _decalinfo$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+eax]
	mov	eax, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _decalinfo$[ebp]
	lea	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _mapSize$[ebp+edx]
	mov	edx, DWORD PTR _decalinfo$[ebp]
	divss	xmm0, DWORD PTR [edx+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv217[ebp], xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _decalExtents$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv217[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 443  : 
; 444  : 	pDecal = surf->pdecals;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _pDecal$[ebp], ecx
$LN2@R_DecalInt:

; 445  : 
; 446  : 	while( pDecal ) 

	cmp	DWORD PTR _pDecal$[ebp], 0
	je	$LN3@R_DecalInt

; 447  : 	{
; 448  : 		texture = pDecal->texture;

	mov	eax, DWORD PTR _pDecal$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	mov	DWORD PTR _texture$[ebp], ecx

; 449  : 
; 450  : 		// Don't steal bigger decals and replace them with smaller decals
; 451  : 		// Don't steal permanent decals
; 452  : 		if( !FBitSet( pDecal->flags, FDECAL_PERMANENT ))

	mov	eax, DWORD PTR _pDecal$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	and	ecx, 1
	jne	$LN7@R_DecalInt

; 453  : 		{
; 454  : 			vec3_t	testBasis[3];
; 455  : 			vec3_t	testPosition[2];
; 456  : 			float	testWorldScale[2];
; 457  : 			vec2_t	vDecalMin, vDecalMax;
; 458  : 			vec2_t	vUnionMin, vUnionMax;
; 459  : 
; 460  : 			R_SetupDecalTextureSpaceBasis( pDecal, surf, texture, testBasis, testWorldScale );

	lea	eax, DWORD PTR _testWorldScale$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _testBasis$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	call	_R_SetupDecalTextureSpaceBasis
	add	esp, 20					; 00000014H

; 461  : 
; 462  : 			VectorSubtract( decalinfo->m_Position, decalExtents[0], testPosition[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	ecx, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR tv266[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv266[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 463  : 			VectorSubtract( decalinfo->m_Position, decalExtents[1], testPosition[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv302[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv302[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 464  : 
; 465  : 			// Here, we project the min and max extents of the decal that got passed in into
; 466  : 			// this decal's (pDecal's) [0,0,1,1] clip space, just like we would if we were
; 467  : 			// clipping a triangle into pDecal's clip space.
; 468  : 			Vector2Set( vDecalMin,

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 0
	lea	eax, DWORD PTR _testBasis$8[ebp+eax]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, edx, 0
	lea	edx, DWORD PTR _testBasis$8[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	lea	ecx, DWORD PTR _testBasis$8[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vDecalMin$5[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	ecx, DWORD PTR _testBasis$8[ebp+ecx]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	edx, DWORD PTR _testBasis$8[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	eax, DWORD PTR _testBasis$8[ebp+eax]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv374[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv374[ebp]
	movss	DWORD PTR _vDecalMin$5[ebp+edx], xmm0

; 469  : 				DotProduct( testPosition[0], testBasis[0] ) - pDecal->dx + 0.5f,
; 470  : 				DotProduct( testPosition[1], testBasis[1] ) - pDecal->dy + 0.5f );
; 471  : 
; 472  : 			VectorAdd( decalinfo->m_Position, decalExtents[0], testPosition[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	ecx, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR tv410[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv410[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 473  : 			VectorAdd( decalinfo->m_Position, decalExtents[1], testPosition[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _decalExtents$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _decalExtents$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _decalinfo$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv446[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv446[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 474  : 
; 475  : 			Vector2Set( vDecalMax,

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 0
	lea	eax, DWORD PTR _testBasis$8[ebp+eax]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, edx, 0
	lea	edx, DWORD PTR _testBasis$8[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _testPosition$7[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	lea	ecx, DWORD PTR _testBasis$8[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vDecalMax$4[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	ecx, DWORD PTR _testBasis$8[ebp+ecx]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _testPosition$7[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	edx, DWORD PTR _testBasis$8[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _testPosition$7[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	eax, DWORD PTR _testBasis$8[ebp+eax]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv518[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv518[ebp]
	movss	DWORD PTR _vDecalMax$4[ebp+edx], xmm0

; 476  : 				DotProduct( testPosition[0], testBasis[0] ) - pDecal->dx + 0.5f,
; 477  : 				DotProduct( testPosition[1], testBasis[1] ) - pDecal->dy + 0.5f );	
; 478  : 
; 479  : 			// Now figure out the part of the projection that intersects pDecal's
; 480  : 			// clip box [0,0,1,1].
; 481  : 			Vector2Set( vUnionMin, max( vDecalMin[0], 0 ), max( vDecalMin[1], 0 ));

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vDecalMin$5[ebp+ecx]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@R_DecalInt
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vDecalMin$5[ebp+eax]
	movss	DWORD PTR tv528[ebp], xmm0
	jmp	SHORT $LN11@R_DecalInt
$LN10@R_DecalInt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv528[ebp], xmm0
$LN11@R_DecalInt:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv528[ebp]
	movss	DWORD PTR _vUnionMin$3[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vDecalMin$5[ebp+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN12@R_DecalInt
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vDecalMin$5[ebp+ecx]
	movss	DWORD PTR tv538[ebp], xmm0
	jmp	SHORT $LN13@R_DecalInt
$LN12@R_DecalInt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv538[ebp], xmm0
$LN13@R_DecalInt:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv538[ebp]
	movss	DWORD PTR _vUnionMin$3[ebp+edx], xmm0

; 482  : 			Vector2Set( vUnionMax, min( vDecalMax[0], 1 ), min( vDecalMax[1], 1 ));

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _vDecalMax$4[ebp+ecx]
	jbe	SHORT $LN14@R_DecalInt
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vDecalMax$4[ebp+eax]
	movss	DWORD PTR tv548[ebp], xmm0
	jmp	SHORT $LN15@R_DecalInt
$LN14@R_DecalInt:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv548[ebp], xmm0
$LN15@R_DecalInt:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv548[ebp]
	movss	DWORD PTR _vUnionMax$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _vDecalMax$4[ebp+eax]
	jbe	SHORT $LN16@R_DecalInt
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vDecalMax$4[ebp+ecx]
	movss	DWORD PTR tv558[ebp], xmm0
	jmp	SHORT $LN17@R_DecalInt
$LN16@R_DecalInt:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv558[ebp], xmm0
$LN17@R_DecalInt:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv558[ebp]
	movss	DWORD PTR _vUnionMax$2[ebp+edx], xmm0

; 483  : 
; 484  : 			if( vUnionMin[0] < 1 && vUnionMin[1] < 1 && vUnionMax[0] > 0 && vUnionMax[1] > 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _vUnionMin$3[ebp+ecx]
	jbe	$LN7@R_DecalInt
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _vUnionMin$3[ebp+eax]
	jbe	$LN7@R_DecalInt
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vUnionMax$2[ebp+ecx]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN7@R_DecalInt
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vUnionMax$2[ebp+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN7@R_DecalInt

; 485  : 			{
; 486  : 				// Figure out how much of this intersects the (0,0) - (1,1) bbox.			
; 487  : 				float	flArea = (vUnionMax[0] - vUnionMin[1]) * (vUnionMax[1] - vUnionMin[1]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _vUnionMax$2[ebp+ecx]
	subss	xmm0, DWORD PTR _vUnionMin$3[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _vUnionMax$2[ebp+eax]
	subss	xmm1, DWORD PTR _vUnionMin$3[ebp+ecx]
	mulss	xmm0, xmm1
	movss	DWORD PTR _flArea$1[ebp], xmm0

; 488  : 
; 489  : 				if( flArea > 0.6f )

	movss	xmm0, DWORD PTR _flArea$1[ebp]
	comiss	xmm0, DWORD PTR __real@3f19999a
	jbe	SHORT $LN7@R_DecalInt

; 490  : 				{
; 491  : 					*pcount += 1;

	mov	eax, DWORD PTR _pcount$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pcount$[ebp]
	mov	DWORD PTR [edx], ecx

; 492  : 
; 493  : 					if( !plast || flArea <= lastArea ) 

	cmp	DWORD PTR _plast$[ebp], 0
	je	SHORT $LN8@R_DecalInt
	movss	xmm0, DWORD PTR _lastArea$[ebp]
	comiss	xmm0, DWORD PTR _flArea$1[ebp]
	jb	SHORT $LN7@R_DecalInt
$LN8@R_DecalInt:

; 494  : 					{
; 495  : 						plast = pDecal;

	mov	eax, DWORD PTR _pDecal$[ebp]
	mov	DWORD PTR _plast$[ebp], eax

; 496  : 						lastArea =  flArea;

	movss	xmm0, DWORD PTR _flArea$1[ebp]
	movss	DWORD PTR _lastArea$[ebp], xmm0
$LN7@R_DecalInt:

; 497  : 					}
; 498  : 				}
; 499  : 			}
; 500  : 		}
; 501  : 		pDecal = pDecal->pnext;

	mov	eax, DWORD PTR _pDecal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDecal$[ebp], ecx

; 502  : 	}

	jmp	$LN2@R_DecalInt
$LN3@R_DecalInt:

; 503  : 	return plast;

	mov	eax, DWORD PTR _plast$[ebp]

; 504  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalVertsLight
_TEXT	SEGMENT
_j$ = -24						; size = 4
_sample_size$ = -20					; size = 4
_info$ = -16						; size = 4
_tex$ = -12						; size = 4
_t$ = -8						; size = 4
_s$ = -4						; size = 4
_v$ = 8							; size = 4
_surf$ = 12						; size = 4
_vertCount$ = 16					; size = 4
_R_DecalVertsLight PROC					; COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 397  : 	float		s, t;
; 398  : 	mtexinfo_t	*tex;
; 399  : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 400  : 	float		sample_size;
; 401  : 	int		j;
; 402  : 
; 403  : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sample_size$[ebp], xmm0

; 404  : 	tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 405  : 
; 406  : 	for( j = 0; j < vertCount; j++, v += VERTEXSIZE )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@R_DecalVer
$LN2@R_DecalVer:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN4@R_DecalVer:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vertCount$[ebp]
	jge	$LN3@R_DecalVer

; 407  : 	{
; 408  : 		// lightmap texture coordinates
; 409  : 		s = DotProduct( v, info->lmvecs[0] ) + info->lmvecs[0][3] - info->lightmapmins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+edx+48]
	cvtsi2ss xmm1, ecx
	subss	xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 410  : 		s += surf->light_s * sample_size;

	mov	eax, DWORD PTR _surf$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 411  : 		s += sample_size * 0.5;

	cvtss2sd xmm0, DWORD PTR _sample_size$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, DWORD PTR _s$[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 412  : 		s /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->width;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 413  : 
; 414  : 		t = DotProduct( v, info->lmvecs[1] ) + info->lmvecs[1][3] - info->lightmapmins[1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 415  : 		t += surf->light_t * sample_size;

	mov	eax, DWORD PTR _surf$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _t$[ebp], xmm0

; 416  : 		t += sample_size * 0.5;

	cvtss2sd xmm0, DWORD PTR _sample_size$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, DWORD PTR _t$[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 417  : 		t /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->height;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 418  : 
; 419  : 		v[5] = s;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 420  : 		v[6] = t;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 421  : 	}

	jmp	$LN2@R_DecalVer
$LN3@R_DecalVer:

; 422  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalVertsLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalVertsClip
_TEXT	SEGMENT
_textureSpaceBasis$ = -48				; size = 36
_decalWorldScale$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_pDecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_texture$ = 16						; size = 4
_pVertCount$ = 20					; size = 4
_R_DecalVertsClip PROC					; COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 382  : 	float	decalWorldScale[2];
; 383  : 	vec3_t	textureSpaceBasis[3]; 
; 384  : 
; 385  : 	// figure out where the decal maps onto the surface.
; 386  : 	R_SetupDecalClip( pDecal, surf, texture, textureSpaceBasis, decalWorldScale );

	lea	eax, DWORD PTR _decalWorldScale$[ebp]
	push	eax
	lea	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	call	_R_SetupDecalClip
	add	esp, 20					; 00000014H

; 387  : 
; 388  : 	// build the initial list of vertices from the surface verts.
; 389  : 	R_SetupDecalVertsForMSurface( pDecal, surf, textureSpaceBasis, g_DecalClipVerts[0] );

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	push	ecx
	lea	edx, DWORD PTR _textureSpaceBasis$[ebp]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	call	_R_SetupDecalVertsForMSurface
	add	esp, 16					; 00000010H

; 390  : 
; 391  : 	return R_DoDecalSHClip( g_DecalClipVerts[0], pDecal, surf->polys->numverts, pVertCount );

	mov	eax, DWORD PTR _pVertCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	mov	edx, 28					; 0000001cH
	imul	eax, edx, 0
	add	eax, OFFSET _g_DecalClipVerts
	push	eax
	call	_R_DoDecalSHClip
	add	esp, 16					; 00000010H

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalVertsClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DoDecalSHClip
_TEXT	SEGMENT
_outCount$ = -8						; size = 4
_pOutVerts$ = -4					; size = 4
_pInVerts$ = 8						; size = 4
_pDecal$ = 12						; size = 4
_nStartVerts$ = 16					; size = 4
_pVertCount$ = 20					; size = 4
_R_DoDecalSHClip PROC					; COMDAT

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 362  : 	float	*pOutVerts = g_DecalClipVerts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	mov	DWORD PTR _pOutVerts$[ebp], ecx

; 363  : 	int	outCount;
; 364  : 
; 365  : 	// clip the polygon to the decal texture space
; 366  : 	outCount = SHClip( pInVerts, nStartVerts, g_DecalClipVerts2[0], LEFT_EDGE );

	push	0
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts2
	push	ecx
	mov	edx, DWORD PTR _nStartVerts$[ebp]
	push	edx
	mov	eax, DWORD PTR _pInVerts$[ebp]
	push	eax
	call	_SHClip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outCount$[ebp], eax

; 367  : 	outCount = SHClip( g_DecalClipVerts2[0], outCount, g_DecalClipVerts[0], RIGHT_EDGE );

	push	1
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	push	ecx
	mov	edx, DWORD PTR _outCount$[ebp]
	push	edx
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts2
	push	ecx
	call	_SHClip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outCount$[ebp], eax

; 368  : 	outCount = SHClip( g_DecalClipVerts[0], outCount, g_DecalClipVerts2[0], TOP_EDGE );

	push	2
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts2
	push	ecx
	mov	edx, DWORD PTR _outCount$[ebp]
	push	edx
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	push	ecx
	call	_SHClip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outCount$[ebp], eax

; 369  : 	outCount = SHClip( g_DecalClipVerts2[0], outCount, pOutVerts, BOTTOM_EDGE );

	push	3
	mov	eax, DWORD PTR _pOutVerts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outCount$[ebp]
	push	ecx
	mov	edx, 28					; 0000001cH
	imul	eax, edx, 0
	add	eax, OFFSET _g_DecalClipVerts2
	push	eax
	call	_SHClip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outCount$[ebp], eax

; 370  : 
; 371  : 	if( pVertCount )

	cmp	DWORD PTR _pVertCount$[ebp], 0
	je	SHORT $LN2@R_DoDecalS

; 372  : 		*pVertCount = outCount;

	mov	eax, DWORD PTR _pVertCount$[ebp]
	mov	ecx, DWORD PTR _outCount$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@R_DoDecalS:

; 373  : 
; 374  : 	return pOutVerts;

	mov	eax, DWORD PTR _pOutVerts$[ebp]

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DoDecalSHClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _SHClip
_TEXT	SEGMENT
_p$ = -16						; size = 4
_s$ = -12						; size = 4
_outCount$ = -8						; size = 4
_j$ = -4						; size = 4
_vert$ = 8						; size = 4
_vertCount$ = 12					; size = 4
_out$ = 16						; size = 4
_edge$ = 20						; size = 4
_SHClip	PROC						; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 313  : 	int	j, outCount;
; 314  : 	float	*s, *p;
; 315  : 
; 316  : 	outCount = 0;

	mov	DWORD PTR _outCount$[ebp], 0

; 317  : 
; 318  : 	s = &vert[(vertCount - 1) * VERTEXSIZE];

	mov	eax, DWORD PTR _vertCount$[ebp]
	sub	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _vert$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _s$[ebp], eax

; 319  : 
; 320  : 	for( j = 0; j < vertCount; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@SHClip
$LN2@SHClip:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@SHClip:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vertCount$[ebp]
	jge	$LN3@SHClip

; 321  : 	{
; 322  : 		p = &vert[j * VERTEXSIZE];

	imul	eax, DWORD PTR _j$[ebp], 7
	mov	ecx, DWORD PTR _vert$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _p$[ebp], edx

; 323  : 
; 324  : 		if( R_ClipInside( p, edge ))

	mov	eax, DWORD PTR _edge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_R_ClipInside
	add	esp, 8
	test	eax, eax
	je	$LN5@SHClip

; 325  : 		{
; 326  : 			if( R_ClipInside( s, edge ))

	mov	eax, DWORD PTR _edge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_R_ClipInside
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@SHClip

; 327  : 			{
; 328  : 				// Add a vertex and advance out to next vertex
; 329  : 				memcpy( out, p, sizeof( float ) * VERTEXSIZE );

	push	28					; 0000001cH
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 330  : 				out += VERTEXSIZE;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 331  : 				outCount++;

	mov	eax, DWORD PTR _outCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outCount$[ebp], eax

; 332  : 			}

	jmp	SHORT $LN8@SHClip
$LN7@SHClip:

; 333  : 			else
; 334  : 			{
; 335  : 				R_ClipIntersect( s, p, out, edge );

	mov	eax, DWORD PTR _edge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_R_ClipIntersect
	add	esp, 16					; 00000010H

; 336  : 				out += VERTEXSIZE;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 337  : 				outCount++;

	mov	eax, DWORD PTR _outCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outCount$[ebp], eax

; 338  : 
; 339  : 				memcpy( out, p, sizeof( float ) * VERTEXSIZE );

	push	28					; 0000001cH
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 340  : 				out += VERTEXSIZE;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 341  : 				outCount++;

	mov	eax, DWORD PTR _outCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outCount$[ebp], eax
$LN8@SHClip:

; 342  : 			}
; 343  : 		}

	jmp	SHORT $LN6@SHClip
$LN5@SHClip:

; 344  : 		else
; 345  : 		{
; 346  : 			if( R_ClipInside( s, edge ))

	mov	eax, DWORD PTR _edge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_R_ClipInside
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@SHClip

; 347  : 			{
; 348  : 				R_ClipIntersect( p, s, out, edge );

	mov	eax, DWORD PTR _edge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_R_ClipIntersect
	add	esp, 16					; 00000010H

; 349  : 				out += VERTEXSIZE;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 350  : 				outCount++;

	mov	eax, DWORD PTR _outCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outCount$[ebp], eax
$LN6@SHClip:

; 351  : 			}
; 352  : 		}
; 353  : 
; 354  : 		s = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 355  : 	}

	jmp	$LN2@SHClip
$LN3@SHClip:

; 356  : 
; 357  : 	return outCount;

	mov	eax, DWORD PTR _outCount$[ebp]

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SHClip	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_ClipIntersect
_TEXT	SEGMENT
tv246 = -72						; size = 4
_t$ = -4						; size = 4
_one$ = 8						; size = 4
_two$ = 12						; size = 4
_out$ = 16						; size = 4
_edge$ = 20						; size = 4
_R_ClipIntersect PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 261  : 	float	t;
; 262  : 
; 263  : 	// t is the parameter of the line between one and two clipped to the edge
; 264  : 	// or the fraction of the clipped point between one & two
; 265  : 	// vert[0], vert[1], vert[2] is X, Y, Z
; 266  : 	// vert[3] is u
; 267  : 	// vert[4] is v
; 268  : 	// vert[5] is lightmap u
; 269  : 	// vert[6] is lightmap v
; 270  : 
; 271  : 	if( edge < TOP_EDGE )

	cmp	DWORD PTR _edge$[ebp], 2
	jge	$LN2@R_ClipInte

; 272  : 	{
; 273  : 		if( edge == LEFT_EDGE )

	cmp	DWORD PTR _edge$[ebp], 0
	jne	SHORT $LN4@R_ClipInte

; 274  : 		{
; 275  : 			// left
; 276  : 			t = ((one[3] - 0.0f) / (one[3] - two[3]));

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR __real@00000000
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _one$[ebp]
	mov	esi, DWORD PTR _two$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm1, DWORD PTR [esi+eax]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 277  : 			out[3] = out[5] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 278  : 		}

	jmp	SHORT $LN5@R_ClipInte
$LN4@R_ClipInte:

; 279  : 		else
; 280  : 		{	
; 281  : 			// right
; 282  : 			t = ((one[3] - 1.0f) / (one[3] - two[3]));

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _one$[ebp]
	mov	esi, DWORD PTR _two$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm1, DWORD PTR [esi+eax]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 283  : 			out[3] = out[5] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0
$LN5@R_ClipInte:

; 284  : 		}
; 285  : 
; 286  : 		out[4] = one[4] + (two[4] - one[4]) * t;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, 4
	shl	edx, 2
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 287  : 		out[6] = one[6] + (two[6] - one[6]) * t;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, 4
	imul	eax, edx, 6
	mov	edx, 4
	imul	edx, edx, 6
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 288  : 	}

	jmp	$LN3@R_ClipInte
$LN2@R_ClipInte:

; 289  : 	else
; 290  : 	{
; 291  : 		if( edge == TOP_EDGE )

	cmp	DWORD PTR _edge$[ebp], 2
	jne	SHORT $LN6@R_ClipInte

; 292  : 		{
; 293  : 			// top
; 294  : 			t = ((one[4] - 0.0f)  / (one[4] - two[4]));

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR __real@00000000
	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _one$[ebp]
	mov	esi, DWORD PTR _two$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	subss	xmm1, DWORD PTR [esi+eax]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 295  : 			out[4] = out[6] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 296  : 		}

	jmp	SHORT $LN7@R_ClipInte
$LN6@R_ClipInte:

; 297  : 		else
; 298  : 		{	
; 299  : 			// bottom
; 300  : 			t = ((one[4] - 1.0f) / (one[4] - two[4]));

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _one$[ebp]
	mov	esi, DWORD PTR _two$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	subss	xmm1, DWORD PTR [esi+eax]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 301  : 			out[4] = out[6] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0
$LN7@R_ClipInte:

; 302  : 		}
; 303  : 
; 304  : 		out[3] = one[3] + (two[3] - one[3]) * t;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 4
	imul	edx, edx, 3
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 305  : 		out[5] = one[5] + (two[4] - one[5]) * t;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, eax, 5
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN3@R_ClipInte:

; 306  : 	}
; 307  : 
; 308  : 	VectorLerp( one, t, two, out );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _one$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _two$[ebp]
	mov	edi, DWORD PTR _one$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _one$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv246[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 309  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ClipIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_ClipInside
_TEXT	SEGMENT
tv64 = -68						; size = 4
_vert$ = 8						; size = 4
_edge$ = 12						; size = 4
_R_ClipInside PROC					; COMDAT

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 237  : 	switch( edge )

	mov	eax, DWORD PTR _edge$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	ja	$LN2@R_ClipInsi
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN13@R_ClipInsi[ecx*4]
$LN4@R_ClipInsi:

; 238  : 	{
; 239  : 	case LEFT_EDGE:
; 240  : 		if( vert[3] > 0.0f )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@R_ClipInsi

; 241  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_ClipInsi
$LN5@R_ClipInsi:

; 242  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@R_ClipInsi
$LN6@R_ClipInsi:

; 243  : 	case RIGHT_EDGE:
; 244  : 		if( vert[3] < 1.0f )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+ecx]
	jbe	SHORT $LN7@R_ClipInsi

; 245  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_ClipInsi
$LN7@R_ClipInsi:

; 246  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@R_ClipInsi
$LN8@R_ClipInsi:

; 247  : 	case TOP_EDGE:
; 248  : 		if( vert[4] > 0.0f )

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@R_ClipInsi

; 249  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_ClipInsi
$LN9@R_ClipInsi:

; 250  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@R_ClipInsi
$LN10@R_ClipInsi:

; 251  : 	case BOTTOM_EDGE:
; 252  : 		if( vert[4] < 1.0f )

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+eax]
	jbe	SHORT $LN11@R_ClipInsi

; 253  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_ClipInsi
$LN11@R_ClipInsi:

; 254  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@R_ClipInsi
$LN2@R_ClipInsi:

; 255  : 	}
; 256  : 	return 0;

	xor	eax, eax
$LN1@R_ClipInsi:

; 257  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@R_ClipInsi:
	DD	$LN4@R_ClipInsi
	DD	$LN6@R_ClipInsi
	DD	$LN8@R_ClipInsi
	DD	$LN10@R_ClipInsi
_R_ClipInside ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_SetupDecalClip
_TEXT	SEGMENT
_pDecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_texture$ = 16						; size = 4
_textureSpaceBasis$ = 20				; size = 4
_decalWorldScale$ = 24					; size = 4
_R_SetupDecalClip PROC					; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 222  : 	R_SetupDecalTextureSpaceBasis( pDecal, surf, texture, textureSpaceBasis, decalWorldScale );

	mov	eax, DWORD PTR _decalWorldScale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	call	_R_SetupDecalTextureSpaceBasis
	add	esp, 20					; 00000014H

; 223  : 
; 224  : 	// Generate texture coordinates for each vertex in decal s,t space
; 225  : 	// probably should pre-generate this, store it and use it for decal-decal collisions
; 226  : 	// as in R_DecalsIntersect()
; 227  : 	pDecal->dx = DotProduct( pDecal->position, textureSpaceBasis[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+28]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [esi+eax+28]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [esi+edx+28]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 228  : 	pDecal->dy = DotProduct( pDecal->position, textureSpaceBasis[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+28]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+28]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+28]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupDecalClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_SetupDecalVertsForMSurface
_TEXT	SEGMENT
_i$ = -8						; size = 4
_v$ = -4						; size = 4
_pDecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_textureSpaceBasis$ = 16				; size = 4
_verts$ = 20						; size = 4
_R_SetupDecalVertsForMSurface PROC			; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 207  : 	float	*v;
; 208  : 	int	i;
; 209  : 
; 210  : 	for( i = 0, v = surf->polys->verts[0]; i < surf->polys->numverts; i++, v += VERTEXSIZE, verts += VERTEXSIZE )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 28					; 0000001cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _v$[ebp], ecx
	jmp	SHORT $LN4@R_SetupDec
$LN2@R_SetupDec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _verts$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp], edx
$LN4@R_SetupDec:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN3@R_SetupDec

; 211  : 	{
; 212  : 		VectorCopy( v, verts ); // copy model space coordinates

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 213  : 		verts[3] = DotProduct( verts, textureSpaceBasis[0] ) - pDecal->dx + 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _verts$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 214  : 		verts[4] = DotProduct( verts, textureSpaceBasis[1] ) - pDecal->dy + 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pDecal$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _verts$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 215  : 		verts[5] = verts[6] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _verts$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _verts$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 216  : 	}

	jmp	$LN2@R_SetupDec
$LN3@R_SetupDec:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupDecalVertsForMSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_SetupDecalTextureSpaceBasis
_TEXT	SEGMENT
tv185 = -76						; size = 4
tv149 = -76						; size = 4
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_pDecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_texture$ = 16						; size = 4
_textureSpaceBasis$ = 20				; size = 4
_decalWorldScale$ = 24					; size = 4
_R_SetupDecalTextureSpaceBasis PROC			; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 187  : 	int	width, height;
; 188  : 
; 189  : 	// Compute the non-scaled decal basis
; 190  : 	R_DecalComputeBasis( surf, pDecal->flags, textureSpaceBasis );

	mov	eax, DWORD PTR _textureSpaceBasis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	push	edx
	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_R_DecalComputeBasis
	add	esp, 12					; 0000000cH

; 191  : 	R_GetDecalDimensions( texture, &width, &height );

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	call	_R_GetDecalDimensions
	add	esp, 12					; 0000000cH

; 192  : 
; 193  : 	// world width of decal = ptexture->width / pDecal->scale
; 194  : 	// world height of decal = ptexture->height / pDecal->scale
; 195  : 	// scale is inverse, scales world space to decal u/v space [0,1]
; 196  : 	// OPTIMIZE: Get rid of these divides
; 197  : 	decalWorldScale[0] = (float)pDecal->scale / width;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [eax+16]
	divss	xmm1, xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _decalWorldScale$[ebp]
	movss	DWORD PTR [eax+edx], xmm1

; 198  : 	decalWorldScale[1] = (float)pDecal->scale / height;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mov	eax, DWORD PTR _pDecal$[ebp]
	movss	xmm1, DWORD PTR [eax+16]
	divss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _decalWorldScale$[ebp]
	movss	DWORD PTR [edx+ecx], xmm1

; 199  : 	
; 200  : 	VectorScale( textureSpaceBasis[0], decalWorldScale[0], textureSpaceBasis[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [esi+edx]
	movss	DWORD PTR tv149[ebp], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 201  : 	VectorScale( textureSpaceBasis[1], decalWorldScale[1], textureSpaceBasis[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _decalWorldScale$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv185[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupDecalTextureSpaceBasis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalComputeBasis
_TEXT	SEGMENT
tv87 = -96						; size = 4
_ilength$1 = -28					; size = 4
_ilength$2 = -24					; size = 4
_ilength$3 = -20					; size = 4
_surfaceNormal$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_surf$ = 8						; size = 4
_flags$ = 12						; size = 4
_textureSpaceBasis$ = 16				; size = 4
_R_DecalComputeBasis PROC				; COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 151  : 	vec3_t	surfaceNormal;
; 152  : 
; 153  : 	// setup normal
; 154  : 	if( surf->flags & SURF_PLANEBACK )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	$LN2@R_DecalCom

; 155  : 		VectorNegate( surf->plane->normal, surfaceNormal );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _surfaceNormal$[ebp+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _surfaceNormal$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv87[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR _surfaceNormal$[ebp+ecx], xmm0
	jmp	SHORT $LN3@R_DecalCom
$LN2@R_DecalCom:

; 156  : 	else VectorCopy( surf->plane->normal, surfaceNormal );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _surfaceNormal$[ebp+edx], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _surfaceNormal$[ebp+ecx], edx
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _surfaceNormal$[ebp+eax], ecx
$LN3@R_DecalCom:

; 157  : 
; 158  : 	VectorNormalize2( surfaceNormal, textureSpaceBasis[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _surfaceNormal$[ebp+ecx]
	mulss	xmm0, DWORD PTR _surfaceNormal$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _surfaceNormal$[ebp+ecx]
	mulss	xmm1, DWORD PTR _surfaceNormal$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _surfaceNormal$[ebp+eax]
	mulss	xmm1, DWORD PTR _surfaceNormal$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@R_DecalCom
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN4@R_DecalCom:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _surfaceNormal$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _surfaceNormal$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _surfaceNormal$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 159  : #if 0
; 160  : 	if( FBitSet( flags, FDECAL_CUSTOM ))
; 161  : 	{
; 162  : 		vec3_t	pSAxis = { 1, 0, 0 };
; 163  : 
; 164  : 		// T = S cross N
; 165  : 		CrossProduct( pSAxis, textureSpaceBasis[2], textureSpaceBasis[1] );
; 166  : 
; 167  : 		// Name sure they aren't parallel or antiparallel
; 168  : 		// In that case, fall back to the normal algorithm.
; 169  : 		if( DotProduct( textureSpaceBasis[1], textureSpaceBasis[1] ) > 1e-6 )
; 170  : 		{
; 171  : 			// S = N cross T
; 172  : 			CrossProduct( textureSpaceBasis[2], textureSpaceBasis[1], textureSpaceBasis[0] );
; 173  : 
; 174  : 			VectorNormalizeFast( textureSpaceBasis[0] );
; 175  : 			VectorNormalizeFast( textureSpaceBasis[1] );
; 176  : 			return;
; 177  : 		}
; 178  : 		// Fall through to the standard algorithm for parallel or antiparallel
; 179  : 	}
; 180  : #endif
; 181  : 	VectorNormalize2( surf->texinfo->vecs[0], textureSpaceBasis[0] );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [edx+44]
	mov	esi, 16					; 00000010H
	imul	esi, esi, 0
	add	edx, esi
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esi, 16					; 00000010H
	imul	esi, esi, 0
	add	eax, esi
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	esi, 16					; 00000010H
	imul	esi, esi, 0
	add	ecx, esi
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_DecalCom
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN5@R_DecalCom:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	add	edx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 182  : 	VectorNormalize2( surf->texinfo->vecs[1], textureSpaceBasis[1] );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	ecx, edx
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esi, 16					; 00000010H
	shl	esi, 0
	add	eax, esi
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esi, 16					; 00000010H
	shl	esi, 0
	add	eax, esi
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esi, 16					; 00000010H
	shl	esi, 0
	add	eax, esi
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_DecalCom
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN6@R_DecalCom:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	ecx, edx
	mov	eax, 4
	imul	edx, eax, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _textureSpaceBasis$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	ecx, edx
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	ecx, edx
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _textureSpaceBasis$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalComputeBasis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_GetDecalDimensions
_TEXT	SEGMENT
_texture$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_R_GetDecalDimensions PROC				; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 140  : 	if( width ) *width = 1;	// to avoid divide by zero

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN2@R_GetDecal
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax], 1
$LN2@R_GetDecal:

; 141  : 	if( height ) *height = 1;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN3@R_GetDecal
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax], 1
$LN3@R_GetDecal:

; 142  : 
; 143  : 	R_GetTextureParms( width, height, texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetDecalDimensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalAlloc
_TEXT	SEGMENT
_count$1 = -8						; size = 4
_limit$ = -4						; size = 4
_pdecal$ = 8						; size = 4
_R_DecalAlloc PROC					; COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 106  : 	int	limit = MAX_RENDER_DECALS;

	mov	DWORD PTR _limit$[ebp], 4096		; 00001000H

; 107  : 
; 108  : 	if( r_decals->value < limit )

	cvtsi2ss xmm0, DWORD PTR _limit$[ebp]
	mov	eax, DWORD PTR _r_decals
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN5@R_DecalAll

; 109  : 		limit = r_decals->value;

	mov	eax, DWORD PTR _r_decals
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _limit$[ebp], ecx
$LN5@R_DecalAll:

; 110  : 	
; 111  : 	if( !limit ) return NULL;

	cmp	DWORD PTR _limit$[ebp], 0
	jne	SHORT $LN6@R_DecalAll
	xor	eax, eax
	jmp	SHORT $LN1@R_DecalAll
$LN6@R_DecalAll:

; 112  : 
; 113  : 	if( !pdecal ) 

	cmp	DWORD PTR _pdecal$[ebp], 0
	jne	SHORT $LN9@R_DecalAll

; 114  : 	{
; 115  : 		int	count = 0;

	mov	DWORD PTR _count$1[ebp], 0
$LN4@R_DecalAll:

; 116  : 
; 117  : 		// check for the odd possiblity of infinte loop
; 118  : 		do 
; 119  : 		{
; 120  : 			if( gDecalCount >= limit )

	mov	eax, DWORD PTR _gDecalCount
	cmp	eax, DWORD PTR _limit$[ebp]
	jl	SHORT $LN8@R_DecalAll

; 121  : 				gDecalCount = 0;

	mov	DWORD PTR _gDecalCount, 0
$LN8@R_DecalAll:

; 122  : 
; 123  : 			pdecal = &gDecalPool[gDecalCount]; // reuse next decal

	imul	eax, DWORD PTR _gDecalCount, 60
	add	eax, OFFSET _gDecalPool
	mov	DWORD PTR _pdecal$[ebp], eax

; 124  : 			gDecalCount++;

	mov	eax, DWORD PTR _gDecalCount
	add	eax, 1
	mov	DWORD PTR _gDecalCount, eax

; 125  : 			count++;

	mov	eax, DWORD PTR _count$1[ebp]
	add	eax, 1
	mov	DWORD PTR _count$1[ebp], eax

; 126  : 		} while( FBitSet( pdecal->flags, FDECAL_PERMANENT ) && count < limit );

	mov	eax, DWORD PTR _pdecal$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	and	ecx, 1
	je	SHORT $LN9@R_DecalAll
	mov	eax, DWORD PTR _count$1[ebp]
	cmp	eax, DWORD PTR _limit$[ebp]
	jl	SHORT $LN4@R_DecalAll
$LN9@R_DecalAll:

; 127  : 	}
; 128  : 	
; 129  : 	// if decal is already linked to a surface, unlink it.
; 130  : 	R_DecalUnlink( pdecal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	push	eax
	call	_R_DecalUnlink
	add	esp, 4

; 131  : 
; 132  : 	return pdecal;	

	mov	eax, DWORD PTR _pdecal$[ebp]
$LN1@R_DecalAll:

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalUnlink
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_pdecal$ = 8						; size = 4
_R_DecalUnlink PROC					; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 69   : 	decal_t	*tmp;
; 70   : 
; 71   : 	if( pdecal->psurface )

	mov	eax, DWORD PTR _pdecal$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@R_DecalUnl

; 72   : 	{
; 73   : 		if( pdecal->psurface->pdecals == pdecal )

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+88]
	cmp	edx, DWORD PTR _pdecal$[ebp]
	jne	SHORT $LN5@R_DecalUnl

; 74   : 		{
; 75   : 			pdecal->psurface->pdecals = pdecal->pnext;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pdecal$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+88], eax

; 76   : 		}

	jmp	SHORT $LN4@R_DecalUnl
$LN5@R_DecalUnl:

; 77   : 		else 
; 78   : 		{
; 79   : 			tmp = pdecal->psurface->pdecals;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR _tmp$[ebp], edx

; 80   : 			if( !tmp ) Host_Error( "D_DecalUnlink: bad decal list\n" );

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN2@R_DecalUnl
	push	OFFSET ??_C@_0BP@BBPGPHGC@D_DecalUnlink?3?5bad?5decal?5list?6@
	call	_Host_Error
	add	esp, 4
$LN2@R_DecalUnl:

; 81   : 
; 82   : 			while( tmp->pnext ) 

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@R_DecalUnl

; 83   : 			{
; 84   : 				if( tmp->pnext == pdecal ) 

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pdecal$[ebp]
	jne	SHORT $LN8@R_DecalUnl

; 85   : 				{
; 86   : 					tmp->pnext = pdecal->pnext;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 87   : 					break;

	jmp	SHORT $LN4@R_DecalUnl
$LN8@R_DecalUnl:

; 88   : 				}
; 89   : 				tmp = tmp->pnext;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$[ebp], ecx

; 90   : 			}

	jmp	SHORT $LN2@R_DecalUnl
$LN4@R_DecalUnl:

; 91   : 		}
; 92   : 	}
; 93   : 
; 94   : 	if( pdecal->polys )

	mov	eax, DWORD PTR _pdecal$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN9@R_DecalUnl

; 95   : 		Mem_Free( pdecal->polys );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DecalUnlink@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pdecal$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@R_DecalUnl:

; 96   : 
; 97   : 	pdecal->psurface = NULL;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	DWORD PTR [eax+4], 0

; 98   : 	pdecal->polys = NULL;

	mov	eax, DWORD PTR _pdecal$[ebp]
	mov	DWORD PTR [eax+40], 0

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalUnlink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalShoot
_TEXT	SEGMENT
tv206 = -252						; size = 4
tv205 = -248						; size = 4
tv166 = -248						; size = 4
_matrix$1 = -180					; size = 64
_pos_l$2 = -116						; size = 12
_hull$ = -104						; size = 4
_height$ = -100						; size = 4
_width$ = -96						; size = 4
_model$ = -92						; size = 4
_ent$ = -88						; size = 4
_decalInfo$ = -84					; size = 80
__$ArrayPad$ = -4					; size = 4
_textureIndex$ = 8					; size = 4
_entityIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_flags$ = 24						; size = 4
_scale$ = 28						; size = 4
_R_DecalShoot PROC					; COMDAT

; 753  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 754  : 	decalinfo_t	decalInfo;
; 755  : 	cl_entity_t	*ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 756  : 	model_t		*model = NULL;

	mov	DWORD PTR _model$[ebp], 0

; 757  : 	int		width, height;
; 758  : 	hull_t		*hull;
; 759  : 
; 760  : 	if( textureIndex <= 0 || textureIndex >= MAX_TEXTURES )

	cmp	DWORD PTR _textureIndex$[ebp], 0
	jle	SHORT $LN3@R_DecalSho
	cmp	DWORD PTR _textureIndex$[ebp], 4096	; 00001000H
	jl	SHORT $LN2@R_DecalSho
$LN3@R_DecalSho:

; 761  : 	{
; 762  : 		Con_Printf( S_ERROR "Decal has invalid texture!\n" );

	push	OFFSET ??_C@_0CH@PKPNMMIJ@?$FO1Error?3?$FO7?5Decal?5has?5invalid?5te@
	call	_Con_Printf
	add	esp, 4

; 763  : 		return;

	jmp	$LN1@R_DecalSho
$LN2@R_DecalSho:

; 764  : 	}
; 765  : 
; 766  : 	if( entityIndex > 0 )

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN4@R_DecalSho

; 767  : 	{
; 768  : 		ent = CL_GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 769  : 
; 770  : 		if( modelIndex > 0 ) model = CL_ModelHandle( modelIndex );

	cmp	DWORD PTR _modelIndex$[ebp], 0
	jle	SHORT $LN6@R_DecalSho
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax
	jmp	SHORT $LN9@R_DecalSho
$LN6@R_DecalSho:

; 771  : 		else if( ent != NULL ) model = CL_ModelHandle( ent->curstate.modelindex );

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN8@R_DecalSho
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+952]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax
	jmp	SHORT $LN9@R_DecalSho
$LN8@R_DecalSho:

; 772  : 		else return;

	jmp	$LN1@R_DecalSho
$LN9@R_DecalSho:

; 773  : 	}

	jmp	SHORT $LN11@R_DecalSho
$LN4@R_DecalSho:

; 774  : 	else if( modelIndex > 0 )

	cmp	DWORD PTR _modelIndex$[ebp], 0
	jle	SHORT $LN10@R_DecalSho

; 775  : 		model = CL_ModelHandle( modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax
	jmp	SHORT $LN11@R_DecalSho
$LN10@R_DecalSho:

; 776  : 	else model = cl.worldmodel;

	mov	eax, DWORD PTR _cl+4579004
	mov	DWORD PTR _model$[ebp], eax
$LN11@R_DecalSho:

; 777  : 
; 778  : 	if( !model ) return;

	cmp	DWORD PTR _model$[ebp], 0
	jne	SHORT $LN12@R_DecalSho
	jmp	$LN1@R_DecalSho
$LN12@R_DecalSho:

; 779  : 	
; 780  : 	if( model->type != mod_brush )

	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN13@R_DecalSho

; 781  : 	{
; 782  : 		Con_Printf( S_ERROR "Decals must hit mod_brush!\n" );

	push	OFFSET ??_C@_0CH@BHCFOIAO@?$FO1Error?3?$FO7?5Decals?5must?5hit?5mod_@
	call	_Con_Printf
	add	esp, 4

; 783  : 		return;

	jmp	$LN1@R_DecalSho
$LN13@R_DecalSho:

; 784  : 	}
; 785  : 
; 786  : 	decalInfo.m_pModel = model;

	mov	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR _decalInfo$[ebp+12], eax

; 787  : 	hull = &model->hulls[0];	// always use #0 hull

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _model$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 788  : 
; 789  : 	// NOTE: all the decals at 'first shoot' placed into local space of parent entity
; 790  : 	// and won't transform again on a next restore, levelchange etc
; 791  : 	if( ent && !FBitSet( flags, FDECAL_LOCAL_SPACE ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN14@R_DecalSho
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	jne	$LN14@R_DecalSho

; 792  : 	{
; 793  : 		vec3_t	pos_l;
; 794  : 
; 795  : 		// transform decal position in local bmodel space
; 796  : 		if( !VectorIsNull( ent->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@R_DecalSho
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@R_DecalSho
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@R_DecalSho
$LN18@R_DecalSho:

; 797  : 		{
; 798  : 			matrix4x4	matrix;
; 799  : 
; 800  : 			Matrix4x4_CreateFromEntity( matrix, ent->angles, ent->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 801  : 			Matrix4x4_VectorITransform( matrix, pos, pos_l );

	lea	eax, DWORD PTR _pos_l$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 802  : 		}

	jmp	$LN17@R_DecalSho
$LN16@R_DecalSho:

; 803  : 		else
; 804  : 		{
; 805  : 			VectorSubtract( pos, ent->origin, pos_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+3224]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pos_l$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+3224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pos_l$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pos$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+3224]
	movss	DWORD PTR tv166[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR _pos_l$2[ebp+eax], xmm0
$LN17@R_DecalSho:

; 806  : 		}
; 807  : 
; 808  : 		VectorCopy( pos_l, decalInfo.m_Position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pos_l$2[ebp+ecx]
	mov	DWORD PTR _decalInfo$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos_l$2[ebp+edx]
	mov	DWORD PTR _decalInfo$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pos_l$2[ebp+edx]
	mov	DWORD PTR _decalInfo$[ebp+eax], ecx

; 809  : 		// decal position moved into local space
; 810  : 		SetBits( flags, FDECAL_LOCAL_SPACE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 128				; 00000080H
	mov	DWORD PTR _flags$[ebp], eax

; 811  : 	}

	jmp	SHORT $LN15@R_DecalSho
$LN14@R_DecalSho:

; 812  : 	else
; 813  : 	{
; 814  : 		// already in local space
; 815  : 		VectorCopy( pos, decalInfo.m_Position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _decalInfo$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _decalInfo$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _decalInfo$[ebp+ecx], eax
$LN15@R_DecalSho:

; 816  : 	}
; 817  : 
; 818  : 	// this decal must use landmark for correct transition
; 819  : 	// because their model exist only in world-space
; 820  : 	if( !FBitSet( model->flags, MODEL_HAS_ORIGIN ))

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	jne	SHORT $LN19@R_DecalSho

; 821  : 		SetBits( flags, FDECAL_USE_LANDMARK );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	mov	DWORD PTR _flags$[ebp], eax
$LN19@R_DecalSho:

; 822  : 
; 823  : 	// more state used by R_DecalNode()
; 824  : 	decalInfo.m_iTexture = textureIndex;

	mov	eax, DWORD PTR _textureIndex$[ebp]
	mov	DWORD PTR _decalInfo$[ebp+16], eax

; 825  : 	decalInfo.m_Entity = entityIndex;

	mov	eax, DWORD PTR _entityIndex$[ebp]
	mov	DWORD PTR _decalInfo$[ebp+28], eax

; 826  : 	decalInfo.m_Flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _decalInfo$[ebp+24], eax

; 827  : 
; 828  : 	R_GetDecalDimensions( textureIndex, &width, &height );

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _textureIndex$[ebp]
	push	edx
	call	_R_GetDecalDimensions
	add	esp, 12					; 0000000cH

; 829  : 	decalInfo.m_Size = width >> 1;

	mov	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _decalInfo$[ebp+20], eax

; 830  : 	if(( height >> 1 ) > decalInfo.m_Size )

	mov	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	cmp	eax, DWORD PTR _decalInfo$[ebp+20]
	jle	SHORT $LN20@R_DecalSho

; 831  : 		decalInfo.m_Size = height >> 1;

	mov	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	mov	DWORD PTR _decalInfo$[ebp+20], eax
$LN20@R_DecalSho:

; 832  : 
; 833  : 	decalInfo.m_scale = bound( MIN_DECAL_SCALE, scale, MAX_DECAL_SCALE );

	movss	xmm0, DWORD PTR _scale$[ebp]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jb	SHORT $LN24@R_DecalSho
	movss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR _scale$[ebp]
	jbe	SHORT $LN22@R_DecalSho
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv205[ebp], xmm0
	jmp	SHORT $LN23@R_DecalSho
$LN22@R_DecalSho:
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv205[ebp], xmm0
$LN23@R_DecalSho:
	movss	xmm0, DWORD PTR tv205[ebp]
	movss	DWORD PTR tv206[ebp], xmm0
	jmp	SHORT $LN25@R_DecalSho
$LN24@R_DecalSho:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv206[ebp], xmm0
$LN25@R_DecalSho:
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR _decalInfo$[ebp+32], xmm0

; 834  : 
; 835  : 	// compute the decal dimensions in world space
; 836  : 	decalInfo.m_decalWidth = width / decalInfo.m_scale;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR _decalInfo$[ebp+32]
	cvttss2si eax, xmm0
	mov	DWORD PTR _decalInfo$[ebp+36], eax

; 837  : 	decalInfo.m_decalHeight = height / decalInfo.m_scale;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	divss	xmm0, DWORD PTR _decalInfo$[ebp+32]
	cvttss2si eax, xmm0
	mov	DWORD PTR _decalInfo$[ebp+40], eax

; 838  : 
; 839  : 	R_DecalNode( model, &model->nodes[hull->firstclipnode], &decalInfo );

	lea	eax, DWORD PTR _decalInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	imul	edx, DWORD PTR [ecx+8], 52
	mov	eax, DWORD PTR _model$[ebp]
	add	edx, DWORD PTR [eax+164]
	push	edx
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	_R_DecalNode
	add	esp, 12					; 0000000cH
$LN1@R_DecalSho:

; 840  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalShoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_ClearDecals
_TEXT	SEGMENT
_R_ClearDecals PROC					; COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 62   : 	memset( gDecalPool, 0, sizeof( gDecalPool ));

	push	245760					; 0003c000H
	push	0
	push	OFFSET _gDecalPool
	call	_memset
	add	esp, 12					; 0000000cH

; 63   : 	gDecalCount = 0;

	mov	DWORD PTR _gDecalCount, 0

; 64   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ClearDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _DrawDecalsBatch
_TEXT	SEGMENT
tv71 = -76						; size = 4
_i$ = -8						; size = 4
_e$ = -4						; size = 4
_DrawDecalsBatch PROC					; COMDAT

; 1041 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1042 : 	cl_entity_t	*e;
; 1043 : 	int		i;
; 1044 : 
; 1045 : 	if( !tr.num_draw_decals )

	cmp	DWORD PTR _tr+83180, 0
	jne	SHORT $LN5@DrawDecals

; 1046 : 		return;

	jmp	$LN1@DrawDecals
$LN5@DrawDecals:

; 1047 : 
; 1048 : 	e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 1049 : 	Assert( e != NULL );

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN15@DrawDecals
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN16@DrawDecals
$LN15@DrawDecals:
	mov	DWORD PTR tv71[ebp], 0
$LN16@DrawDecals:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??DrawDecalsBatch@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_09GMNCBEGH@e?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1050 : 
; 1051 : 	if( e->curstate.rendermode != kRenderTransTexture )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN6@DrawDecals

; 1052 : 	{
; 1053 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1054 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1055 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask
$LN6@DrawDecals:

; 1056 : 	}
; 1057 : 
; 1058 : 	if( e->curstate.rendermode == kRenderTransTexture || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN8@DrawDecals
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN7@DrawDecals
$LN8@DrawDecals:

; 1059 : 		GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4
$LN7@DrawDecals:

; 1060 : 
; 1061 : 	if( gl_polyoffset->value )

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@DrawDecals

; 1062 : 	{
; 1063 : 		pglEnable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglEnable

; 1064 : 		pglPolygonOffset( -1.0f, -gl_polyoffset->value );

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPolygonOffset
$LN9@DrawDecals:

; 1065 : 	}
; 1066 : 
; 1067 : 	for( i = 0; i < tr.num_draw_decals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DrawDecals
$LN2@DrawDecals:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DrawDecals:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tr+83180
	jge	SHORT $LN3@DrawDecals

; 1068 : 	{
; 1069 : 		DrawSurfaceDecals( tr.draw_decals[i], false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+66796]
	push	ecx
	call	_DrawSurfaceDecals
	add	esp, 12					; 0000000cH

; 1070 : 	}

	jmp	SHORT $LN2@DrawDecals
$LN3@DrawDecals:

; 1071 : 
; 1072 : 	if( e->curstate.rendermode != kRenderTransTexture )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN10@DrawDecals

; 1073 : 	{
; 1074 : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1075 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1076 : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable
$LN10@DrawDecals:

; 1077 : 	}
; 1078 : 
; 1079 : 	if( gl_polyoffset->value )

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@DrawDecals

; 1080 : 		pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglDisable
$LN11@DrawDecals:

; 1081 : 
; 1082 : 	if( e->curstate.rendermode == kRenderTransTexture || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN13@DrawDecals
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN12@DrawDecals
$LN13@DrawDecals:

; 1083 : 		GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4
$LN12@DrawDecals:

; 1084 : 
; 1085 : 	tr.num_draw_decals = 0;

	mov	DWORD PTR _tr+83180, 0
$LN1@DrawDecals:

; 1086 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawDecalsBatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_EntityRemoveDecals
_TEXT	SEGMENT
_i$ = -12						; size = 4
_p$ = -8						; size = 4
_psurf$ = -4						; size = 4
_mod$ = 8						; size = 4
_R_EntityRemoveDecals PROC				; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1246 : 	msurface_t	*psurf;
; 1247 : 	decal_t		*p;
; 1248 : 	int		i;
; 1249 : 
; 1250 : 	if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN9@R_EntityRe
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN8@R_EntityRe
$LN9@R_EntityRe:

; 1251 : 		return;

	jmp	SHORT $LN1@R_EntityRe
$LN8@R_EntityRe:

; 1252 : 
; 1253 : 	psurf = &mod->surfaces[mod->firstmodelsurface];

	mov	eax, DWORD PTR _mod$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _mod$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _psurf$[ebp], ecx

; 1254 : 	for( i = 0; i < mod->nummodelsurfaces; i++, psurf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_EntityRe
$LN2@R_EntityRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], ecx
$LN4@R_EntityRe:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $LN1@R_EntityRe

; 1255 : 	{
; 1256 : 		for( p = psurf->pdecals; p; p = p->pnext )

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN7@R_EntityRe
$LN5@R_EntityRe:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN7@R_EntityRe:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@R_EntityRe

; 1257 : 			R_DecalUnlink( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_R_DecalUnlink
	add	esp, 4
	jmp	SHORT $LN5@R_EntityRe
$LN6@R_EntityRe:

; 1258 : 	}

	jmp	SHORT $LN2@R_EntityRe
$LN1@R_EntityRe:

; 1259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_EntityRemoveDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _DrawSingleDecal
_TEXT	SEGMENT
_numVerts$ = -12					; size = 4
_i$ = -8						; size = 4
_v$ = -4						; size = 4
_pDecal$ = 8						; size = 4
_fa$ = 12						; size = 4
_DrawSingleDecal PROC					; COMDAT

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 884  : 	float	*v;
; 885  : 	int	i, numVerts;
; 886  : 
; 887  : 	v = R_DecalSetupVerts( pDecal, fa, pDecal->texture, &numVerts );

	lea	eax, DWORD PTR _numVerts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	movsx	edx, WORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDecal$[ebp]
	push	ecx
	call	_R_DecalSetupVerts
	add	esp, 16					; 00000010H
	mov	DWORD PTR _v$[ebp], eax

; 888  : 	if( !numVerts ) return;

	cmp	DWORD PTR _numVerts$[ebp], 0
	jne	SHORT $LN5@DrawSingle
	jmp	$LN1@DrawSingle
$LN5@DrawSingle:

; 889  : 
; 890  : 	GL_Bind( GL_TEXTURE0, pDecal->texture );

	mov	eax, DWORD PTR _pDecal$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 891  : 
; 892  : 	pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 893  : 
; 894  : 	for( i = 0; i < numVerts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DrawSingle
$LN2@DrawSingle:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN4@DrawSingle:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numVerts$[ebp]
	jge	SHORT $LN3@DrawSingle

; 895  : 	{
; 896  : 		pglTexCoord2f( v[3], v[4] );

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 897  : 		pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 898  : 	}

	jmp	SHORT $LN2@DrawSingle
$LN3@DrawSingle:

; 899  : 
; 900  : 	pglEnd();

	call	DWORD PTR _pglEnd
$LN1@DrawSingle:

; 901  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawSingleDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalSetupVerts
_TEXT	SEGMENT
_v2$ = -20						; size = 4
_v$ = -16						; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_pDecal$ = 8						; size = 4
_surf$ = 12						; size = 4
_texture$ = 16						; size = 4
_outCount$ = 20						; size = 4
_R_DecalSetupVerts PROC					; COMDAT

; 846  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 847  : 	glpoly_t	*p = pDecal->polys;

	mov	eax, DWORD PTR _pDecal$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _p$[ebp], ecx

; 848  : 	int	i, count;
; 849  : 	float	*v, *v2;
; 850  : 
; 851  : 	if( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN5@R_DecalSet

; 852  : 	{
; 853  : 		v = g_DecalClipVerts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	mov	DWORD PTR _v$[ebp], ecx

; 854  : 		count = p->numverts;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _count$[ebp], ecx

; 855  : 		v2 = p->verts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _v2$[ebp], eax

; 856  : 
; 857  : 		// if we have mesh so skip clipping and just copy vertexes out (perf)
; 858  : 		for( i = 0; i < count; i++, v += VERTEXSIZE, v2 += VERTEXSIZE )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DecalSet
$LN2@R_DecalSet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _v2$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _v2$[ebp], edx
$LN4@R_DecalSet:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_DecalSet

; 859  : 		{
; 860  : 			VectorCopy( v2, v );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 861  : 			v[3] = v2[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 862  : 			v[4] = v2[4];

	mov	eax, 4
	shl	eax, 2
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 863  : 			v[5] = v2[5];

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 4
	imul	eax, edx, 5
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 864  : 			v[6] = v2[6];

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, 4
	imul	eax, edx, 6
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v2$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 865  : 		}

	jmp	$LN2@R_DecalSet
$LN3@R_DecalSet:

; 866  : 
; 867  : 		// restore pointer
; 868  : 		v = g_DecalClipVerts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _g_DecalClipVerts
	mov	DWORD PTR _v$[ebp], ecx

; 869  : 	}

	jmp	SHORT $LN6@R_DecalSet
$LN5@R_DecalSet:

; 870  : 	else
; 871  : 	{
; 872  : 		v = R_DecalVertsClip( pDecal, surf, texture, &count );

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _texture$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDecal$[ebp]
	push	eax
	call	_R_DecalVertsClip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _v$[ebp], eax

; 873  : 		R_DecalVertsLight( v, surf, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	_R_DecalVertsLight
	add	esp, 12					; 0000000cH
$LN6@R_DecalSet:

; 874  : 	}
; 875  : 
; 876  : 	if( outCount )

	cmp	DWORD PTR _outCount$[ebp], 0
	je	SHORT $LN7@R_DecalSet

; 877  : 		*outCount = count;

	mov	eax, DWORD PTR _outCount$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@R_DecalSet:

; 878  : 
; 879  : 	return v;

	mov	eax, DWORD PTR _v$[ebp]

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalSetupVerts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _DrawSurfaceDecals
_TEXT	SEGMENT
tv432 = -4660						; size = 8
tv403 = -4660						; size = 8
tv428 = -4652						; size = 4
tv399 = -4652						; size = 4
tv72 = -4652						; size = 4
_count$1 = -4136					; size = 4
_i$2 = -4132						; size = 4
_list$3 = -4128						; size = 4096
_numVerts$4 = -32					; size = 4
_i$5 = -28						; size = 4
_v$6 = -24						; size = 4
_o$7 = -20						; size = 4
_tex$8 = -16						; size = 4
_e$ = -12						; size = 4
_p$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_fa$ = 8						; size = 4
_single$ = 12						; size = 4
_reverse$ = 16						; size = 4
_DrawSurfaceDecals PROC					; COMDAT

; 904  : {	

	push	ebp
	mov	ebp, esp
	mov	eax, 4660				; 00001234H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 905  : 	decal_t		*p;
; 906  : 	cl_entity_t	*e;
; 907  : 
; 908  : 	if( !fa->pdecals ) return;

	mov	eax, DWORD PTR _fa$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $LN20@DrawSurfac
	jmp	$LN36@DrawSurfac
$LN20@DrawSurfac:

; 909  : 
; 910  : 	e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 911  : 	Assert( e != NULL );

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN47@DrawSurfac
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN48@DrawSurfac
$LN47@DrawSurfac:
	mov	DWORD PTR tv72[ebp], 0
$LN48@DrawSurfac:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??DrawSurfaceDecals@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DG@BDHJBJBE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_09GMNCBEGH@e?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 912  : 
; 913  : 	if( single )

	cmp	DWORD PTR _single$[ebp], 0
	je	$LN28@DrawSurfac

; 914  : 	{
; 915  : 		if( e->curstate.rendermode == kRenderNormal || e->curstate.rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN23@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 4
	jne	SHORT $LN24@DrawSurfac
$LN23@DrawSurfac:

; 916  : 		{
; 917  : 			pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 918  : 			pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 919  : 
; 920  : 			if( e->curstate.rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 4
	jne	SHORT $LN24@DrawSurfac

; 921  : 				pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable
$LN24@DrawSurfac:

; 922  : 		}
; 923  : 
; 924  : 		if( e->curstate.rendermode == kRenderTransColor )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 1
	jne	SHORT $LN25@DrawSurfac

; 925  : 			pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN25@DrawSurfac:

; 926  : 
; 927  : 		if( e->curstate.rendermode == kRenderTransTexture || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN27@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN26@DrawSurfac
$LN27@DrawSurfac:

; 928  : 			GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4
$LN26@DrawSurfac:

; 929  : 
; 930  : 		if( gl_polyoffset->value )

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@DrawSurfac

; 931  : 		{
; 932  : 			pglEnable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglEnable

; 933  : 			pglPolygonOffset( -1.0f, -gl_polyoffset->value );

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPolygonOffset
$LN28@DrawSurfac:

; 934  : 		}
; 935  : 	}
; 936  : 
; 937  : 	if( FBitSet( fa->flags, SURF_TRANSPARENT ) && glState.stencilEnabled )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	$LN3@DrawSurfac
	cmp	DWORD PTR _glState+568, 0
	je	$LN3@DrawSurfac

; 938  : 	{
; 939  : 		mtexinfo_t	*tex = fa->texinfo;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$8[ebp], ecx

; 940  : 
; 941  : 		for( p = fa->pdecals; p; p = p->pnext )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@DrawSurfac
$LN2@DrawSurfac:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@DrawSurfac:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@DrawSurfac

; 942  : 		{
; 943  : 			if( p->texture )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	test	ecx, ecx
	je	$LN30@DrawSurfac

; 944  : 			{
; 945  : 				float *o, *v;
; 946  : 				int i, numVerts;
; 947  : 				o = R_DecalSetupVerts( p, fa, p->texture, &numVerts );

	lea	eax, DWORD PTR _numVerts$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, WORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_R_DecalSetupVerts
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$7[ebp], eax

; 948  : 
; 949  : 				pglEnable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglEnable

; 950  : 				pglStencilFunc( GL_ALWAYS, 1, 0xFFFFFFFF );

	push	-1
	push	1
	push	519					; 00000207H
	call	DWORD PTR _pglStencilFunc

; 951  : 				pglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR _pglColorMask

; 952  : 
; 953  : 				pglStencilOp( GL_KEEP, GL_KEEP, GL_REPLACE );

	push	7681					; 00001e01H
	push	7680					; 00001e00H
	push	7680					; 00001e00H
	call	DWORD PTR _pglStencilOp

; 954  : 				pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 955  : 
; 956  : 				for( i = 0, v = o; i < numVerts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$5[ebp], 0
	mov	eax, DWORD PTR _o$7[ebp]
	mov	DWORD PTR _v$6[ebp], eax
	jmp	SHORT $LN7@DrawSurfac
$LN5@DrawSurfac:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
	mov	ecx, DWORD PTR _v$6[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$6[ebp], ecx
$LN7@DrawSurfac:
	mov	eax, DWORD PTR _i$5[ebp]
	cmp	eax, DWORD PTR _numVerts$4[ebp]
	jge	$LN6@DrawSurfac

; 957  : 				{
; 958  : 					v[5] = ( DotProduct( v, tex->vecs[0] ) + tex->vecs[0][3] ) / tex->texture->width;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _tex$8[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _tex$8[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _tex$8[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _tex$8[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _tex$8[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv399[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv399[ebp]
	mov	edx, DWORD PTR tv399[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv403[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv403[ebp]
	divss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$6[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 959  : 					v[6] = ( DotProduct( v, tex->vecs[1] ) + tex->vecs[1][3] ) / tex->texture->height;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _tex$8[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _tex$8[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _tex$8[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$6[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _tex$8[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _tex$8[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv428[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv428[ebp]
	mov	ecx, DWORD PTR tv428[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv432[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv432[ebp]
	divss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _v$6[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 960  : 
; 961  : 					pglTexCoord2f( v[5], v[6] );

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$6[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$6[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 962  : 					pglVertex3fv( v );

	mov	eax, DWORD PTR _v$6[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 963  : 				}

	jmp	$LN5@DrawSurfac
$LN6@DrawSurfac:

; 964  : 
; 965  : 				pglEnd();

	call	DWORD PTR _pglEnd

; 966  : 				pglStencilOp( GL_KEEP, GL_KEEP, GL_DECR );

	push	7683					; 00001e03H
	push	7680					; 00001e00H
	push	7680					; 00001e00H
	call	DWORD PTR _pglStencilOp

; 967  : 
; 968  : 				pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 969  : 				pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 970  : 
; 971  : 				for( i = 0, v = o; i < numVerts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$5[ebp], 0
	mov	eax, DWORD PTR _o$7[ebp]
	mov	DWORD PTR _v$6[ebp], eax
	jmp	SHORT $LN10@DrawSurfac
$LN8@DrawSurfac:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
	mov	ecx, DWORD PTR _v$6[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$6[ebp], ecx
$LN10@DrawSurfac:
	mov	eax, DWORD PTR _i$5[ebp]
	cmp	eax, DWORD PTR _numVerts$4[ebp]
	jge	SHORT $LN9@DrawSurfac

; 972  : 				{
; 973  : 					pglTexCoord2f( v[5], v[6] );

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$6[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$6[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 974  : 					pglVertex3fv( v );

	mov	eax, DWORD PTR _v$6[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 975  : 				}

	jmp	SHORT $LN8@DrawSurfac
$LN9@DrawSurfac:

; 976  : 
; 977  : 				pglEnd();

	call	DWORD PTR _pglEnd

; 978  : 				pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 979  : 
; 980  : 				pglColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );

	push	1
	push	1
	push	1
	push	1
	call	DWORD PTR _pglColorMask

; 981  : 				pglStencilFunc( GL_EQUAL, 0, 0xFFFFFFFF );

	push	-1
	push	0
	push	514					; 00000202H
	call	DWORD PTR _pglStencilFunc

; 982  : 				pglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );

	push	7680					; 00001e00H
	push	7680					; 00001e00H
	push	7680					; 00001e00H
	call	DWORD PTR _pglStencilOp
$LN30@DrawSurfac:

; 983  : 			}
; 984  : 		}

	jmp	$LN2@DrawSurfac
$LN3@DrawSurfac:

; 985  : 	}
; 986  : 
; 987  : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 988  : 
; 989  : 	if( reverse && e->curstate.rendermode == kRenderTransTexture )

	cmp	DWORD PTR _reverse$[ebp], 0
	je	$LN31@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	jne	$LN31@DrawSurfac

; 990  : 	{
; 991  : 		decal_t	*list[1024];
; 992  : 		int	i, count;
; 993  : 
; 994  : 		for( p = fa->pdecals, count = 0; p && count < 1024; p = p->pnext )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _p$[ebp], ecx
	mov	DWORD PTR _count$1[ebp], 0
	jmp	SHORT $LN13@DrawSurfac
$LN11@DrawSurfac:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN13@DrawSurfac:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN12@DrawSurfac
	cmp	DWORD PTR _count$1[ebp], 1024		; 00000400H
	jge	SHORT $LN12@DrawSurfac

; 995  : 			if( p->texture ) list[count++] = p;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN33@DrawSurfac
	mov	eax, DWORD PTR _count$1[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _list$3[ebp+eax*4], ecx
	mov	edx, DWORD PTR _count$1[ebp]
	add	edx, 1
	mov	DWORD PTR _count$1[ebp], edx
$LN33@DrawSurfac:
	jmp	SHORT $LN11@DrawSurfac
$LN12@DrawSurfac:

; 996  : 
; 997  : 		for( i = count - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _count$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN16@DrawSurfac
$LN14@DrawSurfac:
	mov	eax, DWORD PTR _i$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN16@DrawSurfac:
	cmp	DWORD PTR _i$2[ebp], 0
	jl	SHORT $LN15@DrawSurfac

; 998  : 			DrawSingleDecal( list[i], fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR _list$3[ebp+ecx*4]
	push	edx
	call	_DrawSingleDecal
	add	esp, 8
	jmp	SHORT $LN14@DrawSurfac
$LN15@DrawSurfac:

; 999  : 	}

	jmp	SHORT $LN18@DrawSurfac
$LN31@DrawSurfac:

; 1000 : 	else
; 1001 : 	{
; 1002 : 		for( p = fa->pdecals; p; p = p->pnext )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN19@DrawSurfac
$LN17@DrawSurfac:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN19@DrawSurfac:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN18@DrawSurfac

; 1003 : 		{
; 1004 : 			if( !p->texture ) continue;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $LN34@DrawSurfac
	jmp	SHORT $LN17@DrawSurfac
$LN34@DrawSurfac:

; 1005 : 			DrawSingleDecal( p, fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_DrawSingleDecal
	add	esp, 8

; 1006 : 		}

	jmp	SHORT $LN17@DrawSurfac
$LN18@DrawSurfac:

; 1007 : 	}
; 1008 : 
; 1009 : 	if( FBitSet( fa->flags, SURF_TRANSPARENT ) && glState.stencilEnabled )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN35@DrawSurfac
	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN35@DrawSurfac

; 1010 : 		pglDisable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglDisable
$LN35@DrawSurfac:

; 1011 : 
; 1012 : 	if( single )

	cmp	DWORD PTR _single$[ebp], 0
	je	$LN36@DrawSurfac

; 1013 : 	{
; 1014 : 		if( e->curstate.rendermode == kRenderNormal || e->curstate.rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN38@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 4
	jne	SHORT $LN39@DrawSurfac
$LN38@DrawSurfac:

; 1015 : 		{
; 1016 : 			pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1017 : 			pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1018 : 
; 1019 : 			if( e->curstate.rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 4
	jne	SHORT $LN39@DrawSurfac

; 1020 : 				pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable
$LN39@DrawSurfac:

; 1021 : 		}
; 1022 : 
; 1023 : 		if( gl_polyoffset->value )

	mov	eax, DWORD PTR _gl_polyoffset
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@DrawSurfac

; 1024 : 			pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglDisable
$LN40@DrawSurfac:

; 1025 : 
; 1026 : 		if( e->curstate.rendermode == kRenderTransTexture || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN42@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN41@DrawSurfac
$LN42@DrawSurfac:

; 1027 : 			GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4
$LN41@DrawSurfac:

; 1028 : 
; 1029 : 		if( e->curstate.rendermode == kRenderTransColor )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 1
	jne	SHORT $LN43@DrawSurfac

; 1030 : 			pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable
$LN43@DrawSurfac:

; 1031 : 
; 1032 : 		// restore blendfunc here
; 1033 : 		if( e->curstate.rendermode == kRenderTransAdd || e->curstate.rendermode == kRenderGlow )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	je	SHORT $LN45@DrawSurfac
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 3
	jne	SHORT $LN44@DrawSurfac
$LN45@DrawSurfac:

; 1034 : 			pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc
$LN44@DrawSurfac:

; 1035 : 
; 1036 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf
$LN36@DrawSurfac:

; 1037 : 	}
; 1038 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawSurfaceDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_ClearAllDecals
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pdecal$ = -4						; size = 4
_R_ClearAllDecals PROC					; COMDAT

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1271 : 	decal_t	*pdecal;
; 1272 : 	int	i;
; 1273 : 
; 1274 : 	// because gDecalCount may be zeroed after recach the decal limit
; 1275 : 	for( i = 0; i < MAX_RENDER_DECALS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_ClearAll
$LN2@R_ClearAll:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_ClearAll:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	SHORT $LN3@R_ClearAll

; 1276 : 	{
; 1277 : 		pdecal = &gDecalPool[i];

	imul	eax, DWORD PTR _i$[ebp], 60
	add	eax, OFFSET _gDecalPool
	mov	DWORD PTR _pdecal$[ebp], eax

; 1278 : 		R_DecalUnlink( pdecal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	push	eax
	call	_R_DecalUnlink
	add	esp, 4

; 1279 : 	}

	jmp	SHORT $LN2@R_ClearAll
$LN3@R_ClearAll:

; 1280 : 
; 1281 : 	if( clgame.drawFuncs.R_ClearStudioDecals )

	cmp	DWORD PTR _clgame+196, 0
	je	SHORT $LN1@R_ClearAll

; 1282 : 	{
; 1283 : 		clgame.drawFuncs.R_ClearStudioDecals();

	call	DWORD PTR _clgame+196
$LN1@R_ClearAll:

; 1284 : 	}
; 1285 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ClearAllDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_DecalRemoveAll
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pdecal$ = -4						; size = 4
_textureIndex$ = 8					; size = 4
_R_DecalRemoveAll PROC					; COMDAT

; 1217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1218 : 	decal_t	*pdecal;
; 1219 : 	int	i;
; 1220 : 
; 1221 : 	if( textureIndex < 0 || textureIndex >= MAX_TEXTURES )

	cmp	DWORD PTR _textureIndex$[ebp], 0
	jl	SHORT $LN6@R_DecalRem
	cmp	DWORD PTR _textureIndex$[ebp], 4096	; 00001000H
	jl	SHORT $LN5@R_DecalRem
$LN6@R_DecalRem:

; 1222 : 		return; // out of bounds

	jmp	SHORT $LN1@R_DecalRem
$LN5@R_DecalRem:

; 1223 : 
; 1224 : 	for( i = 0; i < gDecalCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DecalRem
$LN2@R_DecalRem:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DecalRem:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gDecalCount
	jge	SHORT $LN1@R_DecalRem

; 1225 : 	{
; 1226 : 		pdecal = &gDecalPool[i];

	imul	eax, DWORD PTR _i$[ebp], 60
	add	eax, OFFSET _gDecalPool
	mov	DWORD PTR _pdecal$[ebp], eax

; 1227 : 
; 1228 : 		// don't remove permanent decals
; 1229 : 		if( !textureIndex && FBitSet( pdecal->flags, FDECAL_PERMANENT ))

	cmp	DWORD PTR _textureIndex$[ebp], 0
	jne	SHORT $LN7@R_DecalRem
	mov	eax, DWORD PTR _pdecal$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	and	ecx, 1
	je	SHORT $LN7@R_DecalRem

; 1230 : 			continue;

	jmp	SHORT $LN2@R_DecalRem
$LN7@R_DecalRem:

; 1231 : 
; 1232 : 		if( !textureIndex || ( pdecal->texture == textureIndex ))

	cmp	DWORD PTR _textureIndex$[ebp], 0
	je	SHORT $LN9@R_DecalRem
	mov	eax, DWORD PTR _pdecal$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	cmp	ecx, DWORD PTR _textureIndex$[ebp]
	jne	SHORT $LN8@R_DecalRem
$LN9@R_DecalRem:

; 1233 : 			R_DecalUnlink( pdecal );

	mov	eax, DWORD PTR _pdecal$[ebp]
	push	eax
	call	_R_DecalUnlink
	add	esp, 4
$LN8@R_DecalRem:

; 1234 : 	}

	jmp	SHORT $LN2@R_DecalRem
$LN1@R_DecalRem:

; 1235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DecalRemoveAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_decals.c
;	COMDAT _R_CreateDecalList
_TEXT	SEGMENT
_pdecals$1 = -20					; size = 4
_decal$2 = -16						; size = 4
_depth$ = -12						; size = 4
_i$ = -8						; size = 4
_total$ = -4						; size = 4
_pList$ = 8						; size = 4
_R_CreateDecalList PROC					; COMDAT

; 1161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1162 : 	int	total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 1163 : 	int	i, depth;
; 1164 : 
; 1165 : 	if( cl.worldmodel )

	cmp	DWORD PTR _cl+4579004, 0
	je	$LN10@R_CreateDe

; 1166 : 	{
; 1167 : 		for( i = 0; i < MAX_RENDER_DECALS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_CreateDe
$LN2@R_CreateDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_CreateDe:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	$LN3@R_CreateDe

; 1168 : 		{
; 1169 : 			decal_t	*decal = &gDecalPool[i];

	imul	eax, DWORD PTR _i$[ebp], 60
	add	eax, OFFSET _gDecalPool
	mov	DWORD PTR _decal$2[ebp], eax

; 1170 : 			decal_t	*pdecals;
; 1171 : 			
; 1172 : 			// decal is in use and is not a custom decal
; 1173 : 			if( decal->psurface == NULL || FBitSet( decal->flags, FDECAL_DONTSAVE ))

	mov	eax, DWORD PTR _decal$2[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN9@R_CreateDe
	mov	eax, DWORD PTR _decal$2[ebp]
	movsx	ecx, WORD PTR [eax+22]
	and	ecx, 32					; 00000020H
	je	SHORT $LN8@R_CreateDe
$LN9@R_CreateDe:

; 1174 : 				 continue;

	jmp	SHORT $LN2@R_CreateDe
$LN8@R_CreateDe:

; 1175 : 
; 1176 : 			// compute depth
; 1177 : 			depth = 0;

	mov	DWORD PTR _depth$[ebp], 0

; 1178 : 			pdecals = decal->psurface->pdecals;

	mov	eax, DWORD PTR _decal$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR _pdecals$1[ebp], edx
$LN5@R_CreateDe:

; 1179 : 
; 1180 : 			while( pdecals && pdecals != decal )

	cmp	DWORD PTR _pdecals$1[ebp], 0
	je	SHORT $LN6@R_CreateDe
	mov	eax, DWORD PTR _pdecals$1[ebp]
	cmp	eax, DWORD PTR _decal$2[ebp]
	je	SHORT $LN6@R_CreateDe

; 1181 : 			{
; 1182 : 				depth++;

	mov	eax, DWORD PTR _depth$[ebp]
	add	eax, 1
	mov	DWORD PTR _depth$[ebp], eax

; 1183 : 				pdecals = pdecals->pnext;

	mov	eax, DWORD PTR _pdecals$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pdecals$1[ebp], ecx

; 1184 : 			}

	jmp	SHORT $LN5@R_CreateDe
$LN6@R_CreateDe:

; 1185 : 
; 1186 : 			pList[total].depth = depth;

	imul	eax, DWORD PTR _total$[ebp], 136
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	dl, BYTE PTR _depth$[ebp]
	mov	BYTE PTR [ecx+eax+78], dl

; 1187 : 			pList[total].flags = decal->flags;

	imul	eax, DWORD PTR _total$[ebp], 136
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR _decal$2[ebp]
	mov	dl, BYTE PTR [edx+22]
	mov	BYTE PTR [ecx+eax+79], dl

; 1188 : 			pList[total].scale = decal->scale;

	imul	eax, DWORD PTR _total$[ebp], 136
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR _decal$2[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+eax+80], edx

; 1189 : 			
; 1190 : 			R_DecalUnProject( decal, &pList[total] );

	imul	eax, DWORD PTR _total$[ebp], 136
	add	eax, DWORD PTR _pList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decal$2[ebp]
	push	ecx
	call	_R_DecalUnProject
	add	esp, 8

; 1191 : 			COM_FileBase( R_GetTexture( decal->texture )->name, pList[total].name );

	imul	eax, DWORD PTR _total$[ebp], 136
	mov	ecx, DWORD PTR _pList$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	push	edx
	mov	eax, DWORD PTR _decal$2[ebp]
	movsx	ecx, WORD PTR [eax+20]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 1192 : 
; 1193 : 			// check to see if the decal should be added
; 1194 : 			total = DecalListAdd( pList, total );

	mov	eax, DWORD PTR _total$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	push	ecx
	call	_DecalListAdd
	add	esp, 8
	mov	DWORD PTR _total$[ebp], eax

; 1195 : 		}

	jmp	$LN2@R_CreateDe
$LN3@R_CreateDe:

; 1196 : 
; 1197 : 		if( clgame.drawFuncs.R_CreateStudioDecalList )

	cmp	DWORD PTR _clgame+192, 0
	je	SHORT $LN10@R_CreateDe

; 1198 : 		{
; 1199 : 			total += clgame.drawFuncs.R_CreateStudioDecalList( pList, total );

	mov	eax, DWORD PTR _total$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	push	ecx
	call	DWORD PTR _clgame+192
	add	esp, 8
	add	eax, DWORD PTR _total$[ebp]
	mov	DWORD PTR _total$[ebp], eax
$LN10@R_CreateDe:

; 1200 : 		}
; 1201 : 	}
; 1202 : 
; 1203 : 	// sort the decals lowest depth first, so they can be re-applied in order
; 1204 : 	qsort( pList, total, sizeof( decallist_t ), DecalDepthCompare );

	push	OFFSET _DecalDepthCompare
	push	136					; 00000088H
	mov	eax, DWORD PTR _total$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	push	ecx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 1205 : 
; 1206 : 	return total;

	mov	eax, DWORD PTR _total$[ebp]

; 1207 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CreateDecalList ENDP
_TEXT	ENDS
END
