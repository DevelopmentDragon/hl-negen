; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\mod_studio.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

EXTRN	_Mod_Calloc:PROC
EXTRN	_Mod_CacheCheck:PROC
EXTRN	_Mod_LoadCacheFile:PROC
EXTRN	_Mod_StudioExtradata:PROC
PUBLIC	_Mod_InitStudioAPI
PUBLIC	_Mod_InitStudioHull
PUBLIC	_Mod_ResetStudioAPI
PUBLIC	_Mod_StudioTexName
PUBLIC	_Mod_GetStudioBounds
PUBLIC	_Mod_StudioGetAttachment
PUBLIC	_Mod_GetBonePosition
PUBLIC	_Mod_HullForStudio
PUBLIC	_Mod_StudioComputeBounds
PUBLIC	_Mod_HitgroupForStudioHull
PUBLIC	_Mod_ClearStudioCache
PUBLIC	_Mod_AddToStudioCache
PUBLIC	_Mod_CheckStudioCache
PUBLIC	_Mod_SetStudioHullPlane
PUBLIC	_Mod_StudioBoundVertex
PUBLIC	_Mod_StudioAccumulateBoneVerts
PUBLIC	_R_StudioLoadHeader
PUBLIC	_Mod_LoadStudioModel
PUBLIC	_Mod_UnloadStudioModel
PUBLIC	?__LINE__Var@?0??Mod_HullForStudio@@9@9		; `Mod_HullForStudio'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0EM@DFLAGAKM@?$FO3Warning?3?$FO7?5SV_StudioSetupBone@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_GetStudioBounds@@9@9	; `Mod_GetStudioBounds'::`1'::__LINE__Var
PUBLIC	??_C@_06FEMFHOOG@models@			; `string'
PUBLIC	??_C@_04IPGPBAO@?4mdl@				; `string'
PUBLIC	??_C@_05OIAJONFB@T?4mdl@			; `string'
PUBLIC	??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadStudioModel@@9@9	; `Mod_LoadStudioModel'::`1'::__LINE__Var
PUBLIC	??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@		; `string'
PUBLIC	??_C@_0DM@HCJDNNKB@?$FO3Warning?3?$FO7?5Mod_LoadStudioMode@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_UnloadStudioModel@@9@9	; `Mod_UnloadStudioModel'::`1'::__LINE__Var
PUBLIC	??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0BM@CNCIFPEN@Server_GetBlendingInterface@	; `string'
PUBLIC	??_C@_0EB@NKJPIMDH@SV_LoadProgs?3?5?$FO2initailized?5Ser@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb40000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@bc23d70a
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_fabs:PROC
EXTRN	_rsqrt:PROC
EXTRN	_RoundUpHullSize:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_Matrix3x4_VectorTransform:PROC
EXTRN	_Matrix3x4_ConcatTransforms:PROC
EXTRN	_Matrix3x4_FromOriginQuat:PROC
EXTRN	_Matrix3x4_CreateFromEntity:PROC
EXTRN	_Matrix3x4_OriginFromMatrix:PROC
EXTRN	_R_StudioSlerpBones:PROC
EXTRN	_R_StudioCalcBoneQuaternion:PROC
EXTRN	_R_StudioCalcBonePosition:PROC
EXTRN	_R_StudioGetAnim:PROC
EXTRN	_Mod_StudioLoadTextures:PROC
EXTRN	_Mod_StudioUnloadTextures:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_mod_studiocache:DWORD
EXTRN	_svgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_pBlendAPI DD	01H DUP (?)
_mod_studiohdr DD 01H DUP (?)
_studio_transform DD 0cH DUP (?)
_cache_hull DB	01400H DUP (?)
_studio_hull DB	01400H DUP (?)
_studio_bones DD 0600H DUP (?)
_studio_hull_hitgroup DD 080H DUP (?)
_cache_hull_hitgroup DD 080H DUP (?)
_cache_studio DB 0440H DUP (?)
_studio_clipnodes DQ 06H DUP (?)
_studio_planes DB 03c00H DUP (?)
_cache_planes DB 03c00H DUP (?)
_cache_current DD 01H DUP (?)
_cache_current_hull DD 01H DUP (?)
_cache_current_plane DD 01H DUP (?)
?pos@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos
?q@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q
?pos2@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos2
?q2@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q2
?pos3@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos3
?q3@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q3
?pos4@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos4
?q4@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q4
?texname@?1??Mod_StudioTexName@@9@9 DB 040H DUP (?)	; `Mod_StudioTexName'::`2'::texname
?pBlendIface@?1??Mod_InitStudioAPI@@9@9 DD 01H DUP (?)	; `Mod_InitStudioAPI'::`2'::pBlendIface
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bc23d70a
CONST	SEGMENT
__real@bc23d70a DD 0bc23d70ar			; -0.01
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0EB@NKJPIMDH@SV_LoadProgs?3?5?$FO2initailized?5Ser@
CONST	SEGMENT
??_C@_0EB@NKJPIMDH@SV_LoadProgs?3?5?$FO2initailized?5Ser@ DB 'SV_LoadProg'
	DB	's: ^2initailized Server Blending interface ^7ver. %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CNCIFPEN@Server_GetBlendingInterface@
CONST	SEGMENT
??_C@_0BM@CNCIFPEN@Server_GetBlendingInterface@ DB 'Server_GetBlendingInt'
	DB	'erface', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_gBlendAPI DD	01H
	DD	FLAT:_SV_StudioSetupBones
_gStudioAPI DD	FLAT:_Mod_Calloc
	DD	FLAT:_Mod_CacheCheck
	DD	FLAT:_Mod_LoadCacheFile
	DD	FLAT:_Mod_StudioExtradata
_DATA	ENDS
;	COMDAT ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@ DB 'mod != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_UnloadStudioModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_UnloadStudioModel@@9@9 DD 037fH	; `Mod_UnloadStudioModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DM@HCJDNNKB@?$FO3Warning?3?$FO7?5Mod_LoadStudioMode@
CONST	SEGMENT
??_C@_0DM@HCJDNNKB@?$FO3Warning?3?$FO7?5Mod_LoadStudioMode@ DB '^3Warning'
	DB	':^7 Mod_LoadStudioModel: %s missing textures file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
CONST	SEGMENT
??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@ DB '^2%s^7', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadStudioModel@@9@9 DD 031fH	; `Mod_LoadStudioModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
CONST	SEGMENT
??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ DB '^1E'
	DB	'rror:^7 %s has wrong version number (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OIAJONFB@T?4mdl@
CONST	SEGMENT
??_C@_05OIAJONFB@T?4mdl@ DB 'T.mdl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPGPBAO@?4mdl@
CONST	SEGMENT
??_C@_04IPGPBAO@?4mdl@ DB '.mdl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEMFHOOG@models@
CONST	SEGMENT
??_C@_06FEMFHOOG@models@ DB 'models', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_GetStudioBounds@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_GetStudioBounds@@9@9 DD 02bdH	; `Mod_GetStudioBounds'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EM@DFLAGAKM@?$FO3Warning?3?$FO7?5SV_StudioSetupBone@
CONST	SEGMENT
??_C@_0EM@DFLAGAKM@?$FO3Warning?3?$FO7?5SV_StudioSetupBone@ DB '^3Warning'
	DB	':^7 SV_StudioSetupBones: sequence %i/%i out of range for mode'
	DB	'l %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\mod_studio.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_HullForStudio@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_HullForStudio@@9@9 DD 0e7H		; `Mod_HullForStudio'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01b9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0192H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03a3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	046fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	043fH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_UnloadStudioModel
_TEXT	SEGMENT
tv70 = -68						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadStudioModel PROC				; COMDAT

; 895  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 896  : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN4@Mod_Unload
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@Mod_Unload
$LN4@Mod_Unload:
	mov	DWORD PTR tv70[ebp], 0
$LN5@Mod_Unload:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadStudioModel@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 897  : 
; 898  : 	if( mod->type != mod_studio )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	je	SHORT $LN2@Mod_Unload

; 899  : 		return; // not a studio

	jmp	SHORT $LN1@Mod_Unload
$LN2@Mod_Unload:

; 900  : 
; 901  : 	Mod_StudioUnloadTextures( mod->cache.data );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	call	_Mod_StudioUnloadTextures
	add	esp, 4

; 902  : 	Mem_FreePool( &mod->mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadStudioModel@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 903  : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_Unload:

; 904  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_LoadStudioModel
_TEXT	SEGMENT
_size2$1 = -28						; size = 4
_size1$2 = -24						; size = 4
_buffer2$3 = -20					; size = 4
_out$4 = -16						; size = 4
_in$5 = -12						; size = 4
_thdr$6 = -8						; size = 4
_phdr$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_Mod_LoadStudioModel PROC				; COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 800  : 	studiohdr_t	*phdr;
; 801  : 
; 802  : 	if( loaded ) *loaded = false;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN2@Mod_LoadSt
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Mod_LoadSt:

; 803  : 	loadmodel->mempool = Mem_AllocPool( va( "^2%s^7", loadmodel->name ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+76], eax

; 804  : 	loadmodel->type = mod_studio;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+68], 3

; 805  : 
; 806  : 	phdr = R_StudioLoadHeader( mod, buffer );

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_R_StudioLoadHeader
	add	esp, 8
	mov	DWORD PTR _phdr$[ebp], eax

; 807  : 	if( !phdr ) return;	// bad model

	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $LN3@Mod_LoadSt
	jmp	$LN15@Mod_LoadSt
$LN3@Mod_LoadSt:

; 808  : 
; 809  : 	if( phdr->numtextures == 0 )

	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax+180], 0
	jne	$LN4@Mod_LoadSt

; 810  : 	{
; 811  : 		studiohdr_t	*thdr;
; 812  : 		byte		*in, *out;
; 813  : 		void		*buffer2 = NULL;

	mov	DWORD PTR _buffer2$3[ebp], 0

; 814  : 		size_t		size1, size2;
; 815  : 
; 816  : 		buffer2 = FS_LoadFile( Mod_StudioTexName( mod->name ), NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer2$3[ebp], eax

; 817  : 		thdr = R_StudioLoadHeader( mod, buffer2 );

	mov	eax, DWORD PTR _buffer2$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_R_StudioLoadHeader
	add	esp, 8
	mov	DWORD PTR _thdr$6[ebp], eax

; 818  : 
; 819  : 		if( !thdr )

	cmp	DWORD PTR _thdr$6[ebp], 0
	jne	SHORT $LN6@Mod_LoadSt

; 820  : 		{
; 821  : 			Con_Printf( S_WARN "Mod_LoadStudioModel: %s missing textures file\n", mod->name ); 

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@HCJDNNKB@?$FO3Warning?3?$FO7?5Mod_LoadStudioMode@
	call	_Con_Printf
	add	esp, 8

; 822  : 			if( buffer2 ) Mem_Free( buffer2 );

	cmp	DWORD PTR _buffer2$3[ebp], 0
	je	SHORT $LN8@Mod_LoadSt
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buffer2$3[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@Mod_LoadSt:

; 823  : 		}

	jmp	$LN7@Mod_LoadSt
$LN6@Mod_LoadSt:

; 824  :                     else
; 825  :                     {
; 826  : 			Mod_StudioLoadTextures( mod, thdr );

	mov	eax, DWORD PTR _thdr$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_StudioLoadTextures
	add	esp, 8

; 827  : 
; 828  : 			// give space for textures and skinrefs
; 829  : 			size1 = thdr->numtextures * sizeof( mstudiotexture_t );

	mov	eax, DWORD PTR _thdr$6[ebp]
	imul	ecx, DWORD PTR [eax+180], 80
	mov	DWORD PTR _size1$2[ebp], ecx

; 830  : 			size2 = thdr->numskinfamilies * thdr->numskinref * sizeof( short );

	mov	eax, DWORD PTR _thdr$6[ebp]
	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR [eax+196]
	imul	edx, DWORD PTR [ecx+192]
	shl	edx, 1
	mov	DWORD PTR _size2$1[ebp], edx

; 831  : 			mod->cache.data = Mem_Calloc( loadmodel->mempool, phdr->length + size1 + size2 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	add	edx, DWORD PTR _size1$2[ebp]
	add	edx, DWORD PTR _size2$1[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+388], eax

; 832  : 			memcpy( loadmodel->cache.data, buffer, phdr->length ); // copy main mdl buffer

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 833  : 			phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _phdr$[ebp], ecx

; 834  : 			phdr->numskinfamilies = thdr->numskinfamilies;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+196], edx

; 835  : 			phdr->numtextures = thdr->numtextures;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+180], edx

; 836  : 			phdr->numskinref = thdr->numskinref;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR [eax+192], edx

; 837  : 			phdr->textureindex = phdr->length;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+184], edx

; 838  : 			phdr->skinindex = phdr->textureindex + size1;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	add	ecx, DWORD PTR _size1$2[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	DWORD PTR [edx+200], ecx

; 839  : 
; 840  : 			in = (byte *)thdr + thdr->textureindex;

	mov	eax, DWORD PTR _thdr$6[ebp]
	mov	ecx, DWORD PTR _thdr$6[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _in$5[ebp], ecx

; 841  : 			out = (byte *)phdr + phdr->textureindex;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _out$4[ebp], ecx

; 842  : 			memcpy( out, in, size1 + size2 );	// copy textures + skinrefs

	mov	eax, DWORD PTR _size1$2[ebp]
	add	eax, DWORD PTR _size2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$4[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 843  : 			phdr->length += size1 + size2;

	mov	eax, DWORD PTR _size1$2[ebp]
	add	eax, DWORD PTR _size2$1[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	DWORD PTR [edx+72], eax

; 844  : 			Mem_Free( buffer2 ); // release T.mdl

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buffer2$3[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@Mod_LoadSt:

; 845  : 		}
; 846  : 	}

	jmp	$LN5@Mod_LoadSt
$LN4@Mod_LoadSt:

; 847  : 	else
; 848  : 	{
; 849  : 		// NOTE: don't modify source buffer because it's used for CRC computing
; 850  : 		loadmodel->cache.data = Mem_Calloc( loadmodel->mempool, phdr->length );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 51					; 00000033H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+388], eax

; 851  : 		memcpy( loadmodel->cache.data, buffer, phdr->length );

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 852  : 		phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _phdr$[ebp], ecx

; 853  : 		Mod_StudioLoadTextures( mod, phdr );

	mov	eax, DWORD PTR _phdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_StudioLoadTextures
	add	esp, 8

; 854  : 
; 855  : 		// NOTE: we wan't keep raw textures in memory. just cutoff model pointer above texture base
; 856  : 		loadmodel->cache.data = Mem_Realloc( loadmodel->mempool, loadmodel->cache.data, phdr->texturedataindex );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadStudioModel@@9@9
	add	eax, 57					; 00000039H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+388], eax

; 857  : 		phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _phdr$[ebp], ecx

; 858  : 		phdr->length = phdr->texturedataindex;	// update model size

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR [eax+72], edx
$LN5@Mod_LoadSt:

; 859  : 	}
; 860  : 
; 861  : 	// setup bounding box
; 862  : 	if( !VectorCompare( vec3_origin, phdr->bbmin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[ecx]
	ucomiss	xmm0, DWORD PTR [edx+eax+112]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_LoadSt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+112]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_LoadSt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+112]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@Mod_LoadSt
$LN11@Mod_LoadSt:

; 863  : 	{
; 864  : 		// clipping bounding box
; 865  : 		VectorCopy( phdr->bbmin, loadmodel->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+112]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+112]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+112]
	mov	DWORD PTR [edx+ecx+84], eax

; 866  : 		VectorCopy( phdr->bbmax, loadmodel->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+124]
	mov	DWORD PTR [edx+eax+96], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+124]
	mov	DWORD PTR [ecx+eax+96], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+124]
	mov	DWORD PTR [edx+ecx+96], eax

; 867  : 	}

	jmp	$LN13@Mod_LoadSt
$LN9@Mod_LoadSt:

; 868  : 	else if( !VectorCompare( vec3_origin, phdr->min ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[ecx]
	ucomiss	xmm0, DWORD PTR [edx+eax+88]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@Mod_LoadSt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+88]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@Mod_LoadSt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+88]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@Mod_LoadSt
$LN14@Mod_LoadSt:

; 869  : 	{
; 870  : 		// movement bounding box
; 871  : 		VectorCopy( phdr->min, loadmodel->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+88]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+88]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+88]
	mov	DWORD PTR [edx+ecx+84], eax

; 872  : 		VectorCopy( phdr->max, loadmodel->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+100]
	mov	DWORD PTR [edx+eax+96], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+100]
	mov	DWORD PTR [ecx+eax+96], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+100]
	mov	DWORD PTR [edx+ecx+96], eax

; 873  : 	}

	jmp	SHORT $LN13@Mod_LoadSt
$LN12@Mod_LoadSt:

; 874  : 	else
; 875  : 	{
; 876  : 		// well compute bounds from vertices and round to nearest even values
; 877  : 		Mod_StudioComputeBounds( phdr, loadmodel->mins, loadmodel->maxs, true );

	push	1
	mov	eax, DWORD PTR _loadmodel
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _phdr$[ebp]
	push	edx
	call	_Mod_StudioComputeBounds
	add	esp, 16					; 00000010H

; 878  : 		RoundUpHullSize( loadmodel->mins );

	mov	eax, DWORD PTR _loadmodel
	add	eax, 84					; 00000054H
	push	eax
	call	_RoundUpHullSize
	add	esp, 4

; 879  : 		RoundUpHullSize( loadmodel->maxs );

	mov	eax, DWORD PTR _loadmodel
	add	eax, 96					; 00000060H
	push	eax
	call	_RoundUpHullSize
	add	esp, 4
$LN13@Mod_LoadSt:

; 880  : 	}
; 881  : 
; 882  : 	loadmodel->numframes = Mod_StudioBodyVariations( loadmodel );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	call	_Mod_StudioBodyVariations
	add	esp, 4
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+72], eax

; 883  : 	loadmodel->radius = RadiusFromBounds( loadmodel->mins, loadmodel->maxs );

	mov	eax, DWORD PTR _loadmodel
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	add	ecx, 84					; 00000054H
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _loadmodel
	fstp	DWORD PTR [edx+108]

; 884  : 	loadmodel->flags = phdr->flags; // copy header flags

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+80], edx

; 885  : 
; 886  : 	if( loaded ) *loaded = true;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN15@Mod_LoadSt
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN15@Mod_LoadSt:

; 887  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _R_StudioLoadHeader
_TEXT	SEGMENT
_i$ = -12						; size = 4
_phdr$ = -8						; size = 4
_pin$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_R_StudioLoadHeader PROC				; COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 774  : 	byte		*pin;
; 775  : 	studiohdr_t	*phdr;
; 776  : 	int		i;
; 777  : 
; 778  : 	if( !buffer ) return NULL;

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@R_StudioLo
	xor	eax, eax
	jmp	SHORT $LN1@R_StudioLo
$LN2@R_StudioLo:

; 779  : 
; 780  : 	pin = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pin$[ebp], eax

; 781  : 	phdr = (studiohdr_t *)pin;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _phdr$[ebp], eax

; 782  : 	i = phdr->version;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx

; 783  : 
; 784  : 	if( i != STUDIO_VERSION )

	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	je	SHORT $LN3@R_StudioLo

; 785  : 	{
; 786  : 		Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", mod->name, i, STUDIO_VERSION );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 787  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioLo
$LN3@R_StudioLo:

; 788  : 	}	
; 789  : 
; 790  : 	return (studiohdr_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
$LN1@R_StudioLo:

; 791  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioLoadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioBodyVariations
_TEXT	SEGMENT
_count$ = -16						; size = 4
_i$ = -12						; size = 4
_pbodypart$ = -8					; size = 4
_pstudiohdr$ = -4					; size = 4
_mod$ = 8						; size = 4
_Mod_StudioBodyVariations PROC				; COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 750  : 	studiohdr_t	*pstudiohdr;
; 751  : 	mstudiobodyparts_t	*pbodypart;
; 752  : 	int		i, count = 1;

	mov	DWORD PTR _count$[ebp], 1

; 753  : 
; 754  : 	pstudiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudiohdr$[ebp], eax

; 755  : 	if( !pstudiohdr ) return 0;

	cmp	DWORD PTR _pstudiohdr$[ebp], 0
	jne	SHORT $LN5@Mod_Studio
	xor	eax, eax
	jmp	SHORT $LN1@Mod_Studio
$LN5@Mod_Studio:

; 756  : 
; 757  : 	pbodypart = (mstudiobodyparts_t *)((byte *)pstudiohdr + pstudiohdr->bodypartindex);

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _pbodypart$[ebp], ecx

; 758  : 
; 759  : 	// each body part has nummodels variations so there are as many total variations as there
; 760  : 	// are in a matrix of each part by each other part
; 761  : 	for( i = 0; i < pstudiohdr->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+204]
	jge	SHORT $LN3@Mod_Studio

; 762  : 		count = count * pbodypart[i].nummodels;

	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	imul	edx, DWORD PTR [ecx+eax+64]
	mov	DWORD PTR _count$[ebp], edx
	jmp	SHORT $LN2@Mod_Studio
$LN3@Mod_Studio:

; 763  : 
; 764  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@Mod_Studio:

; 765  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioBodyVariations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioAccumulateBoneVerts
_TEXT	SEGMENT
tv132 = -96						; size = 4
tv85 = -96						; size = 4
_point$ = -28						; size = 12
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_numverts$ = 16						; size = 4
_bone_mins$ = 20					; size = 4
_bone_maxs$ = 24					; size = 4
_numbones$ = 28						; size = 4
_Mod_StudioAccumulateBoneVerts PROC			; COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 602  : 	vec3_t	delta;
; 603  : 	vec3_t	point;
; 604  : 
; 605  : 	if( *numbones <= 0 )

	mov	eax, DWORD PTR _numbones$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN2@Mod_Studio

; 606  : 		return;

	jmp	$LN1@Mod_Studio
$LN2@Mod_Studio:

; 607  : 
; 608  : 	// calculate the midpoint of the second vertex,
; 609  : 	VectorSubtract( bone_maxs, bone_mins, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv85[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv85[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 610  : 
; 611  : 	VectorScale( delta, 0.5f, point );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _point$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv132[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 612  : 	Mod_StudioBoundVertex( mins, maxs, numverts, point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numverts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H

; 613  : 
; 614  : 	VectorClear( bone_mins );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 615  : 	VectorClear( bone_maxs );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 616  : 	*numbones = 0;

	mov	eax, DWORD PTR _numbones$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Mod_Studio:

; 617  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioAccumulateBoneVerts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioBoundVertex
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_numverts$ = 16						; size = 4
_vertex$ = 20						; size = 4
_Mod_StudioBoundVertex PROC				; COMDAT

; 587  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 588  : 	if((*numverts) == 0 )

	mov	eax, DWORD PTR _numverts$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@Mod_Studio

; 589  : 		ClearBounds( mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8
$LN2@Mod_Studio:

; 590  : 
; 591  : 	AddPointToBounds( vertex, mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vertex$[ebp]
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 592  : 	(*numverts)++;

	mov	eax, DWORD PTR _numverts$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _numverts$[ebp]
	mov	DWORD PTR [edx], ecx

; 593  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioBoundVertex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _SV_StudioSetupBones
_TEXT	SEGMENT
_s$1 = -596						; size = 4
_bonematrix$ = -592					; size = 48
_panim$ = -544						; size = 4
_pseqdesc$ = -540					; size = 4
_pbones$ = -536						; size = 4
_f$ = -532						; size = 4
_boneused$ = -528					; size = 512
_numbones$ = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pModel$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_pcontroller$ = 28					; size = 4
_pblending$ = 32					; size = 4
_iBone$ = 36						; size = 4
_pEdict$ = 40						; size = 4
_SV_StudioSetupBones PROC				; COMDAT

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 724				; 000002d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 409  : 	int		i, j, numbones = 0;

	mov	DWORD PTR _numbones$[ebp], 0

; 410  : 	int		boneused[MAXSTUDIOBONES];
; 411  : 	float		f = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 412  : 
; 413  : 	mstudiobone_t	*pbones;
; 414  : 	mstudioseqdesc_t	*pseqdesc;
; 415  : 	mstudioanim_t	*panim;
; 416  : 
; 417  : 	static float	pos[MAXSTUDIOBONES][3];
; 418  : 	static vec4_t	q[MAXSTUDIOBONES];
; 419  : 	matrix3x4		bonematrix;
; 420  : 
; 421  : 	static float	pos2[MAXSTUDIOBONES][3];
; 422  : 	static vec4_t	q2[MAXSTUDIOBONES];
; 423  : 	static float	pos3[MAXSTUDIOBONES][3];
; 424  : 	static vec4_t	q3[MAXSTUDIOBONES];
; 425  : 	static float	pos4[MAXSTUDIOBONES][3];
; 426  : 	static vec4_t	q4[MAXSTUDIOBONES];
; 427  : 
; 428  : 	if( sequence < 0 || sequence >= mod_studiohdr->numseq )

	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $LN12@SV_StudioS
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jl	SHORT $LN11@SV_StudioS
$LN12@SV_StudioS:

; 429  : 	{
; 430  : 		// only show warn if sequence that out of range was specified intentionally
; 431  : 		if( sequence > mod_studiohdr->numseq )

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jle	SHORT $LN13@SV_StudioS

; 432  : 			Con_Reportf( S_WARN "SV_StudioSetupBones: sequence %i/%i out of range for model %s\n", sequence, mod_studiohdr->numseq, pModel->name );

	mov	eax, DWORD PTR _pModel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	push	OFFSET ??_C@_0EM@DFLAGAKM@?$FO3Warning?3?$FO7?5SV_StudioSetupBone@
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN13@SV_StudioS:

; 433  : 		sequence = 0;

	mov	DWORD PTR _sequence$[ebp], 0
$LN11@SV_StudioS:

; 434  : 	}
; 435  : 
; 436  : 	pseqdesc = (mstudioseqdesc_t *)((byte *)mod_studiohdr + mod_studiohdr->seqindex) + sequence;

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _sequence$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 437  : 	pbones = (mstudiobone_t *)((byte *)mod_studiohdr + mod_studiohdr->boneindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 438  : 	panim = R_StudioGetAnim( mod_studiohdr, pModel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pModel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod_studiohdr
	push	edx
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 439  : 
; 440  : 	if( iBone < -1 || iBone >= mod_studiohdr->numbones )

	cmp	DWORD PTR _iBone$[ebp], -1
	jl	SHORT $LN15@SV_StudioS
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _iBone$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jl	SHORT $LN14@SV_StudioS
$LN15@SV_StudioS:

; 441  : 		iBone = 0;

	mov	DWORD PTR _iBone$[ebp], 0
$LN14@SV_StudioS:

; 442  : 
; 443  : 	if( iBone == -1 )

	cmp	DWORD PTR _iBone$[ebp], -1
	jne	SHORT $LN16@SV_StudioS

; 444  : 	{
; 445  : 		numbones = mod_studiohdr->numbones;

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _numbones$[ebp], ecx

; 446  : 		for( i = 0; i < mod_studiohdr->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_StudioS
$LN2@SV_StudioS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_StudioS:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN3@SV_StudioS

; 447  : 			boneused[(numbones - i) - 1] = i;

	mov	eax, DWORD PTR _numbones$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _boneused$[ebp+eax*4-4], ecx
	jmp	SHORT $LN2@SV_StudioS
$LN3@SV_StudioS:

; 448  : 	}

	jmp	SHORT $LN6@SV_StudioS
$LN16@SV_StudioS:

; 449  : 	else
; 450  : 	{
; 451  : 		// only the parent bones
; 452  : 		for( i = iBone; i != -1; i = pbones[i].parent )

	mov	eax, DWORD PTR _iBone$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@SV_StudioS
$LN5@SV_StudioS:
	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	edx, DWORD PTR [ecx+eax+32]
	mov	DWORD PTR _i$[ebp], edx
$LN7@SV_StudioS:
	cmp	DWORD PTR _i$[ebp], -1
	je	SHORT $LN6@SV_StudioS

; 453  : 			boneused[numbones++] = i;

	mov	eax, DWORD PTR _numbones$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _boneused$[ebp+eax*4], ecx
	mov	edx, DWORD PTR _numbones$[ebp]
	add	edx, 1
	mov	DWORD PTR _numbones$[ebp], edx
	jmp	SHORT $LN5@SV_StudioS
$LN6@SV_StudioS:

; 454  : 	}
; 455  : 
; 456  : 	if( pseqdesc->numframes > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jle	SHORT $LN18@SV_StudioS

; 457  : 		f = ( frame * ( pseqdesc->numframes - 1 )) / 256.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _frame$[ebp]
	divss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR _f$[ebp], xmm0
$LN18@SV_StudioS:

; 458  : 
; 459  : 	Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos, q, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _numbones$[ebp]
	push	eax
	lea	ecx, DWORD PTR _boneused$[ebp]
	push	ecx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 460  : 
; 461  : 	if( pseqdesc->numblends > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 1
	jle	$LN20@SV_StudioS

; 462  : 	{
; 463  : 		float	s;
; 464  : 
; 465  : 		panim += mod_studiohdr->numbones;

	mov	eax, DWORD PTR _mod_studiohdr
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 466  : 		Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos2, q2, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos2@?1??SV_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _numbones$[ebp]
	push	eax
	lea	ecx, DWORD PTR _boneused$[ebp]
	push	ecx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 467  : 
; 468  : 		s = (float)pblending[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pblending$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 469  : 
; 470  : 		R_StudioSlerpBones( mod_studiohdr->numbones, q, pos, q2, pos2, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 471  : 
; 472  : 		if( pseqdesc->numblends == 4 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 4
	jne	$LN20@SV_StudioS

; 473  : 		{
; 474  : 			panim += mod_studiohdr->numbones;

	mov	eax, DWORD PTR _mod_studiohdr
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 475  : 			Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos3, q3, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _numbones$[ebp]
	push	eax
	lea	ecx, DWORD PTR _boneused$[ebp]
	push	ecx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 476  : 
; 477  : 			panim += mod_studiohdr->numbones;

	mov	eax, DWORD PTR _mod_studiohdr
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 478  : 			Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos4, q4, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos4@?1??SV_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _numbones$[ebp]
	push	eax
	lea	ecx, DWORD PTR _boneused$[ebp]
	push	ecx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 479  : 
; 480  : 			s = (float)pblending[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pblending$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 481  : 			R_StudioSlerpBones( mod_studiohdr->numbones, q3, pos3, q4, pos4, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 482  : 
; 483  : 			s = (float)pblending[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pblending$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 484  : 			R_StudioSlerpBones( mod_studiohdr->numbones, q, pos, q3, pos3, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H
$LN20@SV_StudioS:

; 485  : 		}
; 486  : 	}
; 487  : 
; 488  : 	Matrix3x4_CreateFromEntity( studio_transform, angles, origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	push	OFFSET _studio_transform
	call	_Matrix3x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 489  : 
; 490  : 	for( j = numbones - 1; j >= 0; j-- )

	mov	eax, DWORD PTR _numbones$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN10@SV_StudioS
$LN8@SV_StudioS:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_StudioS:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN9@SV_StudioS

; 491  : 	{
; 492  : 		i = boneused[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _boneused$[ebp+eax*4]
	mov	DWORD PTR _i$[ebp], ecx

; 493  : 
; 494  : 		Matrix3x4_FromOriginQuat( bonematrix, q[i], pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	push	ecx
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	_Matrix3x4_FromOriginQuat
	add	esp, 12					; 0000000cH

; 495  : 		if( pbones[i].parent == -1 ) 

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [ecx+eax+32], -1
	jne	SHORT $LN21@SV_StudioS

; 496  : 			Matrix3x4_ConcatTransforms( studio_bones[i], studio_transform, bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	push	OFFSET _studio_transform
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _studio_bones
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@SV_StudioS
$LN21@SV_StudioS:

; 497  : 		else Matrix3x4_ConcatTransforms( studio_bones[i], studio_bones[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _studio_bones
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _studio_bones
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
$LN22@SV_StudioS:

; 498  : 	}

	jmp	$LN8@SV_StudioS
$LN9@SV_StudioS:

; 499  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StudioSetupBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioCalcRotations
_TEXT	SEGMENT
_s$ = -56						; size = 4
_adj$ = -52						; size = 32
_pbone$ = -20						; size = 4
_frame$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_boneused$ = 8						; size = 4
_numbones$ = 12						; size = 4
_pcontroller$ = 16					; size = 4
_pos$ = 20						; size = 4
_q$ = 24						; size = 4
_pseqdesc$ = 28						; size = 4
_panim$ = 32						; size = 4
_f$ = 36						; size = 4
_Mod_StudioCalcRotations PROC				; COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 361  : 	int		i, j, frame;
; 362  : 	mstudiobone_t	*pbone;
; 363  : 	float		adj[MAXSTUDIOCONTROLLERS];
; 364  : 	float		s;
; 365  : 
; 366  : 	// bah, fix this bug with changing sequences too fast
; 367  : 	if( f > pseqdesc->numframes - 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _f$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Mod_Studio

; 368  : 	{
; 369  : 		f = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 370  : 	}

	jmp	SHORT $LN7@Mod_Studio
$LN5@Mod_Studio:

; 371  : 	else if( f < -0.01f )

	movss	xmm0, DWORD PTR __real@bc23d70a
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN7@Mod_Studio

; 372  : 	{
; 373  : 		// BUG ( somewhere else ) but this code should validate this data.
; 374  : 		// This could cause a crash if the frame # is negative, so we'll go ahead
; 375  : 		// and clamp it here
; 376  : 		f = -0.01f;

	movss	xmm0, DWORD PTR __real@bc23d70a
	movss	DWORD PTR _f$[ebp], xmm0
$LN7@Mod_Studio:

; 377  : 	}
; 378  : 
; 379  : 	frame = (int)f;

	cvttss2si eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _frame$[ebp], eax

; 380  : 	s = (f - frame);

	cvtsi2ss xmm0, DWORD PTR _frame$[ebp]
	movss	xmm1, DWORD PTR _f$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 381  : 
; 382  : 	// add in programtic controllers
; 383  : 	pbone = (mstudiobone_t *)((byte *)mod_studiohdr + mod_studiohdr->boneindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbone$[ebp], ecx

; 384  : 
; 385  : 	Mod_StudioCalcBoneAdj( adj, pcontroller );

	mov	eax, DWORD PTR _pcontroller$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	call	_Mod_StudioCalcBoneAdj
	add	esp, 8

; 386  : 
; 387  : 	for( j = numbones - 1; j >= 0; j-- )

	mov	eax, DWORD PTR _numbones$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@Mod_Studio:
	cmp	DWORD PTR _j$[ebp], 0
	jl	SHORT $LN3@Mod_Studio

; 388  : 	{
; 389  : 		i = boneused[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _boneused$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _i$[ebp], edx

; 390  : 		R_StudioCalcBoneQuaternion( frame, s, &pbone[i], &panim[i], adj, q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _panim$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 112
	add	eax, DWORD PTR _pbone$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_R_StudioCalcBoneQuaternion
	add	esp, 24					; 00000018H

; 391  : 		R_StudioCalcBonePosition( frame, s, &pbone[i], &panim[i], adj, pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _panim$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 112
	add	eax, DWORD PTR _pbone$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_R_StudioCalcBonePosition
	add	esp, 24					; 00000018H

; 392  : 	}

	jmp	$LN2@Mod_Studio
$LN3@Mod_Studio:

; 393  : 
; 394  : 	if( pseqdesc->motiontype & STUDIO_X ) pos[pseqdesc->motionbone][0] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 1
	je	SHORT $LN8@Mod_Studio
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
$LN8@Mod_Studio:

; 395  : 	if( pseqdesc->motiontype & STUDIO_Y ) pos[pseqdesc->motionbone][1] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 2
	je	SHORT $LN9@Mod_Studio
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
$LN9@Mod_Studio:

; 396  : 	if( pseqdesc->motiontype & STUDIO_Z ) pos[pseqdesc->motionbone][2] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 4
	je	SHORT $LN10@Mod_Studio
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
$LN10@Mod_Studio:

; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioCalcRotations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioCalcBoneAdj
_TEXT	SEGMENT
tv128 = -88						; size = 4
tv144 = -84						; size = 4
tv95 = -84						; size = 4
_pbonecontroller$ = -16					; size = 4
_value$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_adj$ = 8						; size = 4
_pcontroller$ = 12					; size = 4
_Mod_StudioCalcBoneAdj PROC				; COMDAT

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 309  : 	int			i, j;
; 310  : 	float			value;
; 311  : 	mstudiobonecontroller_t	*pbonecontroller;
; 312  : 	
; 313  : 	pbonecontroller = (mstudiobonecontroller_t *)((byte *)mod_studiohdr + mod_studiohdr->bonecontrollerindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR _pbonecontroller$[ebp], ecx

; 314  : 
; 315  : 	for( j = 0; j < mod_studiohdr->numbonecontrollers; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	$LN3@Mod_Studio

; 316  : 	{
; 317  : 		i = pbonecontroller[j].index;

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _i$[ebp], edx

; 318  : 
; 319  : 		if( i == STUDIO_MOUTH )

	cmp	DWORD PTR _i$[ebp], 4
	jne	SHORT $LN7@Mod_Studio

; 320  : 			continue; // ignore mouth

	jmp	SHORT $LN2@Mod_Studio
$LN7@Mod_Studio:

; 321  : 
; 322  : 		if( i <= MAXSTUDIOCONTROLLERS )

	cmp	DWORD PTR _i$[ebp], 8
	jg	$LN10@Mod_Studio

; 323  : 		{
; 324  : 			// check for 360% wrapping
; 325  : 			if( pbonecontroller[j].type & STUDIO_RLOOP )

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 32768				; 00008000H
	je	SHORT $LN9@Mod_Studio

; 326  : 			{
; 327  : 				value = pcontroller[i] * (360.0f / 256.0f) + pbonecontroller[j].start;

	mov	eax, DWORD PTR _pcontroller$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3fb40000
	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	addss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR _value$[ebp], xmm0

; 328  : 			}

	jmp	$LN10@Mod_Studio
$LN9@Mod_Studio:

; 329  : 			else 
; 330  : 			{
; 331  : 				value = pcontroller[i] / 255.0f;

	mov	eax, DWORD PTR _pcontroller$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _value$[ebp], xmm0

; 332  : 				value = bound( 0.0f, value, 1.0f );

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN20@Mod_Studio
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _value$[ebp]
	jbe	SHORT $LN18@Mod_Studio
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN19@Mod_Studio
$LN18@Mod_Studio:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv95[ebp], xmm0
$LN19@Mod_Studio:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN21@Mod_Studio
$LN20@Mod_Studio:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv128[ebp], xmm0
$LN21@Mod_Studio:
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 333  : 				value = (1.0f - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _value$[ebp]
	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+8]
	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	movss	xmm1, DWORD PTR _value$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _value$[ebp], xmm0
$LN10@Mod_Studio:

; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		switch( pbonecontroller[j].type & STUDIO_TYPES )

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 32767				; 00007fffH
	mov	DWORD PTR tv144[ebp], edx
	mov	eax, DWORD PTR tv144[ebp]
	sub	eax, 1
	mov	DWORD PTR tv144[ebp], eax
	cmp	DWORD PTR tv144[ebp], 31		; 0000001fH
	ja	SHORT $LN5@Mod_Studio
	mov	ecx, DWORD PTR tv144[ebp]
	movzx	edx, BYTE PTR $LN22@Mod_Studio[ecx]
	jmp	DWORD PTR $LN23@Mod_Studio[edx*4]
$LN11@Mod_Studio:

; 338  : 		{
; 339  : 		case STUDIO_XR:
; 340  : 		case STUDIO_YR:
; 341  : 		case STUDIO_ZR:
; 342  : 			adj[j] = value * (M_PI / 180.0f);

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 343  : 			break;

	jmp	SHORT $LN5@Mod_Studio
$LN14@Mod_Studio:

; 344  : 		case STUDIO_X:
; 345  : 		case STUDIO_Y:
; 346  : 		case STUDIO_Z:
; 347  : 			adj[j] = value;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN5@Mod_Studio:

; 348  : 			break;
; 349  : 		}
; 350  : 	}

	jmp	$LN2@Mod_Studio
$LN3@Mod_Studio:

; 351  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN23@Mod_Studio:
	DD	$LN14@Mod_Studio
	DD	$LN11@Mod_Studio
	DD	$LN5@Mod_Studio
$LN22@Mod_Studio:
	DB	0
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_Mod_StudioCalcBoneAdj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_SetStudioHullPlane
_TEXT	SEGMENT
tv334 = -108						; size = 8
tv302 = -108						; size = 8
tv344 = -100						; size = 8
tv340 = -100						; size = 8
tv324 = -92						; size = 8
tv292 = -92						; size = 8
tv342 = -84						; size = 8
tv338 = -84						; size = 8
tv314 = -76						; size = 8
tv282 = -76						; size = 8
_pl$ = -4						; size = 4
_planenum$ = 8						; size = 4
_bone$ = 12						; size = 4
_axis$ = 16						; size = 4
_offset$ = 20						; size = 4
_size$ = 24						; size = 4
_Mod_SetStudioHullPlane PROC				; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 208  : 	mplane_t	*pl = &studio_planes[planenum];

	imul	eax, DWORD PTR _planenum$[ebp], 20
	add	eax, OFFSET _studio_planes
	mov	DWORD PTR _pl$[ebp], eax

; 209  : 
; 210  : 	pl->type = 5;

	mov	eax, DWORD PTR _pl$[ebp]
	mov	BYTE PTR [eax+16], 5

; 211  : 
; 212  : 	pl->normal[0] = studio_bones[bone][0][axis];

	imul	eax, DWORD PTR _bone$[ebp], 48
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _studio_bones[eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx], eax

; 213  : 	pl->normal[1] = studio_bones[bone][1][axis];

	imul	eax, DWORD PTR _bone$[ebp], 48
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _studio_bones[eax+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax], edx

; 214  : 	pl->normal[2] = studio_bones[bone][2][axis];

	imul	eax, DWORD PTR _bone$[ebp], 48
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _studio_bones[eax+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax], edx

; 215  : 
; 216  : 	pl->dist = (pl->normal[0] * studio_bones[bone][0][3]) + (pl->normal[1] * studio_bones[bone][1][3]) + (pl->normal[2] * studio_bones[bone][2][3]) + offset;

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 217  : 
; 218  : 	if( planenum & 1 ) pl->dist -= DotProductFabs( pl->normal, size );

	mov	eax, DWORD PTR _planenum$[ebp]
	and	eax, 1
	je	$LN2@Mod_SetStu
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv282[ebp]
	movsd	xmm0, QWORD PTR tv282[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv338[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv292[ebp]
	movsd	xmm0, QWORD PTR tv338[ebp]
	addsd	xmm0, QWORD PTR tv292[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv340[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv302[ebp]
	movsd	xmm0, QWORD PTR tv340[ebp]
	addsd	xmm0, QWORD PTR tv302[ebp]
	mov	eax, DWORD PTR _pl$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+12]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	ecx, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	jmp	$LN3@Mod_SetStu
$LN2@Mod_SetStu:

; 219  : 	else pl->dist += DotProductFabs( pl->normal, size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv314[ebp]
	movsd	xmm0, QWORD PTR tv314[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv342[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv324[ebp]
	movsd	xmm0, QWORD PTR tv342[ebp]
	addsd	xmm0, QWORD PTR tv324[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv344[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv334[ebp]
	movsd	xmm0, QWORD PTR tv344[ebp]
	addsd	xmm0, QWORD PTR tv334[ebp]
	mov	eax, DWORD PTR _pl$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+12]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	ecx, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
$LN3@Mod_SetStu:

; 220  : 
; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetStudioHullPlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_CheckStudioCache
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pCached$ = -4						; size = 4
_model$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_size$ = 28						; size = 4
_controller$ = 32					; size = 4
_blending$ = 36						; size = 4
_Mod_CheckStudioCache PROC				; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 157  : 	mstudiocache_t	*pCached;
; 158  : 	int		i;
; 159  : 
; 160  : 	for( i = 0; i < STUDIO_CACHESIZE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CheckS
$LN2@Mod_CheckS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_CheckS:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN3@Mod_CheckS

; 161  : 	{
; 162  : 		pCached = &cache_studio[(cache_current - i) & STUDIO_CACHEMASK];

	mov	eax, DWORD PTR _cache_current
	sub	eax, DWORD PTR _i$[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, eax, 68
	add	ecx, OFFSET _cache_studio
	mov	DWORD PTR _pCached$[ebp], ecx

; 163  : 
; 164  : 		if( pCached->model != model )

	mov	eax, DWORD PTR _pCached$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR _model$[ebp]
	je	SHORT $LN5@Mod_CheckS

; 165  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN5@Mod_CheckS:

; 166  : 
; 167  : 		if( pCached->frame != frame )

	mov	eax, DWORD PTR _pCached$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR _frame$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@Mod_CheckS

; 168  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN6@Mod_CheckS:

; 169  : 
; 170  : 		if( pCached->sequence != sequence )

	mov	eax, DWORD PTR _pCached$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _sequence$[ebp]
	je	SHORT $LN7@Mod_CheckS

; 171  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN7@Mod_CheckS:

; 172  : 
; 173  : 		if( !VectorCompare( pCached->angles, angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@Mod_CheckS
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+8]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@Mod_CheckS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+8]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@Mod_CheckS
$LN9@Mod_CheckS:

; 174  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN8@Mod_CheckS:

; 175  : 
; 176  : 		if( !VectorCompare( pCached->origin, origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_CheckS
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_CheckS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@Mod_CheckS
$LN11@Mod_CheckS:

; 177  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN10@Mod_CheckS:

; 178  : 
; 179  : 		if( !VectorCompare( pCached->size, size ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+32]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_CheckS
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+32]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_CheckS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+32]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@Mod_CheckS
$LN13@Mod_CheckS:

; 180  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN12@Mod_CheckS:

; 181  : 
; 182  : 		if( memcmp( pCached->controller, controller, 4 ) != 0 )

	push	4
	mov	eax, DWORD PTR _controller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCached$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@Mod_CheckS

; 183  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN14@Mod_CheckS:

; 184  : 
; 185  : 		if( memcmp( pCached->blending, blending, 2 ) != 0 )

	push	2
	mov	eax, DWORD PTR _blending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCached$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@Mod_CheckS

; 186  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN15@Mod_CheckS:

; 187  : 
; 188  : 		return pCached;

	mov	eax, DWORD PTR _pCached$[ebp]
	jmp	SHORT $LN1@Mod_CheckS

; 189  : 	}

	jmp	$LN2@Mod_CheckS
$LN3@Mod_CheckS:

; 190  : 
; 191  : 	return NULL;

	xor	eax, eax
$LN1@Mod_CheckS:

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_AddToStudioCache
_TEXT	SEGMENT
_pCache$ = -4						; size = 4
_frame$ = 8						; size = 4
_sequence$ = 12						; size = 4
_angles$ = 16						; size = 4
_origin$ = 20						; size = 4
_size$ = 24						; size = 4
_pcontroller$ = 28					; size = 4
_pblending$ = 32					; size = 4
_model$ = 36						; size = 4
_hull$ = 40						; size = 4
_numhitboxes$ = 44					; size = 4
_Mod_AddToStudioCache PROC				; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 120  : 	mstudiocache_t *pCache;
; 121  : 
; 122  : 	if( numhitboxes + cache_current_hull >= MAXSTUDIOBONES )

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	add	eax, DWORD PTR _cache_current_hull
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN2@Mod_AddToS

; 123  : 		Mod_ClearStudioCache();

	call	_Mod_ClearStudioCache
$LN2@Mod_AddToS:

; 124  : 
; 125  : 	cache_current++;

	mov	eax, DWORD PTR _cache_current
	add	eax, 1
	mov	DWORD PTR _cache_current, eax

; 126  : 	pCache = &cache_studio[cache_current & STUDIO_CACHEMASK];

	mov	eax, DWORD PTR _cache_current
	and	eax, 15					; 0000000fH
	imul	ecx, eax, 68
	add	ecx, OFFSET _cache_studio
	mov	DWORD PTR _pCache$[ebp], ecx

; 127  : 
; 128  : 	pCache->frame = frame;

	mov	eax, DWORD PTR _pCache$[ebp]
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax], xmm0

; 129  : 	pCache->sequence = sequence;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _sequence$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 130  : 	VectorCopy( angles, pCache->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+8], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+8], eax

; 131  : 	VectorCopy( origin, pCache->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 132  : 	VectorCopy( size, pCache->size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+32], eax

; 133  : 
; 134  : 	memcpy( pCache->controller, pcontroller, 4 );

	push	4
	mov	eax, DWORD PTR _pcontroller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCache$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 135  : 	memcpy( pCache->blending, pblending, 2 );

	push	2
	mov	eax, DWORD PTR _pblending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCache$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 136  : 
; 137  : 	pCache->model = model;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 138  : 	pCache->current_hull = cache_current_hull;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _cache_current_hull
	mov	DWORD PTR [eax+56], ecx

; 139  : 	pCache->current_plane = cache_current_plane;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _cache_current_plane
	mov	DWORD PTR [eax+60], ecx

; 140  : 
; 141  : 	memcpy( &cache_hull[cache_current_hull], hull, numhitboxes * sizeof( hull_t ));

	imul	eax, DWORD PTR _numhitboxes$[ebp], 40
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	imul	edx, DWORD PTR _cache_current_hull, 40
	add	edx, OFFSET _cache_hull
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 142  : 	memcpy( &cache_planes[cache_current_plane], studio_planes, numhitboxes * sizeof( mplane_t ) * 6 );

	imul	eax, DWORD PTR _numhitboxes$[ebp], 20
	imul	ecx, eax, 6
	push	ecx
	push	OFFSET _studio_planes
	imul	edx, DWORD PTR _cache_current_plane, 20
	add	edx, OFFSET _cache_planes
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 143  : 	memcpy( &cache_hull_hitgroup[cache_current_hull], studio_hull_hitgroup, numhitboxes * sizeof( uint ));

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	shl	eax, 2
	push	eax
	push	OFFSET _studio_hull_hitgroup
	mov	ecx, DWORD PTR _cache_current_hull
	lea	edx, DWORD PTR _cache_hull_hitgroup[ecx*4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 144  : 
; 145  : 	cache_current_hull += numhitboxes;

	mov	eax, DWORD PTR _cache_current_hull
	add	eax, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR _cache_current_hull, eax

; 146  : 	cache_current_plane += numhitboxes * 6;

	imul	eax, DWORD PTR _numhitboxes$[ebp], 6
	add	eax, DWORD PTR _cache_current_plane
	mov	DWORD PTR _cache_current_plane, eax

; 147  : 	pCache->numhitboxes = numhitboxes;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_AddToStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_ClearStudioCache
_TEXT	SEGMENT
_Mod_ClearStudioCache PROC				; COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 107  : 	memset( cache_studio, 0, sizeof( cache_studio ));

	push	1088					; 00000440H
	push	0
	push	OFFSET _cache_studio
	call	_memset
	add	esp, 12					; 0000000cH

; 108  : 	cache_current_hull = cache_current_plane = 0;

	mov	DWORD PTR _cache_current_plane, 0
	mov	eax, DWORD PTR _cache_current_plane
	mov	DWORD PTR _cache_current_hull, eax

; 109  : 
; 110  : 	cache_current = 0;

	mov	DWORD PTR _cache_current, 0

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ClearStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_HitgroupForStudioHull
_TEXT	SEGMENT
_index$ = 8						; size = 4
_Mod_HitgroupForStudioHull PROC				; COMDAT

; 577  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 578  : 	return studio_hull_hitgroup[index];

	mov	eax, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _studio_hull_hitgroup[eax*4]

; 579  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_HitgroupForStudioHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioComputeBounds
_TEXT	SEGMENT
tv153 = -192						; size = 4
_pverts$ = -124						; size = 4
_pos$ = -120						; size = 12
_bodyCount$ = -108					; size = 4
_bone_count$ = -104					; size = 4
_vert_count$ = -100					; size = 4
_vert_maxs$ = -96					; size = 12
_vert_mins$ = -84					; size = 12
_bone_maxs$ = -72					; size = 12
_bone_mins$ = -60					; size = 12
_panim$ = -48						; size = 4
_pbones$ = -44						; size = 4
_pseqdesc$ = -40					; size = 4
_pseqgroup$ = -36					; size = 4
_m_pSubModel$ = -32					; size = 4
_pbodypart$ = -28					; size = 4
_pstudiohdr$ = -24					; size = 4
_numseq$ = -20						; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_ignore_sequences$ = 20					; size = 4
_Mod_StudioComputeBounds PROC				; COMDAT

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 626  : 	int		i, j, k, numseq;
; 627  : 	studiohdr_t	*pstudiohdr;
; 628  : 	mstudiobodyparts_t	*pbodypart;
; 629  : 	mstudiomodel_t	*m_pSubModel;
; 630  : 	mstudioseqgroup_t	*pseqgroup;
; 631  : 	mstudioseqdesc_t	*pseqdesc;
; 632  : 	mstudiobone_t	*pbones;
; 633  : 	mstudioanim_t	*panim;
; 634  : 	vec3_t		bone_mins, bone_maxs;
; 635  : 	vec3_t		vert_mins, vert_maxs;
; 636  : 	int		vert_count, bone_count;
; 637  : 	int		bodyCount = 0;

	mov	DWORD PTR _bodyCount$[ebp], 0

; 638  : 	vec3_t		pos, *pverts;
; 639  : 
; 640  : 	vert_count = bone_count = 0;

	mov	DWORD PTR _bone_count$[ebp], 0
	mov	eax, DWORD PTR _bone_count$[ebp]
	mov	DWORD PTR _vert_count$[ebp], eax

; 641  : 	VectorClear( bone_mins );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+eax], xmm0

; 642  : 	VectorClear( bone_maxs );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+eax], xmm0

; 643  : 	VectorClear( vert_mins );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+eax], xmm0

; 644  : 	VectorClear( vert_maxs );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+eax], xmm0

; 645  : 
; 646  : 	// Get the body part portion of the model
; 647  : 	pstudiohdr = (studiohdr_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pstudiohdr$[ebp], eax

; 648  : 	pbodypart = (mstudiobodyparts_t *)((byte *)pstudiohdr + pstudiohdr->bodypartindex);

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _pbodypart$[ebp], ecx

; 649  : 
; 650  : 	// each body part has nummodels variations so there are as many total variations as there
; 651  : 	// are in a matrix of each part by each other part
; 652  : 	for( i = 0; i < pstudiohdr->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+204]
	jge	SHORT $LN3@Mod_Studio

; 653  : 		bodyCount += pbodypart[i].nummodels;

	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR _bodyCount$[ebp]
	add	edx, DWORD PTR [ecx+eax+64]
	mov	DWORD PTR _bodyCount$[ebp], edx
	jmp	SHORT $LN2@Mod_Studio
$LN3@Mod_Studio:

; 654  : 
; 655  : 	// The studio models we want are vec3_t mins, vec3_t maxsight after the bodyparts (still need to
; 656  : 	// find a detailed breakdown of the mdl format).  Move pointer there.
; 657  : 	m_pSubModel = (mstudiomodel_t *)(&pbodypart[pstudiohdr->numbodyparts]);

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	imul	ecx, DWORD PTR [eax+204], 76
	add	ecx, DWORD PTR _pbodypart$[ebp]
	mov	DWORD PTR _m_pSubModel$[ebp], ecx

; 658  : 
; 659  : 	for( i = 0; i < bodyCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_Studio
$LN5@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bodyCount$[ebp]
	jge	SHORT $LN6@Mod_Studio

; 660  : 	{
; 661  : 		pverts = (vec3_t *)((byte *)pstudiohdr + m_pSubModel[i].vertindex);

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	mov	edx, DWORD PTR _pstudiohdr$[ebp]
	add	edx, DWORD PTR [ecx+eax+88]
	mov	DWORD PTR _pverts$[ebp], edx

; 662  : 
; 663  : 		for( j = 0; j < m_pSubModel[i].numverts; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_Studio
$LN8@Mod_Studio:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_Studio:
	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+80]
	jge	SHORT $LN9@Mod_Studio

; 664  : 			Mod_StudioBoundVertex( bone_mins, bone_maxs, &vert_count, pverts[j] );

	imul	eax, DWORD PTR _j$[ebp], 12
	add	eax, DWORD PTR _pverts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vert_count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bone_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _bone_mins$[ebp]
	push	eax
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H
	jmp	SHORT $LN8@Mod_Studio
$LN9@Mod_Studio:

; 665  : 	}

	jmp	SHORT $LN5@Mod_Studio
$LN6@Mod_Studio:

; 666  : 
; 667  : 	pbones = (mstudiobone_t *)((byte *)pstudiohdr + pstudiohdr->boneindex);

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 668  : 	numseq = (ignore_sequences) ? 1 : pstudiohdr->numseq;

	cmp	DWORD PTR _ignore_sequences$[ebp], 0
	je	SHORT $LN23@Mod_Studio
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN24@Mod_Studio
$LN23@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR tv153[ebp], ecx
$LN24@Mod_Studio:
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR _numseq$[ebp], edx

; 669  : 
; 670  : 	for( i = 0; i < numseq; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Mod_Studio
$LN11@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numseq$[ebp]
	jge	$LN12@Mod_Studio

; 671  : 	{
; 672  : 		pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + i;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _i$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 673  : 		pseqgroup = (mstudioseqgroup_t *)((byte *)pstudiohdr + pstudiohdr->seqgroupindex) + pseqdesc->seqgroup;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	imul	eax, DWORD PTR [edx+156], 104
	add	ecx, eax
	mov	DWORD PTR _pseqgroup$[ebp], ecx

; 674  : 
; 675  : 		if( pseqdesc->seqgroup == 0 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jne	SHORT $LN20@Mod_Studio

; 676  : 			panim = (mstudioanim_t *)((byte *)pstudiohdr + pseqgroup->data + pseqdesc->animindex);

	mov	eax, DWORD PTR _pseqgroup$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	ecx, DWORD PTR [edx+124]
	mov	DWORD PTR _panim$[ebp], ecx
	jmp	SHORT $LN21@Mod_Studio
$LN20@Mod_Studio:

; 677  : 		else continue;

	jmp	SHORT $LN11@Mod_Studio
$LN21@Mod_Studio:

; 678  : 
; 679  : 		for( j = 0; j < pstudiohdr->numbones; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_Studio
$LN14@Mod_Studio:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN15@Mod_Studio

; 680  : 		{
; 681  : 			for( k = 0; k < pseqdesc->numframes; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN19@Mod_Studio
$LN17@Mod_Studio:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN19@Mod_Studio:
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $LN18@Mod_Studio

; 682  : 			{
; 683  : 				R_StudioCalcBonePosition( k, 0, &pbones[j], panim, NULL, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	imul	edx, DWORD PTR _j$[ebp], 112
	add	edx, DWORD PTR _pbones$[ebp]
	push	edx
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_R_StudioCalcBonePosition
	add	esp, 24					; 00000018H

; 684  : 				Mod_StudioBoundVertex( vert_mins, vert_maxs, &bone_count, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bone_count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vert_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _vert_mins$[ebp]
	push	eax
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H

; 685  : 			}

	jmp	SHORT $LN17@Mod_Studio
$LN18@Mod_Studio:

; 686  : 		}

	jmp	SHORT $LN14@Mod_Studio
$LN15@Mod_Studio:

; 687  : 
; 688  : 		Mod_StudioAccumulateBoneVerts( bone_mins, bone_maxs, &vert_count, vert_mins, vert_maxs, &bone_count );

	lea	eax, DWORD PTR _bone_count$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vert_maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vert_mins$[ebp]
	push	edx
	lea	eax, DWORD PTR _vert_count$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bone_maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bone_mins$[ebp]
	push	edx
	call	_Mod_StudioAccumulateBoneVerts
	add	esp, 24					; 00000018H

; 689  : 	}

	jmp	$LN11@Mod_Studio
$LN12@Mod_Studio:

; 690  : 
; 691  : 	VectorCopy( bone_mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _bone_mins$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _bone_mins$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR _bone_mins$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax

; 692  : 	VectorCopy( bone_maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _bone_maxs$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _bone_maxs$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR _bone_maxs$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax

; 693  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioComputeBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_HullForStudio
_TEXT	SEGMENT
tv274 = -104						; size = 4
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_bSkipShield$ = -28					; size = 4
_phitbox$ = -24						; size = 4
_bonecache$ = -20					; size = 4
_angles2$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_size$ = 28						; size = 4
_pcontroller$ = 32					; size = 4
_pblending$ = 36					; size = 4
_numhitboxes$ = 40					; size = 4
_pEdict$ = 44						; size = 4
_Mod_HullForStudio PROC					; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 232  : 	vec3_t		angles2;
; 233  : 	mstudiocache_t	*bonecache;
; 234  : 	mstudiobbox_t	*phitbox;
; 235  : 	qboolean		bSkipShield;
; 236  : 	int		i, j;
; 237  : 
; 238  : 	bSkipShield = false;

	mov	DWORD PTR _bSkipShield$[ebp], 0

; 239  : 	*numhitboxes = 0; // assume error

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [eax], 0

; 240  : 
; 241  : 	if( mod_studiocache->value )

	mov	eax, DWORD PTR _mod_studiocache
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@Mod_HullFo

; 242  : 	{
; 243  : 		bonecache = Mod_CheckStudioCache( model, frame, sequence, angles, origin, size, pcontroller, pblending );

	mov	eax, DWORD PTR _pblending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcontroller$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sequence$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_Mod_CheckStudioCache
	add	esp, 32					; 00000020H
	mov	DWORD PTR _bonecache$[ebp], eax

; 244  : 
; 245  : 		if( bonecache != NULL )

	cmp	DWORD PTR _bonecache$[ebp], 0
	je	$LN6@Mod_HullFo

; 246  : 		{
; 247  : 			memcpy( studio_planes, &cache_planes[bonecache->current_plane], bonecache->numhitboxes * sizeof( mplane_t ) * 6 );

	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+64], 20
	imul	edx, ecx, 6
	push	edx
	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+60], 20
	add	ecx, OFFSET _cache_planes
	push	ecx
	push	OFFSET _studio_planes
	call	_memcpy
	add	esp, 12					; 0000000cH

; 248  : 			memcpy( studio_hull_hitgroup, &cache_hull_hitgroup[bonecache->current_hull], bonecache->numhitboxes * sizeof( uint ));

	mov	eax, DWORD PTR _bonecache$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _bonecache$[ebp]
	mov	eax, DWORD PTR [edx+56]
	lea	ecx, DWORD PTR _cache_hull_hitgroup[eax*4]
	push	ecx
	push	OFFSET _studio_hull_hitgroup
	call	_memcpy
	add	esp, 12					; 0000000cH

; 249  : 			memcpy( studio_hull, &cache_hull[bonecache->current_hull], bonecache->numhitboxes * sizeof( hull_t ));

	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+64], 40
	push	ecx
	mov	edx, DWORD PTR _bonecache$[ebp]
	imul	eax, DWORD PTR [edx+56], 40
	add	eax, OFFSET _cache_hull
	push	eax
	push	OFFSET _studio_hull
	call	_memcpy
	add	esp, 12					; 0000000cH

; 250  : 
; 251  : 			*numhitboxes = bonecache->numhitboxes;

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	ecx, DWORD PTR _bonecache$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax], edx

; 252  : 			return studio_hull;

	mov	eax, OFFSET _studio_hull
	jmp	$LN1@Mod_HullFo
$LN6@Mod_HullFo:

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	mod_studiohdr = Mod_StudioExtradata( model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 257  : 	if( !mod_studiohdr ) return NULL; // probably not a studiomodel

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN7@Mod_HullFo
	xor	eax, eax
	jmp	$LN1@Mod_HullFo
$LN7@Mod_HullFo:

; 258  : 
; 259  : 	VectorCopy( angles, angles2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _angles2$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _angles2$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _angles2$[ebp+ecx], eax

; 260  : 
; 261  : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN8@Mod_HullFo

; 262  : 		angles2[PITCH] = -angles2[PITCH]; // stupid quake bug

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _angles2$[ebp+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _angles2$[ebp+eax], xmm0
$LN8@Mod_HullFo:

; 263  : 
; 264  : 	pBlendAPI->SV_StudioSetupBones( model, frame, sequence, angles2, origin, pcontroller, pblending, -1, pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _pblending$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sequence$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlendAPI
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 36					; 00000024H

; 265  : 	phitbox = (mstudiobbox_t *)((byte *)mod_studiohdr + mod_studiohdr->hitboxindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _phitbox$[ebp], ecx

; 266  : 
; 267  : 	if( SV_IsValidEdict( pEdict ) && pEdict->v.gamestate == 1 )

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_HullForStudio@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@Mod_HullFo
	mov	eax, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [eax+792], 1
	jne	SHORT $LN9@Mod_HullFo

; 268  : 		bSkipShield = 1;

	mov	DWORD PTR _bSkipShield$[ebp], 1
$LN9@Mod_HullFo:

; 269  : 	
; 270  : 	for( i = j = 0; i < mod_studiohdr->numhitboxes; i++, j += 6 )

	mov	DWORD PTR _j$[ebp], 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Mod_HullFo
$LN2@Mod_HullFo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 6
	mov	DWORD PTR _j$[ebp], ecx
$LN4@Mod_HullFo:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+156]
	jge	$LN3@Mod_HullFo

; 271  : 	{
; 272  : 		if( bSkipShield && i == 21 )

	cmp	DWORD PTR _bSkipShield$[ebp], 0
	je	SHORT $LN10@Mod_HullFo
	cmp	DWORD PTR _i$[ebp], 21			; 00000015H
	jne	SHORT $LN10@Mod_HullFo

; 273  : 			continue;	// CS stuff

	jmp	SHORT $LN2@Mod_HullFo
$LN10@Mod_HullFo:

; 274  : 
; 275  : 		studio_hull_hitgroup[i] = phitbox[i].group;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _studio_hull_hitgroup[ecx*4], eax

; 276  : 
; 277  : 		Mod_SetStudioHullPlane( j + 0, phitbox[i].bone, 0, phitbox[i].bbmax[0], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+20]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 278  : 		Mod_SetStudioHullPlane( j + 1, phitbox[i].bone, 0, phitbox[i].bbmin[0], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	push	ecx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 279  : 		Mod_SetStudioHullPlane( j + 2, phitbox[i].bone, 1, phitbox[i].bbmax[1], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+20]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 2
	push	eax
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 280  : 		Mod_SetStudioHullPlane( j + 3, phitbox[i].bone, 1, phitbox[i].bbmin[1], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+8]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	push	eax
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 281  : 		Mod_SetStudioHullPlane( j + 4, phitbox[i].bone, 2, phitbox[i].bbmax[2], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	shl	edx, 1
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+20]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	push	eax
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 282  : 		Mod_SetStudioHullPlane( j + 5, phitbox[i].bone, 2, phitbox[i].bbmin[2], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	shl	edx, 1
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+8]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 5
	push	eax
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 283  : 	}

	jmp	$LN2@Mod_HullFo
$LN3@Mod_HullFo:

; 284  : 
; 285  : 	// tell trace code about hitbox count
; 286  : 	*numhitboxes = (bSkipShield) ? (mod_studiohdr->numhitboxes - 1) : (mod_studiohdr->numhitboxes);

	cmp	DWORD PTR _bSkipShield$[ebp], 0
	je	SHORT $LN13@Mod_HullFo
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	DWORD PTR tv274[ebp], ecx
	jmp	SHORT $LN14@Mod_HullFo
$LN13@Mod_HullFo:
	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR tv274[ebp], eax
$LN14@Mod_HullFo:
	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	mov	edx, DWORD PTR tv274[ebp]
	mov	DWORD PTR [ecx], edx

; 287  : 
; 288  : 	if( mod_studiocache->value )

	mov	eax, DWORD PTR _mod_studiocache
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@Mod_HullFo

; 289  : 		Mod_AddToStudioCache( frame, sequence, angles, origin, size, pcontroller, pblending, model, studio_hull, *numhitboxes );

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET _studio_hull
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	mov	eax, DWORD PTR _pblending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcontroller$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sequence$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_Mod_AddToStudioCache
	add	esp, 40					; 00000028H
$LN11@Mod_HullFo:

; 290  : 
; 291  : 	return studio_hull;

	mov	eax, OFFSET _studio_hull
$LN1@Mod_HullFo:

; 292  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_HullForStudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_GetBonePosition
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_e$ = 8							; size = 4
_iBone$ = 12						; size = 4
_origin$ = 16						; size = 4
_angles$ = 20						; size = 4
_Mod_GetBonePosition PROC				; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 559  : 	model_t	*mod;
; 560  : 
; 561  : 	mod = SV_ModelHandle( e->v.modelindex );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 562  : 	mod_studiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 563  : 	if( !mod_studiohdr ) return;

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN2@Mod_GetBon
	jmp	$LN4@Mod_GetBon
$LN2@Mod_GetBon:

; 564  : 
; 565  : 	pBlendAPI->SV_StudioSetupBones( mod, e->v.frame, e->v.sequence, e->v.angles, e->v.origin, e->v.controller, e->v.blending, iBone, e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBone$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 488				; 000001e8H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 484				; 000001e4H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+472]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlendAPI
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 36					; 00000024H

; 566  : 
; 567  : 	if( origin ) Matrix3x4_OriginFromMatrix( studio_bones[iBone], origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN3@Mod_GetBon
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	imul	ecx, DWORD PTR _iBone$[ebp], 48
	add	ecx, OFFSET _studio_bones
	push	ecx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8
$LN3@Mod_GetBon:

; 568  : 	if( angles ) VectorAngles( studio_bones[iBone][0], angles ); // bone forward to angles

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN4@Mod_GetBon
	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	imul	ecx, DWORD PTR _iBone$[ebp], 48
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _studio_bones[ecx+eax]
	push	ecx
	call	_VectorAngles
	add	esp, 8
$LN4@Mod_GetBon:

; 569  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetBonePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioGetAttachment
_TEXT	SEGMENT
tv145 = -124						; size = 4
tv225 = -120						; size = 4
tv144 = -120						; size = 4
_ilength$1 = -52					; size = 4
_bonepos$2 = -48					; size = 12
_forward$3 = -36					; size = 12
_mod$ = -24						; size = 4
_angles2$ = -20						; size = 12
_pAtt$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_iAtt$ = 12						; size = 4
_origin$ = 16						; size = 4
_angles$ = 20						; size = 4
_Mod_StudioGetAttachment PROC				; COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 508  : 	mstudioattachment_t		*pAtt;
; 509  : 	vec3_t			angles2;
; 510  : 	model_t			*mod;
; 511  : 
; 512  : 	mod = SV_ModelHandle( e->v.modelindex );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 513  : 	mod_studiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 514  : 	if( !mod_studiohdr ) return;

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN2@Mod_Studio
	jmp	$LN8@Mod_Studio
$LN2@Mod_Studio:

; 515  : 
; 516  : 	if( mod_studiohdr->numattachments <= 0 )

	mov	eax, DWORD PTR _mod_studiohdr
	cmp	DWORD PTR [eax+212], 0
	jg	$LN3@Mod_Studio

; 517  : 	{
; 518  : 		if( origin ) VectorCopy( e->v.origin, origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN4@Mod_Studio
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx], eax
$LN4@Mod_Studio:

; 519  : 
; 520  : 		if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ) && angles )

	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	je	SHORT $LN5@Mod_Studio
	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN5@Mod_Studio

; 521  : 			VectorCopy( e->v.angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx], eax
$LN5@Mod_Studio:

; 522  : 		return;

	jmp	$LN8@Mod_Studio
$LN3@Mod_Studio:

; 523  : 	}
; 524  : 
; 525  : 	iAtt = bound( 0, iAtt, mod_studiohdr->numattachments - 1 );

	cmp	DWORD PTR _iAtt$[ebp], 0
	jl	SHORT $LN12@Mod_Studio
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+212]
	sub	ecx, 1
	cmp	DWORD PTR _iAtt$[ebp], ecx
	jge	SHORT $LN10@Mod_Studio
	mov	edx, DWORD PTR _iAtt$[ebp]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN11@Mod_Studio
$LN10@Mod_Studio:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+212]
	sub	ecx, 1
	mov	DWORD PTR tv144[ebp], ecx
$LN11@Mod_Studio:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv145[ebp], edx
	jmp	SHORT $LN13@Mod_Studio
$LN12@Mod_Studio:
	mov	DWORD PTR tv145[ebp], 0
$LN13@Mod_Studio:
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR _iAtt$[ebp], eax

; 526  : 
; 527  : 	// calculate attachment origin and angles
; 528  : 	pAtt = (mstudioattachment_t *)((byte *)mod_studiohdr + mod_studiohdr->attachmentindex) + iAtt;

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+216]
	imul	edx, DWORD PTR _iAtt$[ebp], 88
	add	ecx, edx
	mov	DWORD PTR _pAtt$[ebp], ecx

; 529  : 
; 530  : 	VectorCopy( e->v.angles, angles2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _angles2$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _angles2$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _angles2$[ebp+ecx], eax

; 531  : 
; 532  : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN6@Mod_Studio

; 533  : 		angles2[PITCH] = -angles2[PITCH];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _angles2$[ebp+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _angles2$[ebp+eax], xmm0
$LN6@Mod_Studio:

; 534  : 
; 535  : 	pBlendAPI->SV_StudioSetupBones( mod, e->v.frame, e->v.sequence, angles2, e->v.origin, e->v.controller, e->v.blending, pAtt->bone, e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAtt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 488				; 000001e8H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 484				; 000001e4H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR _angles2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+472]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBlendAPI
	mov	eax, DWORD PTR [edx+4]
	call	eax
	add	esp, 36					; 00000024H

; 536  : 
; 537  : 	// compute pos and angles
; 538  : 	if( origin != NULL )

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN7@Mod_Studio

; 539  : 		Matrix3x4_VectorTransform( studio_bones[pAtt->bone], pAtt->org, origin );

	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAtt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _pAtt$[ebp]
	imul	eax, DWORD PTR [edx+36], 48
	add	eax, OFFSET _studio_bones
	push	eax
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH
$LN7@Mod_Studio:

; 540  : 
; 541  : 	if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ) && origin != NULL && angles != NULL )

	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	je	$LN8@Mod_Studio
	cmp	DWORD PTR _origin$[ebp], 0
	je	$LN8@Mod_Studio
	cmp	DWORD PTR _angles$[ebp], 0
	je	$LN8@Mod_Studio

; 542  : 	{
; 543  : 		vec3_t	forward, bonepos;
; 544  : 
; 545  : 		Matrix3x4_OriginFromMatrix( studio_bones[pAtt->bone], bonepos );

	lea	eax, DWORD PTR _bonepos$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAtt$[ebp]
	imul	edx, DWORD PTR [ecx+36], 48
	add	edx, OFFSET _studio_bones
	push	edx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 546  : 		VectorSubtract( origin, bonepos, forward ); // make forward

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _bonepos$2[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _forward$3[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _bonepos$2[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _forward$3[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _bonepos$2[ebp+ecx]
	movss	DWORD PTR tv225[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv225[ebp]
	movss	DWORD PTR _forward$3[ebp+eax], xmm0

; 547  : 		VectorNormalizeFast( forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mulss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _forward$3[ebp+ecx]
	mulss	xmm1, DWORD PTR _forward$3[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _forward$3[ebp+eax]
	mulss	xmm1, DWORD PTR _forward$3[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_rsqrt
	add	esp, 4
	fstp	DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _forward$3[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _forward$3[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _forward$3[ebp+ecx], xmm0

; 548  : 		VectorAngles( forward, angles );

	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$3[ebp]
	push	ecx
	call	_VectorAngles
	add	esp, 8
$LN8@Mod_Studio:

; 549  : 	}
; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioGetAttachment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_GetStudioBounds
_TEXT	SEGMENT
_f$ = -8						; size = 4
_result$ = -4						; size = 4
_name$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_Mod_GetStudioBounds PROC				; COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 702  : 	int	result = false;

	mov	DWORD PTR _result$[ebp], 0

; 703  : 	byte	*f;
; 704  : 
; 705  : 	if( !Q_strstr( name, "models" ) || !Q_strstr( name, ".mdl" ))

	push	OFFSET ??_C@_06FEMFHOOG@models@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@Mod_GetStu
	push	OFFSET ??_C@_04IPGPBAO@?4mdl@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@Mod_GetStu
$LN3@Mod_GetStu:

; 706  : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_GetStu
$LN2@Mod_GetStu:

; 707  : 
; 708  : 	f = FS_LoadFile( name, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 709  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@Mod_GetStu
	xor	eax, eax
	jmp	$LN1@Mod_GetStu
$LN4@Mod_GetStu:

; 710  : 
; 711  : 	if( *(uint *)f == IDSTUDIOHEADER )

	mov	eax, DWORD PTR _f$[ebp]
	cmp	DWORD PTR [eax], 1414743113		; 54534449H
	jne	$LN5@Mod_GetStu

; 712  : 	{
; 713  : 		VectorClear( mins );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 714  : 		VectorClear( maxs );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 715  : 		Mod_StudioComputeBounds( f, mins, maxs, false );

	push	0
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_Mod_StudioComputeBounds
	add	esp, 16					; 00000010H

; 716  : 		result = true;

	mov	DWORD PTR _result$[ebp], 1
$LN5@Mod_GetStu:

; 717  : 	}
; 718  : 	Mem_Free( f );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_GetStudioBounds@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DH@OGLHGOCJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 719  : 
; 720  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Mod_GetStu:

; 721  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetStudioBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_StudioTexName
_TEXT	SEGMENT
_modname$ = 8						; size = 4
_Mod_StudioTexName PROC					; COMDAT

; 731  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 732  : 	static char	texname[MAX_QPATH];
; 733  : 
; 734  : 	Q_strncpy( texname, modname, sizeof( texname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _modname$[ebp]
	push	eax
	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 735  : 	COM_StripExtension( texname );

	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_COM_StripExtension
	add	esp, 4

; 736  : 	Q_strncat( texname, "T.mdl", sizeof( texname ));

	push	64					; 00000040H
	push	OFFSET ??_C@_05OIAJONFB@T?4mdl@
	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 	return texname;

	mov	eax, OFFSET ?texname@?1??Mod_StudioTexName@@9@9

; 739  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioTexName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_ResetStudioAPI
_TEXT	SEGMENT
_Mod_ResetStudioAPI PROC				; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 953  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI

; 954  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ResetStudioAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_InitStudioHull
_TEXT	SEGMENT
_side$ = -8						; size = 4
_i$ = -4						; size = 4
_Mod_InitStudioHull PROC				; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 68   : 	int	i, side;
; 69   : 
; 70   : 	if( studio_hull[0].planes != NULL )

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	cmp	DWORD PTR _studio_hull[ecx+4], 0
	je	SHORT $LN8@Mod_InitSt

; 71   : 		return;	// already initailized

	jmp	$LN1@Mod_InitSt
$LN8@Mod_InitSt:

; 72   : 
; 73   : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_InitSt
$LN2@Mod_InitSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_InitSt:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@Mod_InitSt

; 74   : 	{
; 75   : 		studio_clipnodes[i].planenum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _studio_clipnodes[eax*8], ecx

; 76   : 
; 77   : 		side = i & 1;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	mov	DWORD PTR _side$[ebp], eax

; 78   : 
; 79   : 		studio_clipnodes[i].children[side] = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _side$[ebp]
	shl	eax, 1
	or	ecx, -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[eax+edx*8+4], cx

; 80   : 		if( i != 5 ) studio_clipnodes[i].children[side^1] = i + 1;

	cmp	DWORD PTR _i$[ebp], 5
	je	SHORT $LN9@Mod_InitSt
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[ecx+edx*8+4], ax
	jmp	SHORT $LN10@Mod_InitSt
$LN9@Mod_InitSt:

; 81   : 		else studio_clipnodes[i].children[side^1] = CONTENTS_SOLID;

	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	shl	eax, 1
	mov	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[eax+edx*8+4], cx
$LN10@Mod_InitSt:

; 82   : 	}

	jmp	SHORT $LN2@Mod_InitSt
$LN3@Mod_InitSt:

; 83   : 
; 84   : 	for( i = 0; i < MAXSTUDIOBONES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_InitSt
$LN5@Mod_InitSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_InitSt:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	SHORT $LN1@Mod_InitSt

; 85   : 	{
; 86   : 		studio_hull[i].clipnodes = studio_clipnodes;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[eax], OFFSET _studio_clipnodes

; 87   : 		studio_hull[i].planes = &studio_planes[i*6];

	imul	eax, DWORD PTR _i$[ebp], 6
	imul	ecx, eax, 20
	add	ecx, OFFSET _studio_planes
	imul	edx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[edx+4], ecx

; 88   : 		studio_hull[i].firstclipnode = 0;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[eax+8], 0

; 89   : 		studio_hull[i].lastclipnode = 5;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[eax+12], 5

; 90   : 	}

	jmp	SHORT $LN5@Mod_InitSt
$LN1@Mod_InitSt:

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_InitStudioHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_studio.c
;	COMDAT _Mod_InitStudioAPI
_TEXT	SEGMENT
_Mod_InitStudioAPI PROC					; COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 929  : 	static STUDIOAPI	pBlendIface;
; 930  : 
; 931  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI

; 932  : 
; 933  : 	pBlendIface = (STUDIOAPI)COM_GetProcAddress( svgame.hInstance, "Server_GetBlendingInterface" );

	push	OFFSET ??_C@_0BM@CNCIFPEN@Server_GetBlendingInterface@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9, eax

; 934  : 	if( pBlendIface && pBlendIface( SV_BLENDING_INTERFACE_VERSION, &pBlendAPI, &gStudioAPI, &studio_transform, &studio_bones ))

	cmp	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9, 0
	je	SHORT $LN2@Mod_InitSt
	push	OFFSET _studio_bones
	push	OFFSET _studio_transform
	push	OFFSET _gStudioAPI
	push	OFFSET _pBlendAPI
	push	1
	call	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@Mod_InitSt

; 935  : 	{
; 936  : 		Con_Reportf( "SV_LoadProgs: ^2initailized Server Blending interface ^7ver. %i\n", SV_BLENDING_INTERFACE_VERSION );

	push	1
	push	OFFSET ??_C@_0EB@NKJPIMDH@SV_LoadProgs?3?5?$FO2initailized?5Ser@
	call	_Con_Reportf
	add	esp, 8

; 937  : 		return;

	jmp	SHORT $LN1@Mod_InitSt
$LN2@Mod_InitSt:

; 938  : 	}
; 939  : 
; 940  : 	// just restore pointer to builtin function
; 941  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI
$LN1@Mod_InitSt:

; 942  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_InitStudioAPI ENDP
_TEXT	ENDS
END
