; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\snd_mp3.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Sound_LoadMPG
PUBLIC	_Stream_OpenMPG
PUBLIC	_Stream_ReadMPG
PUBLIC	_Stream_SetPosMPG
PUBLIC	_Stream_GetPosMPG
PUBLIC	_Stream_FreeMPG
PUBLIC	?__LINE__Var@?0??Sound_LoadMPG@@9@9		; `Sound_LoadMPG'::`1'::__LINE__Var
PUBLIC	??_C@_0P@MJNGGDBD@?$FO1Error?3?$FO7?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DD@ELMBKEKI@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5faile@ ; `string'
PUBLIC	??_C@_0DG@KEHEPMJA@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??Stream_OpenMPG@@9@9		; `Stream_OpenMPG'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0DE@HJJEMODI@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5coul@ ; `string'
PUBLIC	??_C@_0DE@GBNALHAE@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5fail@ ; `string'
PUBLIC	?__LINE__Var@?0??Stream_FreeMPG@@9@9		; `Stream_FreeMPG'::`1'::__LINE__Var
EXTRN	_memcpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_create_decoder:PROC
EXTRN	_feed_mpeg_header:PROC
EXTRN	_feed_mpeg_stream:PROC
EXTRN	_open_mpeg_stream:PROC
EXTRN	_read_mpeg_stream:PROC
EXTRN	_get_stream_pos:PROC
EXTRN	_set_stream_pos:PROC
EXTRN	_close_decoder:PROC
EXTRN	_get_error:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_sound:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?__LINE__Var@?0??Stream_FreeMPG@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Stream_FreeMPG@@9@9 DD 0121H		; `Stream_FreeMPG'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DE@GBNALHAE@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5fail@
CONST	SEGMENT
??_C@_0DE@GBNALHAE@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5fail@ DB '^1Error'
	DB	':^7 Stream_OpenMPG: failed to load (%s): %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HJJEMODI@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5coul@
CONST	SEGMENT
??_C@_0DE@HJJEMODI@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5coul@ DB '^1Error'
	DB	':^7 Stream_OpenMPG: couldn''t create decoder', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Stream_OpenMPG@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Stream_OpenMPG@@9@9 DD 095H		; `Stream_OpenMPG'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\soundlib\snd_mp3.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KEHEPMJA@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0DG@KEHEPMJA@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Sound_LoadMPG: (%s) is probably corrupted', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ELMBKEKI@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5faile@
CONST	SEGMENT
??_C@_0DD@ELMBKEKI@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5faile@ DB '^1Error'
	DB	':^7 Sound_LoadMPG: failed to load (%s): %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJNGGDBD@?$FO1Error?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@MJNGGDBD@?$FO1Error?3?$FO7?5?$CFs?6@ DB '^1Error:^7 %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Sound_LoadMPG@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Sound_LoadMPG@@9@9 DD 038H		; `Sound_LoadMPG'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	019aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	02e1H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Stream_FreeMPG
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_FreeMPG PROC					; COMDAT

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 290  : 	if( stream->ptr )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@Stream_Fre

; 291  : 	{
; 292  : 		close_decoder( stream->ptr );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_close_decoder
	add	esp, 4

; 293  : 		stream->ptr = NULL;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+28], 0
$LN2@Stream_Fre:

; 294  : 	}
; 295  : 
; 296  : 	if( stream->file )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@Stream_Fre

; 297  : 	{
; 298  : 		FS_Close( stream->file );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 299  : 		stream->file = NULL;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Stream_Fre:

; 300  : 	}
; 301  : 
; 302  : 	Mem_Free( stream );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_FreeMPG@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 303  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_FreeMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Stream_GetPosMPG
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_GetPosMPG PROC					; COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 278  : 	return get_stream_pos( stream->ptr );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_get_stream_pos
	add	esp, 4

; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_GetPosMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Stream_SetPosMPG
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_Stream_SetPosMPG PROC					; COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 258  : 	if( set_stream_pos( stream->ptr, newpos ) != -1 )

	mov	eax, DWORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_set_stream_pos
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN2@Stream_Set

; 259  : 	{
; 260  : 		// flush any previous data
; 261  : 		stream->buffsize = 0;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8228], 0

; 262  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Stream_Set
$LN2@Stream_Set:

; 263  : 	}
; 264  : 
; 265  : 	// failed to seek for some reasons
; 266  : 	return false;

	xor	eax, eax
$LN1@Stream_Set:

; 267  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_SetPosMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Stream_ReadMPG
_TEXT	SEGMENT
_outsize$1 = -16					; size = 4
_data$2 = -12						; size = 4
_mpg$ = -8						; size = 4
_bytesWritten$ = -4					; size = 4
_stream$ = 8						; size = 4
_needBytes$ = 12					; size = 4
_buffer$ = 16						; size = 4
_Stream_ReadMPG PROC					; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 210  : 	// buffer handling
; 211  : 	int	bytesWritten = 0;

	mov	DWORD PTR _bytesWritten$[ebp], 0

; 212  : 	void	*mpg;
; 213  : 
; 214  : 	mpg = stream->ptr;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _mpg$[ebp], ecx
$LN2@Stream_Rea:

; 215  : 
; 216  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Stream_Rea

; 217  : 	{
; 218  : 		byte	*data;
; 219  : 		long	outsize;
; 220  : 
; 221  : 		if( !stream->buffsize )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+8228], 0
	jne	SHORT $LN4@Stream_Rea

; 222  : 		{
; 223  : 			if( read_mpeg_stream( mpg, stream->temp, &stream->pos ) != MP3_OK )

	mov	eax, DWORD PTR _stream$[ebp]
	add	eax, 8224				; 00002020H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _mpg$[ebp]
	push	edx
	call	_read_mpeg_stream
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@Stream_Rea

; 224  : 				break; // there was end of the stream

	jmp	$LN3@Stream_Rea
$LN4@Stream_Rea:

; 225  : 		}
; 226  : 
; 227  : 		// check remaining size
; 228  : 		if( bytesWritten + stream->pos > needBytes )

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _bytesWritten$[ebp]
	add	ecx, DWORD PTR [eax+8224]
	cmp	ecx, DWORD PTR _needBytes$[ebp]
	jbe	SHORT $LN6@Stream_Rea

; 229  : 			outsize = ( needBytes - bytesWritten ); 

	mov	eax, DWORD PTR _needBytes$[ebp]
	sub	eax, DWORD PTR _bytesWritten$[ebp]
	mov	DWORD PTR _outsize$1[ebp], eax
	jmp	SHORT $LN7@Stream_Rea
$LN6@Stream_Rea:

; 230  : 		else outsize = stream->pos;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8224]
	mov	DWORD PTR _outsize$1[ebp], ecx
$LN7@Stream_Rea:

; 231  : 
; 232  : 		// copy raw sample to output buffer
; 233  : 		data = (byte *)buffer + bytesWritten;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _bytesWritten$[ebp]
	mov	DWORD PTR _data$2[ebp], eax

; 234  : 		memcpy( data, &stream->temp[stream->buffsize], outsize );

	mov	eax, DWORD PTR _outsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+8228]
	mov	eax, DWORD PTR _stream$[ebp]
	lea	ecx, DWORD PTR [eax+edx+32]
	push	ecx
	mov	edx, DWORD PTR _data$2[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 235  : 		bytesWritten += outsize;

	mov	eax, DWORD PTR _bytesWritten$[ebp]
	add	eax, DWORD PTR _outsize$1[ebp]
	mov	DWORD PTR _bytesWritten$[ebp], eax

; 236  : 		stream->pos -= outsize;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8224]
	sub	ecx, DWORD PTR _outsize$1[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8224], ecx

; 237  : 		stream->buffsize += outsize;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8228]
	add	ecx, DWORD PTR _outsize$1[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8228], ecx

; 238  : 
; 239  : 		// continue from this sample on a next call
; 240  : 		if( bytesWritten >= needBytes )

	mov	eax, DWORD PTR _bytesWritten$[ebp]
	cmp	eax, DWORD PTR _needBytes$[ebp]
	jl	SHORT $LN8@Stream_Rea

; 241  : 			return bytesWritten;

	mov	eax, DWORD PTR _bytesWritten$[ebp]
	jmp	SHORT $LN1@Stream_Rea
$LN8@Stream_Rea:

; 242  : 
; 243  : 		stream->buffsize = 0; // no bytes remaining

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8228], 0

; 244  : 	}

	jmp	$LN2@Stream_Rea
$LN3@Stream_Rea:

; 245  : 
; 246  : 	return 0;

	xor	eax, eax
$LN1@Stream_Rea:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_ReadMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Stream_OpenMPG
_TEXT	SEGMENT
_sc$ = -32						; size = 12
_ret$ = -20						; size = 4
_file$ = -16						; size = 4
_mpeg$ = -12						; size = 4
_stream$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_Stream_OpenMPG PROC					; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 150  : 	stream_t	*stream;
; 151  : 	void	*mpeg;
; 152  : 	file_t	*file;
; 153  : 	int	ret;
; 154  : 	wavinfo_t	sc;
; 155  : 
; 156  : 	file = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 157  : 	if( !file ) return NULL;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@Stream_Ope
	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN2@Stream_Ope:

; 158  : 
; 159  : 	// at this point we have valid stream
; 160  : 	stream = Mem_Calloc( host.soundpool, sizeof( stream_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_OpenMPG@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	8232					; 00002028H
	mov	ecx, DWORD PTR _host+34748
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _stream$[ebp], eax

; 161  : 	stream->file = file;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 162  : 	stream->pos = 0;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8224], 0

; 163  : 
; 164  : 	// couldn't create decoder
; 165  : 	if(( mpeg = create_decoder( &ret )) == NULL )

	lea	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_create_decoder
	add	esp, 4
	mov	DWORD PTR _mpeg$[ebp], eax
	cmp	DWORD PTR _mpeg$[ebp], 0
	jne	SHORT $LN3@Stream_Ope

; 166  : 	{
; 167  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: couldn't create decoder\n" );

	push	OFFSET ??_C@_0DE@HJJEMODI@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5coul@
	call	_Con_DPrintf
	add	esp, 4

; 168  : 		Mem_Free( stream );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_OpenMPG@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 169  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 170  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN3@Stream_Ope:

; 171  : 	}
; 172  : 
; 173  : #ifdef _DEBUG
; 174  : 	if( ret ) Con_DPrintf( S_ERROR "%s\n", get_error( mpeg ));

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@Stream_Ope
	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0P@MJNGGDBD@?$FO1Error?3?$FO7?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8
$LN4@Stream_Ope:

; 175  : #endif
; 176  : 	// trying to open stream and read header
; 177  : 	if( !open_mpeg_stream( mpeg, file, FS_Read, FS_Seek, &sc ))

	lea	eax, DWORD PTR _sc$[ebp]
	push	eax
	push	OFFSET _FS_Seek
	push	OFFSET _FS_Read
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_open_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN5@Stream_Ope

; 178  : 	{
; 179  : #ifdef _DEBUG
; 180  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: failed to load (%s): %s\n", filename, get_error( mpeg ));

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@GBNALHAE@?$FO1Error?3?$FO7?5Stream_OpenMPG?3?5fail@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 181  : #else
; 182  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: (%s) is probably corrupted\n", filename );
; 183  : #endif
; 184  : 		close_decoder( mpeg );

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_close_decoder
	add	esp, 4

; 185  : 		Mem_Free( stream );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_OpenMPG@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 186  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 187  : 
; 188  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Stream_Ope
$LN5@Stream_Ope:

; 189  : 	}
; 190  : 
; 191  : 	stream->buffsize = 0; // how many samples left from previous frame

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8228], 0

; 192  : 	stream->channels = sc.channels;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sc$[ebp+4]
	mov	DWORD PTR [eax+16], ecx

; 193  : 	stream->rate = sc.rate;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 194  : 	stream->width = 2;	// always 16 bit

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8], 2

; 195  : 	stream->ptr = mpeg;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _mpeg$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 196  : 	stream->type = WF_MPGDATA;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+20], 2

; 197  : 
; 198  : 	return stream;

	mov	eax, DWORD PTR _stream$[ebp]
$LN1@Stream_Ope:

; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_OpenMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_mp3.c
;	COMDAT _Sound_LoadMPG
_TEXT	SEGMENT
_bufsize$1 = -8244					; size = 4
_data$2 = -8240						; size = 4
_size$3 = -8236						; size = 4
_sc$ = -8232						; size = 12
_ret$ = -8220						; size = 4
_padsize$ = -8216					; size = 4
_outsize$ = -8212					; size = 4
_out$ = -8208						; size = 8192
_bytesWrite$ = -16					; size = 4
_pos$ = -12						; size = 4
_mpeg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Sound_LoadMPG PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8756				; 00002234H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 57   : 	void	*mpeg;
; 58   : 	size_t	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 59   : 	size_t	bytesWrite = 0;

	mov	DWORD PTR _bytesWrite$[ebp], 0

; 60   : 	char	out[OUTBUF_SIZE];
; 61   : 	size_t	outsize, padsize;
; 62   : 	int	ret;
; 63   : 	wavinfo_t	sc;
; 64   : 
; 65   : 	// load the file
; 66   : 	if( !buffer || filesize < FRAME_SIZE )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN5@Sound_Load
	cmp	DWORD PTR _filesize$[ebp], 32768	; 00008000H
	jae	SHORT $LN4@Sound_Load
$LN5@Sound_Load:

; 67   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN4@Sound_Load:

; 68   : 
; 69   : 	// couldn't create decoder
; 70   : 	if(( mpeg = create_decoder( &ret )) == NULL )

	lea	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_create_decoder
	add	esp, 4
	mov	DWORD PTR _mpeg$[ebp], eax
	cmp	DWORD PTR _mpeg$[ebp], 0
	jne	SHORT $LN6@Sound_Load

; 71   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN6@Sound_Load:

; 72   : 
; 73   : #ifdef _DEBUG
; 74   : 	if( ret ) Con_DPrintf( S_ERROR "%s\n", get_error( mpeg ));

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN7@Sound_Load
	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0P@MJNGGDBD@?$FO1Error?3?$FO7?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8
$LN7@Sound_Load:

; 75   : #endif
; 76   : 
; 77   : 	// trying to read header
; 78   : 	if( !feed_mpeg_header( mpeg, buffer, FRAME_SIZE, filesize, &sc ))

	lea	eax, DWORD PTR _sc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	push	32768					; 00008000H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_feed_mpeg_header
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN8@Sound_Load

; 79   : 	{
; 80   : #ifdef _DEBUG
; 81   : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: failed to load (%s): %s\n", name, get_error( mpeg ));

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@ELMBKEKI@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5faile@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 82   : #else
; 83   : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: (%s) is probably corrupted\n", name );
; 84   : #endif
; 85   : 		close_decoder( mpeg );

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_close_decoder
	add	esp, 4

; 86   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN8@Sound_Load:

; 87   : 	}
; 88   : 
; 89   : 	sound.channels = sc.channels;

	mov	eax, DWORD PTR _sc$[ebp+4]
	mov	DWORD PTR _sound+20, eax

; 90   : 	sound.rate = sc.rate;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR _sound+12, eax

; 91   : 	sound.width = 2; // always 16-bit PCM

	mov	DWORD PTR _sound+16, 2

; 92   : 	sound.loopstart = -1;

	mov	DWORD PTR _sound+24, -1

; 93   : 	sound.size = ( sound.channels * sound.rate * sound.width ) * ( sc.playtime / 1000 ); // in bytes

	mov	ecx, DWORD PTR _sound+20
	imul	ecx, DWORD PTR _sound+12
	imul	ecx, DWORD PTR _sound+16
	mov	eax, DWORD PTR _sc$[ebp+8]
	cdq
	mov	esi, 1000				; 000003e8H
	idiv	esi
	imul	ecx, eax
	mov	DWORD PTR _sound+36, ecx

; 94   : 	padsize = sound.size % FRAME_SIZE;

	mov	eax, DWORD PTR _sound+36
	xor	edx, edx
	mov	ecx, 32768				; 00008000H
	div	ecx
	mov	DWORD PTR _padsize$[ebp], edx

; 95   : 	pos += FRAME_SIZE; // evaluate pos

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 32768				; 00008000H
	mov	DWORD PTR _pos$[ebp], eax

; 96   : 
; 97   : 	if( !sound.size )

	cmp	DWORD PTR _sound+36, 0
	jne	SHORT $LN9@Sound_Load

; 98   : 	{
; 99   : 		// bad mpeg file ?
; 100  : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: (%s) is probably corrupted\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@KEHEPMJA@?$FO1Error?3?$FO7?5Sound_LoadMPG?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 101  : 		close_decoder( mpeg );

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_close_decoder
	add	esp, 4

; 102  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN9@Sound_Load:

; 103  : 	}
; 104  : 
; 105  : 	// add sentinel make sure we not overrun
; 106  : 	sound.wav = (byte *)Mem_Calloc( host.soundpool, sound.size + padsize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Sound_LoadMPG@@9@9
	add	eax, 50					; 00000032H
	push	eax
	push	OFFSET ??_C@_0DN@JOJLAJAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _sound+36
	add	ecx, DWORD PTR _padsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34748
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _sound+40, eax

; 107  : 	sound.type = WF_PCMDATA;

	mov	DWORD PTR _sound+8, 1
$LN2@Sound_Load:

; 108  : 
; 109  : 	// decompress mpg into pcm wav format
; 110  : 	while( bytesWrite < sound.size )

	mov	eax, DWORD PTR _bytesWrite$[ebp]
	cmp	eax, DWORD PTR _sound+36
	jae	$LN3@Sound_Load

; 111  : 	{
; 112  : 		int	size;
; 113  : 
; 114  : 		if( feed_mpeg_stream( mpeg, NULL, 0, out, &outsize ) != MP3_OK && outsize <= 0 )

	lea	eax, DWORD PTR _outsize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_feed_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN10@Sound_Load
	cmp	DWORD PTR _outsize$[ebp], 0
	ja	SHORT $LN10@Sound_Load

; 115  : 		{
; 116  : 			char	*data = (char *)buffer + pos;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR _data$2[ebp], eax

; 117  : 			int	bufsize;
; 118  : 
; 119  : 			// if there are no bytes remainig so we can decompress the new frame
; 120  : 			if( pos + FRAME_SIZE > filesize )

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 32768				; 00008000H
	cmp	eax, DWORD PTR _filesize$[ebp]
	jbe	SHORT $LN11@Sound_Load

; 121  : 				bufsize = ( filesize - pos );

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR _bufsize$1[ebp], eax
	jmp	SHORT $LN12@Sound_Load
$LN11@Sound_Load:

; 122  : 			else bufsize = FRAME_SIZE;

	mov	DWORD PTR _bufsize$1[ebp], 32768	; 00008000H
$LN12@Sound_Load:

; 123  : 			pos += bufsize;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _bufsize$1[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 124  : 
; 125  : 			if( feed_mpeg_stream( mpeg, data, bufsize, out, &outsize ) != MP3_OK )

	lea	eax, DWORD PTR _outsize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bufsize$1[ebp]
	push	edx
	mov	eax, DWORD PTR _data$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpeg$[ebp]
	push	ecx
	call	_feed_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN10@Sound_Load

; 126  : 				break; // there was end of the stream

	jmp	SHORT $LN3@Sound_Load
$LN10@Sound_Load:

; 127  : 		}
; 128  : 
; 129  : 		if( bytesWrite + outsize > sound.size )

	mov	eax, DWORD PTR _bytesWrite$[ebp]
	add	eax, DWORD PTR _outsize$[ebp]
	cmp	eax, DWORD PTR _sound+36
	jbe	SHORT $LN14@Sound_Load

; 130  : 			size = ( sound.size - bytesWrite );

	mov	eax, DWORD PTR _sound+36
	sub	eax, DWORD PTR _bytesWrite$[ebp]
	mov	DWORD PTR _size$3[ebp], eax
	jmp	SHORT $LN15@Sound_Load
$LN14@Sound_Load:

; 131  : 		else size = outsize;

	mov	eax, DWORD PTR _outsize$[ebp]
	mov	DWORD PTR _size$3[ebp], eax
$LN15@Sound_Load:

; 132  : 
; 133  : 		memcpy( &sound.wav[bytesWrite], out, size );

	mov	eax, DWORD PTR _size$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sound+40
	add	edx, DWORD PTR _bytesWrite$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 		bytesWrite += size;

	mov	eax, DWORD PTR _bytesWrite$[ebp]
	add	eax, DWORD PTR _size$3[ebp]
	mov	DWORD PTR _bytesWrite$[ebp], eax

; 135  : 	}

	jmp	$LN2@Sound_Load
$LN3@Sound_Load:

; 136  : 
; 137  : 	sound.samples = bytesWrite / ( sound.width * sound.channels );

	mov	ecx, DWORD PTR _sound+16
	imul	ecx, DWORD PTR _sound+20
	mov	eax, DWORD PTR _bytesWrite$[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _sound+28, eax

; 138  : 	close_decoder( mpeg );

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_close_decoder
	add	esp, 4

; 139  : 
; 140  : 	return true;

	mov	eax, 1
$LN1@Sound_Load:

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_LoadMPG ENDP
_TEXT	ENDS
END
