; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\crclib.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_crc32table DD	00H
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
CONST	ENDS
PUBLIC	_CRC32_Init
PUBLIC	_CRC32_BlockSequence
PUBLIC	_CRC32_ProcessBuffer
PUBLIC	_CRC32_ProcessByte
PUBLIC	_CRC32_Final
PUBLIC	_CRC32_File
PUBLIC	_CRC32_MapFile
PUBLIC	_MD5Init
PUBLIC	_MD5Update
PUBLIC	_MD5Final
PUBLIC	_MD5_HashFile
PUBLIC	_COM_HashKey
PUBLIC	_MD5_Print
PUBLIC	_MD5Transform
PUBLIC	?__LINE__Var@?0??CRC32_File@@9@9		; `CRC32_File'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0DD@MLICIGDA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BB@OKIBMNG@crcvalue?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_04JFFKLGJF@?$CF02X@			; `string'
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Eof:PROC
EXTRN	_FS_Close:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?szReturn@?1??MD5_Print@@9@9 DB 040H DUP (?)		; `MD5_Print'::`2'::szReturn
_BSS	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X@ DB '%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OKIBMNG@crcvalue?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BB@OKIBMNG@crcvalue?5?$CB?$DN?5NULL@ DB 'crcvalue != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MLICIGDA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@MLICIGDA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\crclib.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CRC32_File@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CRC32_File@@9@9 DD 0cdH		; `CRC32_File'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	076H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0269H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0106H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f2H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5Transform
_TEXT	SEGMENT
_d$ = -16						; size = 4
_c$ = -12						; size = 4
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_buf$ = 8						; size = 4
_in$ = 12						; size = 4
_MD5Transform PROC					; COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 448  : 	register uint	a, b, c, d;
; 449  : 
; 450  : 	a = buf[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _a$[ebp], eax

; 451  : 	b = buf[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _b$[ebp], edx

; 452  : 	c = buf[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _c$[ebp], edx

; 453  : 	d = buf[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _d$[ebp], eax

; 454  : 
; 455  : 	MD5STEP( F1, a, b, c, d, in[0] + 0xd76aa478, 7 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-680876936]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 25					; 00000019H
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 456  : 	MD5STEP( F1, d, a, b, c, in[1] + 0xe8c7b756, 12 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [ecx+eax-389564586]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _d$[ebp]
	shr	ecx, 20					; 00000014H
	or	eax, ecx
	mov	DWORD PTR _d$[ebp], eax
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 457  : 	MD5STEP( F1, c, d, a, b, in[2] + 0x242070db, 17 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [ecx+eax+606105819]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 15					; 0000000fH
	or	eax, ecx
	mov	DWORD PTR _c$[ebp], eax
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 458  : 	MD5STEP( F1, b, c, d, a, in[3] + 0xc1bdceee, 22 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-1044525330]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 22					; 00000016H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 10					; 0000000aH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 459  : 	MD5STEP( F1, a, b, c, d, in[4] + 0xf57c0faf, 7 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax-176418897]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 25					; 00000019H
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 460  : 	MD5STEP( F1, d, a, b, c, in[5] + 0x4787c62a, 12 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax+1200080426]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 20					; 00000014H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 461  : 	MD5STEP( F1, c, d, a, b, in[6] + 0xa8304613, 17 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-1473231341]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 17					; 00000011H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 15					; 0000000fH
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 462  : 	MD5STEP( F1, b, c, d, a, in[7] + 0xfd469501, 22 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-45705983]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 22					; 00000016H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 10					; 0000000aH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 463  : 	MD5STEP( F1, a, b, c, d, in[8] + 0x698098d8, 7 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1770035416]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 25					; 00000019H
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 464  : 	MD5STEP( F1, d, a, b, c, in[9] + 0x8b44f7af, 12 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-1958414417]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 20					; 00000014H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 465  : 	MD5STEP( F1, c, d, a, b, in[10] + 0xffff5bb1, 17 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-42063]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 17					; 00000011H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 15					; 0000000fH
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 466  : 	MD5STEP( F1, b, c, d, a, in[11] + 0x895cd7be, 22 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-1990404162]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 22					; 00000016H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 10					; 0000000aH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 467  : 	MD5STEP( F1, a, b, c, d, in[12] + 0x6b901122, 7 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax+1804603682]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 25					; 00000019H
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 468  : 	MD5STEP( F1, d, a, b, c, in[13] + 0xfd987193, 12 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-40341101]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 20					; 00000014H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 469  : 	MD5STEP( F1, c, d, a, b, in[14] + 0xa679438e, 17 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-1502002290]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 17					; 00000011H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 15					; 0000000fH
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 470  : 	MD5STEP( F1, b, c, d, a, in[15] + 0x49b40821, 22 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax+1236535329]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 22					; 00000016H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 10					; 0000000aH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 471  : 
; 472  : 	MD5STEP( F2, a, b, c, d, in[1] + 0xf61e2562, 5 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax-165796510]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 27					; 0000001bH
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 473  : 	MD5STEP( F2, d, a, b, c, in[6] + 0xc040b340, 9 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-1069501632]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 23					; 00000017H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 474  : 	MD5STEP( F2, c, d, a, b, in[11] + 0x265e5a51, 14 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax+643717713]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 14					; 0000000eH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 475  : 	MD5STEP( F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-373897302]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 12					; 0000000cH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 476  : 	MD5STEP( F2, a, b, c, d, in[5] + 0xd62f105d, 5 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-701558691]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 27					; 0000001bH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 477  : 	MD5STEP( F2, d, a, b, c, in[10] + 0x02441453, 9 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax+38016083]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 23					; 00000017H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 478  : 	MD5STEP( F2, c, d, a, b, in[15] + 0xd8a1e681, 14 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-660478335]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 14					; 0000000eH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 479  : 	MD5STEP( F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _b$[ebp]
	lea	edx, DWORD PTR [ecx+eax-405537848]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 12					; 0000000cH
	or	eax, ecx
	mov	DWORD PTR _b$[ebp], eax
	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 480  : 	MD5STEP( F2, a, b, c, d, in[9] + 0x21e1cde6, 5 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax+568446438]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 27					; 0000001bH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 481  : 	MD5STEP( F2, d, a, b, c, in[14] + 0xc33707d6, 9 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-1019803690]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 23					; 00000017H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 482  : 	MD5STEP( F2, c, d, a, b, in[3] + 0xf4d50d87, 14 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-187363961]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 14					; 0000000eH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 483  : 	MD5STEP( F2, b, c, d, a, in[8] + 0x455a14ed, 20 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _b$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1163531501]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 12					; 0000000cH
	or	eax, ecx
	mov	DWORD PTR _b$[ebp], eax
	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 484  : 	MD5STEP( F2, a, b, c, d, in[13] + 0xa9e3e905, 5 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-1444681467]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 27					; 0000001bH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 485  : 	MD5STEP( F2, d, a, b, c, in[2] + 0xfcefa3f8, 9 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [ecx+eax-51403784]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _d$[ebp]
	shr	ecx, 23					; 00000017H
	or	eax, ecx
	mov	DWORD PTR _d$[ebp], eax
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 486  : 	MD5STEP( F2, c, d, a, b, in[7] + 0x676f02d9, 14 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax+1735328473]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 14					; 0000000eH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 487  : 	MD5STEP( F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-1926607734]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 12					; 0000000cH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 488  : 
; 489  : 	MD5STEP( F3, a, b, c, d, in[5] + 0xfffa3942, 4 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-378558]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 28					; 0000001cH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 490  : 	MD5STEP( F3, d, a, b, c, in[8] + 0x8771f681, 11 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [ecx+eax-2022574463]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 11					; 0000000bH
	mov	ecx, DWORD PTR _d$[ebp]
	shr	ecx, 21					; 00000015H
	or	eax, ecx
	mov	DWORD PTR _d$[ebp], eax
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 491  : 	MD5STEP( F3, c, d, a, b, in[11] + 0x6d9d6122, 16 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax+1839030562]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 16					; 00000010H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 492  : 	MD5STEP( F3, b, c, d, a, in[14] + 0xfde5380c, 23 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-35309556]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 23					; 00000017H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 9
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 493  : 	MD5STEP( F3, a, b, c, d, in[1] + 0xa4beea44, 4 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1530992060]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 28					; 0000001cH
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 494  : 	MD5STEP( F3, d, a, b, c, in[4] + 0x4bdecfa9, 11 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1272893353]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 11					; 0000000bH
	mov	ecx, DWORD PTR _d$[ebp]
	shr	ecx, 21					; 00000015H
	or	eax, ecx
	mov	DWORD PTR _d$[ebp], eax
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 495  : 	MD5STEP( F3, c, d, a, b, in[7] + 0xf6bb4b60, 16 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-155497632]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 16					; 00000010H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 496  : 	MD5STEP( F3, b, c, d, a, in[10] + 0xbebfbc70, 23 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-1094730640]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 23					; 00000017H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 9
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 497  : 	MD5STEP( F3, a, b, c, d, in[13] + 0x289b7ec6, 4 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax+681279174]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 28					; 0000001cH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 498  : 	MD5STEP( F3, d, a, b, c, in[0] + 0xeaa127fa, 11 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-358537222]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 11					; 0000000bH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 21					; 00000015H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 499  : 	MD5STEP( F3, c, d, a, b, in[3] + 0xd4ef3085, 16 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-722521979]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 16					; 00000010H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 500  : 	MD5STEP( F3, b, c, d, a, in[6] + 0x04881d05, 23 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax+76029189]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 23					; 00000017H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 9
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 501  : 	MD5STEP( F3, a, b, c, d, in[9] + 0xd9d4d039, 4 );

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-640364487]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 28					; 0000001cH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 502  : 	MD5STEP( F3, d, a, b, c, in[12] + 0xe6db99e5, 11 );

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-421815835]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 11					; 0000000bH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 21					; 00000015H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 503  : 	MD5STEP( F3, c, d, a, b, in[15] + 0x1fa27cf8, 16 );

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax+530742520]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 16					; 00000010H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 504  : 	MD5STEP( F3, b, c, d, a, in[2] + 0xc4ac5665, 23 );

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _b$[ebp]
	lea	edx, DWORD PTR [ecx+eax-995338651]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 23					; 00000017H
	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 9
	or	eax, ecx
	mov	DWORD PTR _b$[ebp], eax
	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 505  : 
; 506  : 	MD5STEP( F4, a, b, c, d, in[0] + 0xf4292244, 6 );

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax-198630844]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 26					; 0000001aH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 507  : 	MD5STEP( F4, d, a, b, c, in[7] + 0x432aff97, 10 );

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax+1126891415]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 22					; 00000016H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 508  : 	MD5STEP( F4, c, d, a, b, in[14] + 0xab9423a7, 15 );

	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	or	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-1416354905]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 17					; 00000011H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 509  : 	MD5STEP( F4, b, c, d, a, in[5] + 0xfc93a039, 21 );

	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	or	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-57434055]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 21					; 00000015H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 11					; 0000000bH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 510  : 	MD5STEP( F4, a, b, c, d, in[12] + 0x655b59c3, 6 );

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [edx+eax+1700485571]
	mov	DWORD PTR _a$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _a$[ebp]
	shr	edx, 26					; 0000001aH
	or	ecx, edx
	mov	DWORD PTR _a$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 511  : 	MD5STEP( F4, d, a, b, c, in[3] + 0x8f0ccc92, 10 );

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-1894986606]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 22					; 00000016H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 512  : 	MD5STEP( F4, c, d, a, b, in[10] + 0xffeff47d, 15 );

	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	or	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-1051523]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 17					; 00000011H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 513  : 	MD5STEP( F4, b, c, d, a, in[1] + 0x85845dd1, 21 );

	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	or	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _b$[ebp]
	lea	edx, DWORD PTR [ecx+eax-2054922799]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 21					; 00000015H
	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 11					; 0000000bH
	or	eax, ecx
	mov	DWORD PTR _b$[ebp], eax
	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 514  : 	MD5STEP( F4, a, b, c, d, in[8] + 0x6fa87e4f, 6 );

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1873313359]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 26					; 0000001aH
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 515  : 	MD5STEP( F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10 );

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-30611744]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 22					; 00000016H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 516  : 	MD5STEP( F4, c, d, a, b, in[6] + 0xa3014314, 15 );

	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	or	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [edx+eax-1560198380]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 17					; 00000011H
	or	ecx, edx
	mov	DWORD PTR _c$[ebp], ecx
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 517  : 	MD5STEP( F4, b, c, d, a, in[13] + 0x4e0811a1, 21 );

	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	or	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax+1309151649]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 21					; 00000015H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 11					; 0000000bH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 518  : 	MD5STEP( F4, a, b, c, d, in[4] + 0xf7537e82, 6 );

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+eax-145523070]
	mov	DWORD PTR _a$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 26					; 0000001aH
	or	eax, ecx
	mov	DWORD PTR _a$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 519  : 	MD5STEP( F4, d, a, b, c, in[11] + 0xbd3af235, 10 );

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [edx+eax-1120210379]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _d$[ebp]
	shr	edx, 22					; 00000016H
	or	ecx, edx
	mov	DWORD PTR _d$[ebp], ecx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 520  : 	MD5STEP( F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15 );

	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	or	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [ecx+eax+718787259]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 17					; 00000011H
	or	eax, ecx
	mov	DWORD PTR _c$[ebp], eax
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 521  : 	MD5STEP( F4, b, c, d, a, in[9] + 0xeb86d391, 21 );

	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	or	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [edx+eax-343485551]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 21					; 00000015H
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 11					; 0000000bH
	or	ecx, edx
	mov	DWORD PTR _b$[ebp], ecx
	mov	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 522  : 
; 523  : 	buf[0] += a;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 524  : 	buf[1] += b;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, DWORD PTR _b$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 525  : 	buf[2] += c;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, DWORD PTR _c$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 526  : 	buf[3] += d;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	add	eax, DWORD PTR _d$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 527  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5Transform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5_Print
_TEXT	SEGMENT
_i$ = -20						; size = 4
_szChunk$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_hash$ = 8						; size = 4
_MD5_Print PROC						; COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 574  : 	static char	szReturn[64];
; 575  : 	byte		szChunk[10];
; 576  : 	int		i;
; 577  : 
; 578  : 	memset( szReturn, 0, 64 );

	push	64					; 00000040H
	push	0
	push	OFFSET ?szReturn@?1??MD5_Print@@9@9
	call	_memset
	add	esp, 12					; 0000000cH

; 579  : 
; 580  : 	for( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MD5_Print
$LN2@MD5_Print:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MD5_Print:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@MD5_Print

; 581  : 	{
; 582  : 		Q_snprintf( szChunk, sizeof( szChunk ), "%02X", hash[i] );

	mov	eax, DWORD PTR _hash$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_04JFFKLGJF@?$CF02X@
	push	10					; 0000000aH
	lea	edx, DWORD PTR _szChunk$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 583  : 		Q_strncat( szReturn, szChunk, sizeof( szReturn ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _szChunk$[ebp]
	push	eax
	push	OFFSET ?szReturn@?1??MD5_Print@@9@9
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 584  : 	}

	jmp	SHORT $LN2@MD5_Print
$LN3@MD5_Print:

; 585  : 
; 586  : 	return szReturn;

	mov	eax, OFFSET ?szReturn@?1??MD5_Print@@9@9

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _COM_HashKey
_TEXT	SEGMENT
_hashKey$ = -8						; size = 4
_i$ = -4						; size = 4
_string$ = 8						; size = 4
_hashSize$ = 12						; size = 4
_COM_HashKey PROC					; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 598  : 	uint	i, hashKey = 0;

	mov	DWORD PTR _hashKey$[ebp], 0

; 599  : 
; 600  : 	for( i = 0; string[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_HashKe
$LN2@COM_HashKe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@COM_HashKe:
	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@COM_HashKe

; 601  : 		hashKey = (hashKey + i) * 37 + Q_tolower( string[i] );

	mov	eax, DWORD PTR _hashKey$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	imul	esi, eax, 37
	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	eax, al
	add	esi, eax
	mov	DWORD PTR _hashKey$[ebp], esi
	jmp	SHORT $LN2@COM_HashKe
$LN3@COM_HashKe:

; 602  : 
; 603  : 	return (hashKey % hashSize);

	mov	eax, DWORD PTR _hashKey$[ebp]
	xor	edx, edx
	div	DWORD PTR _hashSize$[ebp]
	mov	eax, edx

; 604  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_HashKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5_HashFile
_TEXT	SEGMENT
_bytes$ = -1124						; size = 4
_MD5_Hash$ = -1120					; size = 88
_buffer$ = -1032					; size = 1024
_file$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_digest$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_seed$ = 16						; size = 4
_MD5_HashFile PROC					; COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1316				; 00000524H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 531  : 	file_t		*file;
; 532  : 	char		buffer[1024];
; 533  : 	MD5Context_t	MD5_Hash;
; 534  : 	int		bytes;
; 535  :  
; 536  : 	if(( file = FS_Open( pszFileName, "rb", false )) == NULL )

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _pszFileName$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN4@MD5_HashFi

; 537  : 		return false;

	xor	eax, eax
	jmp	$LN1@MD5_HashFi
$LN4@MD5_HashFi:

; 538  : 
; 539  : 	memset( &MD5_Hash, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 540  : 
; 541  : 	MD5Init( &MD5_Hash );

	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 542  : 
; 543  : 	if( seed )

	cmp	DWORD PTR _seed$[ebp], 0
	je	SHORT $LN2@MD5_HashFi

; 544  : 	{
; 545  : 		MD5Update( &MD5_Hash, (const byte *)seed, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _seed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _MD5_Hash$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN2@MD5_HashFi:

; 546  : 	}
; 547  : 
; 548  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@MD5_HashFi

; 549  : 	{
; 550  : 		bytes = FS_Read( file, buffer, sizeof( buffer ));

	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytes$[ebp], eax

; 551  : 
; 552  : 		if( bytes > 0 )

	cmp	DWORD PTR _bytes$[ebp], 0
	jle	SHORT $LN6@MD5_HashFi

; 553  : 			MD5Update( &MD5_Hash, buffer, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _MD5_Hash$[ebp]
	push	edx
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN6@MD5_HashFi:

; 554  : 
; 555  : 		if( FS_Eof( file ))

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@MD5_HashFi

; 556  : 			break;

	jmp	SHORT $LN3@MD5_HashFi
$LN7@MD5_HashFi:

; 557  : 	}

	jmp	SHORT $LN2@MD5_HashFi
$LN3@MD5_HashFi:

; 558  : 
; 559  : 	FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 560  : 	MD5Final( digest, &MD5_Hash );

	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _digest$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 561  : 
; 562  : 	return true;

	mov	eax, 1
$LN1@MD5_HashFi:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5_HashFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5Final
_TEXT	SEGMENT
_p$ = -8						; size = 4
_count$ = -4						; size = 4
_digest$ = 8						; size = 4
_ctx$ = 12						; size = 4
_MD5Final PROC						; COMDAT

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 388  : 	uint	count;
; 389  : 	byte	*p;
; 390  : 
; 391  : 	// compute number of bytes mod 64
; 392  : 	count = ( ctx->bits[0] >> 3 ) & 0x3F;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+ecx+16]
	shr	eax, 3
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _count$[ebp], eax

; 393  : 
; 394  : 	// set the first char of padding to 0x80.
; 395  : 	// this is safe since there is always at least one byte free
; 396  : 	p = ctx->in + count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _ctx$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24]
	mov	DWORD PTR _p$[ebp], edx

; 397  : 	*p++ = 0x80;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 128			; 00000080H
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 398  : 
; 399  : 	// bytes of padding needed to make 64 bytes
; 400  : 	count = 64 - 1 - count;

	mov	eax, 63					; 0000003fH
	sub	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 401  : 
; 402  : 	// pad out to 56 mod 64
; 403  : 	if( count < 8 )

	cmp	DWORD PTR _count$[ebp], 8
	jae	SHORT $LN2@MD5Final

; 404  : 	{
; 405  : 
; 406  : 		// two lots of padding: pad the first block to 64 bytes
; 407  : 		memset( p, 0, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 408  : 		MD5Transform( ctx->buf, (uint *)ctx->in );

	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Transform
	add	esp, 8

; 409  : 
; 410  : 		// now fill the next block with 56 bytes
; 411  : 		memset( ctx->in, 0, 56 );

	push	56					; 00000038H
	push	0
	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 412  : 	}

	jmp	SHORT $LN3@MD5Final
$LN2@MD5Final:

; 413  : 	else
; 414  : 	{
; 415  : 		// pad block to 56 bytes
; 416  : 		memset( p, 0, count - 8 );

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 8
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@MD5Final:

; 417  : 	}
; 418  : 
; 419  : 	// append length in bits and transform
; 420  : 	((uint *)ctx->in)[14] = ctx->bits[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 14
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+24], ecx

; 421  : 	((uint *)ctx->in)[15] = ctx->bits[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx+24], eax

; 422  : 
; 423  : 	MD5Transform( ctx->buf, (uint *)ctx->in );

	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Transform
	add	esp, 8

; 424  : 	memcpy( digest, ctx->buf, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _ctx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _digest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 425  : 	memset( ctx, 0, sizeof( *ctx ));	// in case it's sensitive

	push	88					; 00000058H
	push	0
	mov	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 426  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5Final ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5Update
_TEXT	SEGMENT
tv71 = -76						; size = 4
_p$1 = -8						; size = 4
_t$ = -4						; size = 4
_ctx$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_MD5Update PROC						; COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 336  : 	uint	t;
; 337  : 
; 338  : 	// update bitcount
; 339  : 	t = ctx->bits[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _t$[ebp], eax

; 340  : 
; 341  : 	if(( ctx->bits[0] = t + ((uint) len << 3 )) < t )

	mov	eax, DWORD PTR _len$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, eax
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, DWORD PTR tv71[ebp]
	cmp	eax, DWORD PTR _t$[ebp]
	jae	SHORT $LN4@MD5Update

; 342  : 		ctx->bits[1]++;	// carry from low to high

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	add	edx, 1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+eax+16], edx
$LN4@MD5Update:

; 343  : 	ctx->bits[1] += len >> 29;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _len$[ebp]
	shr	ecx, 29					; 0000001dH
	mov	edx, DWORD PTR _ctx$[ebp]
	add	ecx, DWORD PTR [edx+eax+16]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [edx+eax+16], ecx

; 344  : 
; 345  : 	t = (t >> 3) & 0x3f;	// bytes already in shsInfo->data

	mov	eax, DWORD PTR _t$[ebp]
	shr	eax, 3
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _t$[ebp], eax

; 346  : 
; 347  : 	// handle any leading odd-sized chunks
; 348  : 	if( t )

	je	SHORT $LN2@MD5Update

; 349  : 	{
; 350  : 		byte	*p = (byte *)ctx->in + t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _ctx$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24]
	mov	DWORD PTR _p$1[ebp], edx

; 351  : 
; 352  : 		t = 64 - t;

	mov	eax, 64					; 00000040H
	sub	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 353  : 		if( len < t )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _t$[ebp]
	jae	SHORT $LN6@MD5Update

; 354  : 		{
; 355  : 			memcpy( p, buf, len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$1[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 356  : 			return;

	jmp	$LN1@MD5Update
$LN6@MD5Update:

; 357  : 		}
; 358  : 
; 359  : 		memcpy( p, buf, t );

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$1[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 360  : 		MD5Transform( ctx->buf, (uint *)ctx->in );

	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Transform
	add	esp, 8

; 361  : 		buf += t;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _buf$[ebp], eax

; 362  : 		len -= t;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN2@MD5Update:

; 363  : 	}
; 364  : 
; 365  : 	// process data in 64-byte chunks
; 366  : 	while( len >= 64 )

	cmp	DWORD PTR _len$[ebp], 64		; 00000040H
	jb	SHORT $LN3@MD5Update

; 367  : 	{
; 368  : 		memcpy( ctx->in, buf, 64 );

	push	64					; 00000040H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 369  : 		MD5Transform( ctx->buf, (uint *)ctx->in );

	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Transform
	add	esp, 8

; 370  : 		buf += 64;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _buf$[ebp], eax

; 371  : 		len -= 64;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 64					; 00000040H
	mov	DWORD PTR _len$[ebp], eax

; 372  : 	}

	jmp	SHORT $LN2@MD5Update
$LN3@MD5Update:

; 373  : 
; 374  : 	// handle any remaining bytes of data.
; 375  : 	memcpy( ctx->in, buf, len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctx$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@MD5Update:

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5Update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _MD5Init
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_MD5Init PROC						; COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 318  : 	ctx->buf[0] = 0x67452301;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [edx+ecx], 1732584193		; 67452301H

; 319  : 	ctx->buf[1] = 0xefcdab89;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+eax], -271733879		; efcdab89H

; 320  : 	ctx->buf[2] = 0x98badcfe;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+eax], -1732584194	; 98badcfeH

; 321  : 	ctx->buf[3] = 0x10325476;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [edx+ecx], 271733878		; 10325476H

; 322  : 
; 323  : 	ctx->bits[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [edx+ecx+16], 0

; 324  : 	ctx->bits[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+eax+16], 0

; 325  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MD5Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_MapFile
_TEXT	SEGMENT
tv84 = -1508						; size = 4
_f$ = -1312						; size = 4
_header$ = -1308					; size = 4
_hdr_size$ = -1304					; size = 4
_version$ = -1300					; size = 4
_lumplen$ = -1296					; size = 4
_num_bytes$ = -1292					; size = 4
_i$ = -1288						; size = 4
_buffer$ = -1284					; size = 1024
_headbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_crcvalue$ = 8						; size = 4
_filename$ = 12						; size = 4
_multiplayer$ = 16					; size = 4
_CRC32_MapFile PROC					; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1508				; 000005e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 232  : 	char	headbuf[256], buffer[1024];
; 233  : 	int	i, num_bytes, lumplen;
; 234  : 	int	version, hdr_size;
; 235  : 	dheader_t	*header;
; 236  : 	file_t	*f;
; 237  : 
; 238  : 	if( !crcvalue ) return false;

	cmp	DWORD PTR _crcvalue$[ebp], 0
	jne	SHORT $LN9@CRC32_MapF
	xor	eax, eax
	jmp	$LN1@CRC32_MapF
$LN9@CRC32_MapF:

; 239  : 
; 240  : 	// always calc same checksum for singleplayer
; 241  : 	if( multiplayer == false )

	cmp	DWORD PTR _multiplayer$[ebp], 0
	jne	SHORT $LN10@CRC32_MapF

; 242  : 	{
; 243  : 		*crcvalue = (('H'<<24)+('S'<<16)+('A'<<8)+'X');

	mov	eax, DWORD PTR _crcvalue$[ebp]
	mov	DWORD PTR [eax], 1213415768		; 48534158H

; 244  : 		return true;

	mov	eax, 1
	jmp	$LN1@CRC32_MapF
$LN10@CRC32_MapF:

; 245  : 	}
; 246  : 
; 247  : 	f = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 248  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN11@CRC32_MapF
	xor	eax, eax
	jmp	$LN1@CRC32_MapF
$LN11@CRC32_MapF:

; 249  : 
; 250  : 	// read version number
; 251  : 	FS_Read( f, &version, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 252  : 	FS_Seek( f, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 253  : 
; 254  : 	hdr_size = sizeof( int ) + sizeof( dlump_t ) * HEADER_LUMPS;

	mov	DWORD PTR _hdr_size$[ebp], 124		; 0000007cH

; 255  : 	num_bytes = FS_Read( f, headbuf, hdr_size );

	mov	eax, DWORD PTR _hdr_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _headbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _num_bytes$[ebp], eax

; 256  : 
; 257  : 	// corrupted map ?
; 258  : 	if( num_bytes != hdr_size )

	mov	eax, DWORD PTR _num_bytes$[ebp]
	cmp	eax, DWORD PTR _hdr_size$[ebp]
	je	SHORT $LN12@CRC32_MapF

; 259  : 	{
; 260  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 261  : 		return false;

	xor	eax, eax
	jmp	$LN1@CRC32_MapF
$LN12@CRC32_MapF:

; 262  : 	}
; 263  : 
; 264  : 	header = (dheader_t *)headbuf;

	lea	eax, DWORD PTR _headbuf$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 265  : 
; 266  : 	// invalid version ?
; 267  : 	switch( header->version )

	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 29			; 0000001dH
	je	SHORT $LN15@CRC32_MapF
	cmp	DWORD PTR tv84[ebp], 30			; 0000001eH
	je	SHORT $LN15@CRC32_MapF
	cmp	DWORD PTR tv84[ebp], 844124994		; 32505342H
	je	SHORT $LN15@CRC32_MapF
	jmp	SHORT $LN16@CRC32_MapF
$LN15@CRC32_MapF:

; 268  : 	{
; 269  : 	case Q1BSP_VERSION:
; 270  : 	case HLBSP_VERSION:
; 271  : 	case QBSP2_VERSION:
; 272  : 		break;

	jmp	SHORT $LN2@CRC32_MapF
$LN16@CRC32_MapF:

; 273  : 	default:
; 274  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 275  : 		return false;

	xor	eax, eax
	jmp	$LN1@CRC32_MapF
$LN2@CRC32_MapF:

; 276  : 	}
; 277  : 
; 278  : 	CRC32_Init( crcvalue );

	mov	eax, DWORD PTR _crcvalue$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 279  : 
; 280  : 	for( i = LUMP_PLANES; i < HEADER_LUMPS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN6@CRC32_MapF
$LN4@CRC32_MapF:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CRC32_MapF:
	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	jge	$LN5@CRC32_MapF

; 281  : 	{
; 282  : 		lumplen = header->lumps[i].filelen;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+8]
	mov	DWORD PTR _lumplen$[ebp], edx

; 283  : 		FS_Seek( f, header->lumps[i].fileofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH
$LN7@CRC32_MapF:

; 284  : 
; 285  : 		while( lumplen > 0 )

	cmp	DWORD PTR _lumplen$[ebp], 0
	jle	$LN8@CRC32_MapF

; 286  : 		{
; 287  : 			if( lumplen >= sizeof( buffer ))

	cmp	DWORD PTR _lumplen$[ebp], 1024		; 00000400H
	jb	SHORT $LN17@CRC32_MapF

; 288  : 				num_bytes = FS_Read( f, buffer, sizeof( buffer ));

	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _num_bytes$[ebp], eax
	jmp	SHORT $LN18@CRC32_MapF
$LN17@CRC32_MapF:

; 289  : 			else num_bytes = FS_Read( f, buffer, lumplen );

	mov	eax, DWORD PTR _lumplen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _num_bytes$[ebp], eax
$LN18@CRC32_MapF:

; 290  : 
; 291  : 			if( num_bytes > 0 )

	cmp	DWORD PTR _num_bytes$[ebp], 0
	jle	SHORT $LN19@CRC32_MapF

; 292  : 			{
; 293  : 				lumplen -= num_bytes;

	mov	eax, DWORD PTR _lumplen$[ebp]
	sub	eax, DWORD PTR _num_bytes$[ebp]
	mov	DWORD PTR _lumplen$[ebp], eax

; 294  : 				CRC32_ProcessBuffer( crcvalue, buffer, num_bytes );

	mov	eax, DWORD PTR _num_bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crcvalue$[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH
$LN19@CRC32_MapF:

; 295  : 			}
; 296  : 
; 297  : 			// file unexpected end ?
; 298  : 			if( FS_Eof( f )) break;

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@CRC32_MapF
	jmp	SHORT $LN8@CRC32_MapF
$LN20@CRC32_MapF:

; 299  : 		}

	jmp	$LN7@CRC32_MapF
$LN8@CRC32_MapF:

; 300  : 	}

	jmp	$LN4@CRC32_MapF
$LN5@CRC32_MapF:

; 301  : 
; 302  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 303  : 
; 304  : 	return 1;

	mov	eax, 1
$LN1@CRC32_MapF:

; 305  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_MapFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_File
_TEXT	SEGMENT
tv75 = -1232						; size = 4
_f$ = -1036						; size = 4
_num_bytes$ = -1032					; size = 4
_buffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_crcvalue$ = 8						; size = 4
_filename$ = 12						; size = 4
_CRC32_File PROC					; COMDAT

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1232				; 000004d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 206  : 	char	buffer[1024];
; 207  : 	int	num_bytes;
; 208  : 	file_t	*f;
; 209  : 
; 210  : 	f = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 211  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@CRC32_File
	xor	eax, eax
	jmp	$LN1@CRC32_File
$LN4@CRC32_File:

; 212  : 
; 213  : 	Assert( crcvalue != NULL );

	cmp	DWORD PTR _crcvalue$[ebp], 0
	je	SHORT $LN8@CRC32_File
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN9@CRC32_File
$LN8@CRC32_File:
	mov	DWORD PTR tv75[ebp], 0
$LN9@CRC32_File:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CRC32_File@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DD@MLICIGDA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BB@OKIBMNG@crcvalue?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv75[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 214  : 	CRC32_Init( crcvalue );

	mov	eax, DWORD PTR _crcvalue$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4
$LN2@CRC32_File:

; 215  : 
; 216  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@CRC32_File

; 217  : 	{
; 218  : 		num_bytes = FS_Read( f, buffer, sizeof( buffer ));

	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _num_bytes$[ebp], eax

; 219  : 
; 220  : 		if( num_bytes > 0 )

	cmp	DWORD PTR _num_bytes$[ebp], 0
	jle	SHORT $LN5@CRC32_File

; 221  : 			CRC32_ProcessBuffer( crcvalue, buffer, num_bytes );

	mov	eax, DWORD PTR _num_bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crcvalue$[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH
$LN5@CRC32_File:

; 222  : 
; 223  : 		if( FS_Eof( f )) break;

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@CRC32_File
	jmp	SHORT $LN3@CRC32_File
$LN6@CRC32_File:

; 224  : 	}

	jmp	SHORT $LN2@CRC32_File
$LN3@CRC32_File:

; 225  : 
; 226  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 227  : 	return true;

	mov	eax, 1
$LN1@CRC32_File:

; 228  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_File ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_Final
_TEXT	SEGMENT
_pulCRC$ = 8						; size = 4
_CRC32_Final PROC					; COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 98   : 	return pulCRC ^ CRC32_XOR_VALUE;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	xor	eax, -1

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_Final ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_ProcessByte
_TEXT	SEGMENT
_ulCrc$ = -4						; size = 4
_pulCRC$ = 8						; size = 4
_ch$ = 12						; size = 1
_CRC32_ProcessByte PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 103  : 	dword	ulCrc = *pulCRC;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 104  : 
; 105  : 	ulCrc ^= ch;

	movzx	eax, BYTE PTR _ch$[ebp]
	xor	eax, DWORD PTR _ulCrc$[ebp]
	mov	DWORD PTR _ulCrc$[ebp], eax

; 106  : 	ulCrc = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 107  : 	*pulCRC = ulCrc;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	mov	DWORD PTR [eax], ecx

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_ProcessByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_ProcessBuffer
_TEXT	SEGMENT
tv200 = -84						; size = 4
tv169 = -84						; size = 4
tv64 = -84						; size = 4
_nMain$ = -16						; size = 4
_nFront$ = -12						; size = 4
_pb$ = -8						; size = 4
_ulCrc$ = -4						; size = 4
_pulCRC$ = 8						; size = 4
_pBuffer$ = 12						; size = 4
_nBuffer$ = 16						; size = 4
_CRC32_ProcessBuffer PROC				; COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 112  : 	dword	ulCrc = *pulCRC;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 113  : 	byte	*pb = (byte *)pBuffer;

	mov	eax, DWORD PTR _pBuffer$[ebp]
	mov	DWORD PTR _pb$[ebp], eax
$JustAfew$21:

; 114  : 	uint	nFront;
; 115  : 	int	nMain;
; 116  : JustAfew:
; 117  : 	switch( nBuffer )

	mov	eax, DWORD PTR _nBuffer$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN2@CRC32_Proc
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN20@CRC32_Proc[ecx*4]
$LN8@CRC32_Proc:

; 118  : 	{
; 119  : 	case 7: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN9@CRC32_Proc:

; 120  : 	case 6: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN10@CRC32_Proc:

; 121  : 	case 5: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN11@CRC32_Proc:

; 122  : 	case 4:
; 123  : 		ulCrc ^= *(dword *)pb;	// warning, this only works on little-endian.

	mov	eax, DWORD PTR _pb$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	xor	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 124  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 125  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 126  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 127  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 128  : 		*pulCRC = ulCrc;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	mov	DWORD PTR [eax], ecx

; 129  : 		return;

	jmp	$LN1@CRC32_Proc
$LN12@CRC32_Proc:

; 130  : 	case 3: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN13@CRC32_Proc:

; 131  : 	case 2: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN14@CRC32_Proc:

; 132  : 	case 1: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN15@CRC32_Proc:

; 133  : 	case 0: *pulCRC = ulCrc;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	mov	DWORD PTR [eax], ecx

; 134  : 		return;

	jmp	$LN1@CRC32_Proc
$LN2@CRC32_Proc:

; 135  : 	}
; 136  : 
; 137  : 	// We may need to do some alignment work up front, and at the end, so that
; 138  : 	// the main loop is aligned and only has to worry about 8 byte at a time.
; 139  : 	// The low-order two bits of pb and nBuffer in total control the
; 140  : 	// upfront work.
; 141  : 	nFront = ((uint)pb) & 3;

	mov	eax, DWORD PTR _pb$[ebp]
	and	eax, 3
	mov	DWORD PTR _nFront$[ebp], eax

; 142  : 	nBuffer -= nFront;

	mov	eax, DWORD PTR _nBuffer$[ebp]
	sub	eax, DWORD PTR _nFront$[ebp]
	mov	DWORD PTR _nBuffer$[ebp], eax

; 143  : 
; 144  : 	switch( nFront )

	mov	eax, DWORD PTR _nFront$[ebp]
	mov	DWORD PTR tv169[ebp], eax
	cmp	DWORD PTR tv169[ebp], 1
	je	SHORT $LN18@CRC32_Proc
	cmp	DWORD PTR tv169[ebp], 2
	je	SHORT $LN17@CRC32_Proc
	cmp	DWORD PTR tv169[ebp], 3
	je	SHORT $LN16@CRC32_Proc
	jmp	SHORT $LN4@CRC32_Proc
$LN16@CRC32_Proc:

; 145  : 	{
; 146  : 	case 3: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN17@CRC32_Proc:

; 147  : 	case 2: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN18@CRC32_Proc:

; 148  : 	case 1: ulCrc  = crc32table[*pb++ ^ (byte)ulCrc] ^ (ulCrc >> 8);

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _ulCrc$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _ulCrc$[ebp]
	shr	eax, 8
	xor	eax, DWORD PTR _crc32table[ecx*4]
	mov	DWORD PTR _ulCrc$[ebp], eax
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx
$LN4@CRC32_Proc:

; 149  : 	}
; 150  : 
; 151  : 	nMain = nBuffer >> 3;

	mov	eax, DWORD PTR _nBuffer$[ebp]
	sar	eax, 3
	mov	DWORD PTR _nMain$[ebp], eax
$LN6@CRC32_Proc:

; 152  : 	while( nMain-- )

	mov	eax, DWORD PTR _nMain$[ebp]
	mov	DWORD PTR tv200[ebp], eax
	mov	ecx, DWORD PTR _nMain$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nMain$[ebp], ecx
	cmp	DWORD PTR tv200[ebp], 0
	je	$LN7@CRC32_Proc

; 153  : 	{
; 154  : 		ulCrc ^= *(dword *)pb;	// warning, this only works on little-endian.

	mov	eax, DWORD PTR _pb$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	xor	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 155  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 156  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 157  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 158  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 159  : 		ulCrc ^= *(dword *)(pb + 4);// warning, this only works on little-endian.

	mov	eax, DWORD PTR _pb$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	xor	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 160  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 161  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 162  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 163  : 		ulCrc  = crc32table[(byte)ulCrc] ^ (ulCrc >> 8);

	movzx	eax, BYTE PTR _ulCrc$[ebp]
	mov	ecx, DWORD PTR _ulCrc$[ebp]
	shr	ecx, 8
	xor	ecx, DWORD PTR _crc32table[eax*4]
	mov	DWORD PTR _ulCrc$[ebp], ecx

; 164  : 		pb += 8;

	mov	eax, DWORD PTR _pb$[ebp]
	add	eax, 8
	mov	DWORD PTR _pb$[ebp], eax

; 165  : 	}

	jmp	$LN6@CRC32_Proc
$LN7@CRC32_Proc:

; 166  : 
; 167  : 	nBuffer &= 7;

	mov	eax, DWORD PTR _nBuffer$[ebp]
	and	eax, 7
	mov	DWORD PTR _nBuffer$[ebp], eax

; 168  : 	goto JustAfew;

	jmp	$JustAfew$21
$LN1@CRC32_Proc:

; 169  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@CRC32_Proc:
	DD	$LN15@CRC32_Proc
	DD	$LN14@CRC32_Proc
	DD	$LN13@CRC32_Proc
	DD	$LN12@CRC32_Proc
	DD	$LN11@CRC32_Proc
	DD	$LN10@CRC32_Proc
	DD	$LN9@CRC32_Proc
	DD	$LN8@CRC32_Proc
_CRC32_ProcessBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_BlockSequence
_TEXT	SEGMENT
_buffer$ = -76						; size = 64
_ptr$ = -12						; size = 4
_CRC$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_base$ = 8						; size = 4
_length$ = 12						; size = 4
_sequence$ = 16						; size = 4
_CRC32_BlockSequence PROC				; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 180  : 	dword	CRC;
; 181  : 	char	*ptr;
; 182  : 	char	buffer[64];
; 183  : 
; 184  : 	if( sequence < 0 ) sequence = abs( sequence );

	cmp	DWORD PTR _sequence$[ebp], 0
	jge	SHORT $LN2@CRC32_Bloc
	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _sequence$[ebp], eax
$LN2@CRC32_Bloc:

; 185  : 	ptr = (char *)crc32table + (sequence % 0x3FC);

	mov	eax, DWORD PTR _sequence$[ebp]
	cdq
	mov	ecx, 1020				; 000003fcH
	idiv	ecx
	add	edx, OFFSET _crc32table
	mov	DWORD PTR _ptr$[ebp], edx

; 186  : 
; 187  : 	if( length > 60 ) length = 60;

	cmp	DWORD PTR _length$[ebp], 60		; 0000003cH
	jle	SHORT $LN3@CRC32_Bloc
	mov	DWORD PTR _length$[ebp], 60		; 0000003cH
$LN3@CRC32_Bloc:

; 188  : 	memcpy( buffer, base, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 189  : 
; 190  : 	buffer[length+0] = ptr[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _buffer$[ebp+edx], cl

; 191  : 	buffer[length+1] = ptr[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _buffer$[ebp+ecx+1], al

; 192  : 	buffer[length+2] = ptr[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _buffer$[ebp+ecx+2], al

; 193  : 	buffer[length+3] = ptr[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _buffer$[ebp+edx+3], cl

; 194  : 
; 195  : 	length += 4;

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 4
	mov	DWORD PTR _length$[ebp], eax

; 196  : 
; 197  : 	CRC32_Init( &CRC );

	lea	eax, DWORD PTR _CRC$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 198  : 	CRC32_ProcessBuffer( &CRC, buffer, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _CRC$[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 199  : 	CRC = CRC32_Final( CRC );

	mov	eax, DWORD PTR _CRC$[ebp]
	push	eax
	call	_CRC32_Final
	add	esp, 4
	mov	DWORD PTR _CRC$[ebp], eax

; 200  : 
; 201  : 	return (byte)CRC;

	movzx	eax, BYTE PTR _CRC$[ebp]

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_BlockSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crclib.c
;	COMDAT _CRC32_Init
_TEXT	SEGMENT
_pulCRC$ = 8						; size = 4
_CRC32_Init PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 93   : 	*pulCRC = CRC32_INIT_VALUE;

	mov	eax, DWORD PTR _pulCRC$[ebp]
	mov	DWORD PTR [eax], -1

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CRC32_Init ENDP
_TEXT	ENDS
END
