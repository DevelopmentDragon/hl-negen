; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\console.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_color_table
_DATA	SEGMENT
COMM	_con_fontsize:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_con_notifytime:DWORD
COMM	_scr_conspeed:DWORD
_DATA	ENDS
_DATA	SEGMENT
_g_color_table DB 00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0f0H
	DB	0b4H
	DB	018H
	DB	0ffH
_DATA	ENDS
PUBLIC	_Con_Reportf
PUBLIC	_Con_DPrintf
PUBLIC	_Con_Printf
PUBLIC	_Con_Init
PUBLIC	_Con_Print
PUBLIC	_Con_NPrintf
PUBLIC	_Con_NXPrintf
PUBLIC	_UI_NPrintf
PUBLIC	_UI_NXPrintf
PUBLIC	_Cmd_AutoComplete
PUBLIC	_Con_Visible
PUBLIC	_Con_FixedFont
PUBLIC	_Con_VidInit
PUBLIC	_Con_Shutdown
PUBLIC	_Con_ToggleConsole_f
PUBLIC	_Con_ClearNotify
PUBLIC	_Con_DrawDebug
PUBLIC	_Con_RunConsole
PUBLIC	_Con_DrawConsole
PUBLIC	_Con_DrawVersion
PUBLIC	_Con_DrawStringLen
PUBLIC	_Con_DrawString
PUBLIC	_Con_DrawCharacter
PUBLIC	_Con_DrawCharacterLen
PUBLIC	_Con_DefaultColor
PUBLIC	_Con_InvalidateFonts
PUBLIC	_Con_SetFont
PUBLIC	_Con_CharEvent
PUBLIC	_Con_RestoreFont
PUBLIC	_Key_Console
PUBLIC	_Key_Message
PUBLIC	_Con_FastClose
PUBLIC	_Field_CharEvent
PUBLIC	_Con_Clear_f
PUBLIC	_Con_SetColor_f
PUBLIC	_Con_ClearField
PUBLIC	_Con_ClearTyping
PUBLIC	_Con_StringLength
PUBLIC	_Con_MessageMode_f
PUBLIC	_Con_MessageMode2_f
PUBLIC	_Con_SetTimes_f
PUBLIC	_Con_FixTimes
PUBLIC	_Con_DeleteLine
PUBLIC	_Con_DeleteLastLine
PUBLIC	_Con_AddLine
PUBLIC	_Con_CheckResize
PUBLIC	_Con_PageUp
PUBLIC	_Con_PageDown
PUBLIC	_Con_Top
PUBLIC	_Con_Bottom
PUBLIC	_Con_DrawGenericString
PUBLIC	_Con_CompleteCommand
PUBLIC	_Field_Paste
PUBLIC	_Field_KeyDownEvent
PUBLIC	_Field_DrawInputLine
PUBLIC	_Con_DrawInput
PUBLIC	_Con_DrawDebugLines
PUBLIC	_Con_DrawNotify
PUBLIC	_Con_DrawConsoleLine
PUBLIC	_Con_DrawSolidConsole
PUBLIC	??_C@_0BJ@ELGMFDFE@?$CCcon_color?$CC?5is?5?$CFi?5?$CFi?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0BK@LJJAIAPH@Usage?3?5con_color?5?$CCr?5g?5b?$CC?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Con_ClearTyping@@9@9		; `Con_ClearTyping'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_03BANJEMDJ@say@				; `string'
PUBLIC	??_C@_08NBFNGOHN@say_team@			; `string'
PUBLIC	??_C@_0O@DOOGBBKD@sv_background@		; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_0BL@MLFKPALA@Usage?3?5contimes?5?$DMn?5lines?$DO?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Con_AddLine@@9@9		; `Con_AddLine'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Con_LoadVariableWidthFont@@9@9	; `Con_LoadVariableWidthFont'::`1'::__LINE__Var
PUBLIC	??_C@_08MANNGIAP@?9oldfont@			; `string'
PUBLIC	??_C@_0BF@BPDLPEHF@gfx?4wad?1conchars?4fnt@	; `string'
PUBLIC	??_C@_0BB@GOBNJLKD@fonts?4wad?1font?$CFi@	; `string'
PUBLIC	??_C@_0N@POKADIKD@gfx?1conchars@		; `string'
PUBLIC	?__LINE__Var@?0??Con_Init@@9@9			; `Con_Init'::`1'::__LINE__Var
PUBLIC	??_C@_0BF@CAMOCHIE@console?5moving?5speed@	; `string'
PUBLIC	??_C@_03PANGFEPN@600@				; `string'
PUBLIC	??_C@_0N@MGJFCGAP@scr_conspeed@			; `string'
PUBLIC	??_C@_0BE@IFHMLKJ@notify?5time?5to?5live@	; `string'
PUBLIC	??_C@_01EKENIIDA@3@				; `string'
PUBLIC	??_C@_0P@INMLCMIF@con_notifytime@		; `string'
PUBLIC	??_C@_0CA@IPEAEPHH@console?5font?5number?5?$CI0?0?51?5or?52?$CJ@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0N@IHPBPOML@con_fontsize@			; `string'
PUBLIC	??_C@_0BM@NLDOPNPC@opens?5or?5closes?5the?5console@ ; `string'
PUBLIC	??_C@_0O@JJBKLGLG@toggleconsole@		; `string'
PUBLIC	??_C@_0BL@DCHKFMKF@set?5a?5custom?5console?5color@ ; `string'
PUBLIC	??_C@_09PPDAPOC@con_color@			; `string'
PUBLIC	??_C@_0BG@IHNLBNJN@clear?5console?5history@	; `string'
PUBLIC	??_C@_05MEHLAELG@clear@				; `string'
PUBLIC	??_C@_0BK@JLLANAOF@enable?5message?5mode?5?$CCsay?$CC@ ; `string'
PUBLIC	??_C@_0M@JINOELJH@messagemode@			; `string'
PUBLIC	??_C@_0BP@LJHCNEMD@enable?5message?5mode?5?$CCsay_team?$CC@ ; `string'
PUBLIC	??_C@_0N@IDIDIMNN@messagemode2@			; `string'
PUBLIC	??_C@_0CO@EHLOLBON@change?5number?5of?5console?5overla@ ; `string'
PUBLIC	??_C@_08CJIJIFFE@contimes@			; `string'
PUBLIC	??_C@_0BG@PCBGEEM@Console?5initialized?4?6@	; `string'
PUBLIC	?__LINE__Var@?0??Con_Shutdown@@9@9		; `Con_Shutdown'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Con_AddCommandToList@@9@9	; `Con_AddCommandToList'::`1'::__LINE__Var
PUBLIC	??_C@_0P@IMEIJKPK@?5?5?5?5?$CFs?5?$FO3?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_07FBMPDAOB@?5?5?5?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BG@IIHNMGJ@?5?5?5?5?$CFs?5?$CI?$CFs?$CJ?5?5?5?$FO3?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0O@MOEFDAMM@?5?5?5?5?$CFs?5?5?$CI?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	?__LINE__Var@?0??Con_CompleteCommand@@9@9	; `Con_CompleteCommand'::`1'::__LINE__Var
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs@			; `string'
PUBLIC	??_C@_03GFPEDOMH@?2?$CFs@			; `string'
PUBLIC	??_C@_04MCOKGCBH@?$FN?$CFs?6@			; `string'
PUBLIC	??_C@_06NICJIFDH@clear?6@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_04BMHIGPIK@?$DO?$CFs?6@			; `string'
PUBLIC	??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0DJ@HGANGLHK@Downloading?5?$FL?$CFd?5remaining?$FN?3?5?$FO2?$CF@ ; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5@			; `string'
PUBLIC	??_C@_04PNCPDLMM@0?499@				; `string'
PUBLIC	??_C@_0BL@LCJADJBF@Xash3D?5?$CFi?1?$CFs?5?$CIhw?5build?5?$CFi?$CJ@ ; `string'
PUBLIC	??_C@_0BJ@JEMCKMEL@Xash3D?5v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@ ; `string'
PUBLIC	??_C@_0BC@PNIBJGBA@v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??Con_VidInit@@9@9		; `Con_VidInit'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@HHLPGLEH@gfx?1shell?1conback?4bmp@	; `string'
PUBLIC	??_C@_0BG@FMIDMFMC@gfx?1shell?1conback?4tga@	; `string'
PUBLIC	??_C@_0BC@DJCOGMDD@gfx?1shell?1conback@		; `string'
PUBLIC	??_C@_0BC@NLNHOONG@cached?1conback640@		; `string'
PUBLIC	??_C@_0P@OOIJEEJJ@cached?1conback@		; `string'
PUBLIC	??_C@_0BG@ECMKGMDP@gfx?1shell?1loading?4bmp@	; `string'
PUBLIC	??_C@_0BG@GJPGMCLK@gfx?1shell?1loading?4tga@	; `string'
PUBLIC	??_C@_0BC@PPMBMNFK@gfx?1shell?1loading@		; `string'
PUBLIC	??_C@_0BC@BLHIGMPO@cached?1loading640@		; `string'
PUBLIC	??_C@_0P@CIGGOFPA@cached?1loading@		; `string'
PUBLIC	??_C@_03BBBGPMCE@id1@				; `string'
PUBLIC	??_C@_08BJJGNCOA@hipnotic@			; `string'
PUBLIC	??_C@_05PPPEOIOJ@rogue@				; `string'
PUBLIC	??_C@_0BA@HPEGNDIC@gfx?1conback?4lmp@		; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi@				; `string'
PUBLIC	??_C@_0BB@CHCLAABE@?$CDgfx?1conback?4lmp@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f866666
PUBLIC	__real@3f99999a
PUBLIC	__real@40000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@437f0000
PUBLIC	__real@bf800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_GetClipboardData:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Sys_Print:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_LookupCmds:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_atov:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_LookupVars:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Q_buildnum:PROC
EXTRN	_Key_IsDown:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_SCR_UpdateScreen:PROC
EXTRN	_Cmd_AutocompleteName:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_fabs:PROC
EXTRN	_CL_IsDevOverviewMode:PROC
EXTRN	_SCR_DrawFPS:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_scr_download:DWORD
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_net_graph:DWORD
EXTRN	_tr:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_con	DB	0140a0H DUP (?)
?cr_pending@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::cr_pending
?buf@?1??Con_Print@@9@9 DB 02000H DUP (?)		; `Con_Print'::`2'::buf
?inupdate@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::inupdate
?bufpos@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::bufpos
?buffer@?1??Con_Printf@@9@9 DB 02000H DUP (?)		; `Con_Printf'::`2'::buffer
?buffer@?1??Con_DPrintf@@9@9 DB 02020H DUP (?)		; `Con_DPrintf'::`2'::buffer
?buffer@?1??Con_Reportf@@9@9 DB 02020H DUP (?)		; `Con_Reportf'::`2'::buffer
	ALIGN	8

?timeStart@?1??Con_DrawDebug@@9@9 DQ 01H DUP (?)	; `Con_DrawDebug'::`2'::timeStart
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f866666
CONST	SEGMENT
__real@3f866666 DD 03f866666r			; 1.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BB@CHCLAABE@?$CDgfx?1conback?4lmp@
CONST	SEGMENT
??_C@_0BB@CHCLAABE@?$CDgfx?1conback?4lmp@ DB '#gfx/conback.lmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPEGNDIC@gfx?1conback?4lmp@
CONST	SEGMENT
??_C@_0BA@HPEGNDIC@gfx?1conback?4lmp@ DB 'gfx/conback.lmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPPEOIOJ@rogue@
CONST	SEGMENT
??_C@_05PPPEOIOJ@rogue@ DB 'rogue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJJGNCOA@hipnotic@
CONST	SEGMENT
??_C@_08BJJGNCOA@hipnotic@ DB 'hipnotic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBBGPMCE@id1@
CONST	SEGMENT
??_C@_03BBBGPMCE@id1@ DB 'id1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CIGGOFPA@cached?1loading@
CONST	SEGMENT
??_C@_0P@CIGGOFPA@cached?1loading@ DB 'cached/loading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BLHIGMPO@cached?1loading640@
CONST	SEGMENT
??_C@_0BC@BLHIGMPO@cached?1loading640@ DB 'cached/loading640', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPMBMNFK@gfx?1shell?1loading@
CONST	SEGMENT
??_C@_0BC@PPMBMNFK@gfx?1shell?1loading@ DB 'gfx/shell/loading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJPGMCLK@gfx?1shell?1loading?4tga@
CONST	SEGMENT
??_C@_0BG@GJPGMCLK@gfx?1shell?1loading?4tga@ DB 'gfx/shell/loading.tga', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECMKGMDP@gfx?1shell?1loading?4bmp@
CONST	SEGMENT
??_C@_0BG@ECMKGMDP@gfx?1shell?1loading?4bmp@ DB 'gfx/shell/loading.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOIJEEJJ@cached?1conback@
CONST	SEGMENT
??_C@_0P@OOIJEEJJ@cached?1conback@ DB 'cached/conback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLNHOONG@cached?1conback640@
CONST	SEGMENT
??_C@_0BC@NLNHOONG@cached?1conback640@ DB 'cached/conback640', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJCOGMDD@gfx?1shell?1conback@
CONST	SEGMENT
??_C@_0BC@DJCOGMDD@gfx?1shell?1conback@ DB 'gfx/shell/conback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMIDMFMC@gfx?1shell?1conback?4tga@
CONST	SEGMENT
??_C@_0BG@FMIDMFMC@gfx?1shell?1conback?4tga@ DB 'gfx/shell/conback.tga', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HHLPGLEH@gfx?1shell?1conback?4bmp@
CONST	SEGMENT
??_C@_0BG@HHLPGLEH@gfx?1shell?1conback?4bmp@ DB 'gfx/shell/conback.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_VidInit@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_VidInit@@9@9 DD 0926H		; `Con_VidInit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@PNIBJGBA@v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@
CONST	SEGMENT
??_C@_0BC@PNIBJGBA@v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@ DB 'v%i/%s (build'
	DB	' %i)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JEMCKMEL@Xash3D?5v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@
CONST	SEGMENT
??_C@_0BJ@JEMCKMEL@Xash3D?5v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@ DB 'Xash3'
	DB	'D v%i/%s (build %i)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LCJADJBF@Xash3D?5?$CFi?1?$CFs?5?$CIhw?5build?5?$CFi?$CJ@
CONST	SEGMENT
??_C@_0BL@LCJADJBF@Xash3D?5?$CFi?1?$CFs?5?$CIhw?5build?5?$CFi?$CJ@ DB 'Xa'
	DB	'sh3D %i/%s (hw build %i)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNCPDLMM@0?499@
CONST	SEGMENT
??_C@_04PNCPDLMM@0?499@ DB '0.99', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HGANGLHK@Downloading?5?$FL?$CFd?5remaining?$FN?3?5?$FO2?$CF@
CONST	SEGMENT
??_C@_0DJ@HGANGLHK@Downloading?5?$FL?$CFd?5remaining?$FN?3?5?$FO2?$CF@ DB 'D'
	DB	'ownloading [%d remaining]: ^2%s^7 %5.1f%% time %.f secs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@ DB '%s "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMHIGPIK@?$DO?$CFs?6@
CONST	SEGMENT
??_C@_04BMHIGPIK@?$DO?$CFs?6@ DB '>%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NICJIFDH@clear?6@
CONST	SEGMENT
??_C@_06NICJIFDH@clear?6@ DB 'clear', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCOKGCBH@?$FN?$CFs?6@
CONST	SEGMENT
??_C@_04MCOKGCBH@?$FN?$CFs?6@ DB ']%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GFPEDOMH@?2?$CFs@
CONST	SEGMENT
??_C@_03GFPEDOMH@?2?$CFs@ DB '\%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_CompleteCommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_CompleteCommand@@9@9 DD 0557H	; `Con_CompleteCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MOEFDAMM@?5?5?5?5?$CFs?5?5?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0O@MOEFDAMM@?5?5?5?5?$CFs?5?5?$CI?$CFs?$CJ?6@ DB '    %s  (%s)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIHNMGJ@?5?5?5?5?$CFs?5?$CI?$CFs?$CJ?5?5?5?$FO3?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BG@IIHNMGJ@?5?5?5?5?$CFs?5?$CI?$CFs?$CJ?5?5?5?$FO3?$CC?$CFs?$CC?6@ DB ' '
	DB	'   %s (%s)   ^3"%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBMPDAOB@?5?5?5?5?$CFs?6@
CONST	SEGMENT
??_C@_07FBMPDAOB@?5?5?5?5?$CFs?6@ DB '    %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMEIJKPK@?5?5?5?5?$CFs?5?$FO3?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@IMEIJKPK@?5?5?5?5?$CFs?5?$FO3?$CC?$CFs?$CC?6@ DB '    %s ^3"%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_AddCommandToList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_AddCommandToList@@9@9 DD 04f9H	; `Con_AddCommandToList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Con_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_Shutdown@@9@9 DD 03e2H		; `Con_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@PCBGEEM@Console?5initialized?4?6@
CONST	SEGMENT
??_C@_0BG@PCBGEEM@Console?5initialized?4?6@ DB 'Console initialized.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJIJIFFE@contimes@
CONST	SEGMENT
??_C@_08CJIJIFFE@contimes@ DB 'contimes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EHLOLBON@change?5number?5of?5console?5overla@
CONST	SEGMENT
??_C@_0CO@EHLOLBON@change?5number?5of?5console?5overla@ DB 'change number'
	DB	' of console overlay lines (4-64)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDIDIMNN@messagemode2@
CONST	SEGMENT
??_C@_0N@IDIDIMNN@messagemode2@ DB 'messagemode2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJHCNEMD@enable?5message?5mode?5?$CCsay_team?$CC@
CONST	SEGMENT
??_C@_0BP@LJHCNEMD@enable?5message?5mode?5?$CCsay_team?$CC@ DB 'enable me'
	DB	'ssage mode "say_team"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JINOELJH@messagemode@
CONST	SEGMENT
??_C@_0M@JINOELJH@messagemode@ DB 'messagemode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JLLANAOF@enable?5message?5mode?5?$CCsay?$CC@
CONST	SEGMENT
??_C@_0BK@JLLANAOF@enable?5message?5mode?5?$CCsay?$CC@ DB 'enable message'
	DB	' mode "say"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear@
CONST	SEGMENT
??_C@_05MEHLAELG@clear@ DB 'clear', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IHNLBNJN@clear?5console?5history@
CONST	SEGMENT
??_C@_0BG@IHNLBNJN@clear?5console?5history@ DB 'clear console history', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PPDAPOC@con_color@
CONST	SEGMENT
??_C@_09PPDAPOC@con_color@ DB 'con_color', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DCHKFMKF@set?5a?5custom?5console?5color@
CONST	SEGMENT
??_C@_0BL@DCHKFMKF@set?5a?5custom?5console?5color@ DB 'set a custom conso'
	DB	'le color', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JJBKLGLG@toggleconsole@
CONST	SEGMENT
??_C@_0O@JJBKLGLG@toggleconsole@ DB 'toggleconsole', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NLDOPNPC@opens?5or?5closes?5the?5console@
CONST	SEGMENT
??_C@_0BM@NLDOPNPC@opens?5or?5closes?5the?5console@ DB 'opens or closes t'
	DB	'he console', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IHPBPOML@con_fontsize@
CONST	SEGMENT
??_C@_0N@IHPBPOML@con_fontsize@ DB 'con_fontsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IPEAEPHH@console?5font?5number?5?$CI0?0?51?5or?52?$CJ@
CONST	SEGMENT
??_C@_0CA@IPEAEPHH@console?5font?5number?5?$CI0?0?51?5or?52?$CJ@ DB 'cons'
	DB	'ole font number (0, 1 or 2)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@INMLCMIF@con_notifytime@
CONST	SEGMENT
??_C@_0P@INMLCMIF@con_notifytime@ DB 'con_notifytime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3@
CONST	SEGMENT
??_C@_01EKENIIDA@3@ DB '3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IFHMLKJ@notify?5time?5to?5live@
CONST	SEGMENT
??_C@_0BE@IFHMLKJ@notify?5time?5to?5live@ DB 'notify time to live', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MGJFCGAP@scr_conspeed@
CONST	SEGMENT
??_C@_0N@MGJFCGAP@scr_conspeed@ DB 'scr_conspeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PANGFEPN@600@
CONST	SEGMENT
??_C@_03PANGFEPN@600@ DB '600', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CAMOCHIE@console?5moving?5speed@
CONST	SEGMENT
??_C@_0BF@CAMOCHIE@console?5moving?5speed@ DB 'console moving speed', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_Init@@9@9 DD 03b0H			; `Con_Init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@POKADIKD@gfx?1conchars@
CONST	SEGMENT
??_C@_0N@POKADIKD@gfx?1conchars@ DB 'gfx/conchars', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOBNJLKD@fonts?4wad?1font?$CFi@
CONST	SEGMENT
??_C@_0BB@GOBNJLKD@fonts?4wad?1font?$CFi@ DB 'fonts.wad/font%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BPDLPEHF@gfx?4wad?1conchars?4fnt@
CONST	SEGMENT
??_C@_0BF@BPDLPEHF@gfx?4wad?1conchars?4fnt@ DB 'gfx.wad/conchars.fnt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MANNGIAP@?9oldfont@
CONST	SEGMENT
??_C@_08MANNGIAP@?9oldfont@ DB '-oldfont', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_LoadVariableWidthFont@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_LoadVariableWidthFont@@9@9 DD 024aH ; `Con_LoadVariableWidthFont'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_AddLine@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_AddLine@@9@9 DD 01b1H		; `Con_AddLine'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@MLFKPALA@Usage?3?5contimes?5?$DMn?5lines?$DO?6@
CONST	SEGMENT
??_C@_0BL@MLFKPALA@Usage?3?5contimes?5?$DMn?5lines?$DO?6@ DB 'Usage: cont'
	DB	'imes <n lines>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DOOGBBKD@sv_background@
CONST	SEGMENT
??_C@_0O@DOOGBBKD@sv_background@ DB 'sv_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBFNGOHN@say_team@
CONST	SEGMENT
??_C@_08NBFNGOHN@say_team@ DB 'say_team', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BANJEMDJ@say@
CONST	SEGMENT
??_C@_03BANJEMDJ@say@ DB 'say', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\console.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Con_ClearTyping@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Con_ClearTyping@@9@9 DD 0d0H		; `Con_ClearTyping'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@LJJAIAPH@Usage?3?5con_color?5?$CCr?5g?5b?$CC?6@
CONST	SEGMENT
??_C@_0BK@LJJAIAPH@Usage?3?5con_color?5?$CCr?5g?5b?$CC?6@ DB 'Usage: con_'
	DB	'color "r g b"', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ELGMFDFE@?$CCcon_color?$CC?5is?5?$CFi?5?$CFi?5?$CFi?6@
CONST	SEGMENT
??_C@_0BJ@ELGMFDFE@?$CCcon_color?$CC?5is?5?$CFi?5?$CFi?5?$CFi?6@ DB '"con'
	DB	'_color" is %i %i %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03b4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0285H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	048eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0216H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03d1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01acH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0154H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03a7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0beH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawSolidConsole
_TEXT	SEGMENT
tv207 = -372						; size = 4
tv146 = -372						; size = 4
_lastline$1 = -304					; size = 4
_ymax$2 = -300						; size = 4
_color$3 = -296						; size = 4
_curbuild$4 = -292					; size = 256
_charH$5 = -36						; size = 4
_width$6 = -32						; size = 4
_stringLen$7 = -28					; size = 4
_start$ = -24						; size = 4
_fraction$ = -20					; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lines$ = 8						; size = 4
_Con_DrawSolidConsole PROC				; COMDAT

; 2086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2087 : 	int	i, x, y;
; 2088 : 	float	fraction;
; 2089 : 	int	start;
; 2090 : 
; 2091 : 	if( lines <= 0 ) return;

	cmp	DWORD PTR _lines$[ebp], 0
	jg	SHORT $LN10@Con_DrawSo
	jmp	$LN1@Con_DrawSo
$LN10@Con_DrawSo:

; 2092 : 
; 2093 : 	// draw the background
; 2094 : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 2095 : 	pglColor4ub( 255, 255, 255, 255 ); // to prevent grab color from screenfade

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 2096 : 	R_DrawStretchPic( 0, lines - glState.height, glState.width, glState.height, 0, 0, 1, 1, con.background );

	mov	eax, DWORD PTR _con+48
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState+4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _lines$[ebp]
	sub	ecx, DWORD PTR _glState+4
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 2097 : 
; 2098 : 	if( !con.curFont || !host.allow_console )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN12@Con_DrawSo
	cmp	DWORD PTR _host+34336, 0
	jne	SHORT $LN11@Con_DrawSo
$LN12@Con_DrawSo:

; 2099 : 		return; // nothing to draw

	jmp	$LN1@Con_DrawSo
$LN11@Con_DrawSo:

; 2100 : 
; 2101 : 	if( host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	je	$LN3@Con_DrawSo

; 2102 : 	{
; 2103 : 		// draw current version
; 2104 : 		int	stringLen, width = 0, charH;

	mov	DWORD PTR _width$6[ebp], 0

; 2105 : 		string	curbuild;
; 2106 : 		byte	color[4];
; 2107 : 
; 2108 : 		memcpy( color, g_color_table[7], sizeof( color ));

	push	4
	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	lea	edx, DWORD PTR _color$3[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2109 : 
; 2110 : 		Q_snprintf( curbuild, MAX_STRING, "Xash3D %i/%s (hw build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( ));

	call	_Q_buildnum
	push	eax
	push	OFFSET ??_C@_04PNCPDLMM@0?499@
	push	49					; 00000031H
	push	OFFSET ??_C@_0BL@LCJADJBF@Xash3D?5?$CFi?1?$CFs?5?$CIhw?5build?5?$CFi?$CJ@
	push	256					; 00000100H
	lea	eax, DWORD PTR _curbuild$4[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 2111 : 		Con_DrawStringLen( curbuild, &stringLen, &charH );

	lea	eax, DWORD PTR _charH$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _stringLen$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _curbuild$4[ebp]
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2112 : 		start = glState.width - stringLen;

	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _stringLen$7[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 2113 : 		stringLen = Con_StringLength( curbuild );

	lea	eax, DWORD PTR _curbuild$4[ebp]
	push	eax
	call	_Con_StringLength
	add	esp, 4
	mov	DWORD PTR _stringLen$7[ebp], eax

; 2114 : 
; 2115 : 		fraction = lines / (float)glState.height;

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState+4
	divss	xmm0, xmm1
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2116 : 		color[3] = Q_min( fraction * 2.0f, 1.0f ) * 255; // fadeout version number

	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@Con_DrawSo
	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv146[ebp], xmm0
	jmp	SHORT $LN20@Con_DrawSo
$LN19@Con_DrawSo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
$LN20@Con_DrawSo:
	movss	xmm0, DWORD PTR tv146[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 1
	imul	ecx, eax, 3
	cvttss2si edx, xmm0
	mov	BYTE PTR _color$3[ebp+ecx], dl

; 2117 : 
; 2118 : 		for( i = 0; i < stringLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_DrawSo
$LN2@Con_DrawSo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_DrawSo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _stringLen$7[ebp]
	jge	SHORT $LN3@Con_DrawSo

; 2119 : 			width += Con_DrawCharacter( start + width, 0, curbuild[i], color );

	lea	eax, DWORD PTR _color$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _curbuild$4[ebp+ecx]
	push	edx
	push	0
	mov	eax, DWORD PTR _start$[ebp]
	add	eax, DWORD PTR _width$6[ebp]
	push	eax
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _width$6[ebp]
	mov	DWORD PTR _width$6[ebp], eax
	jmp	SHORT $LN2@Con_DrawSo
$LN3@Con_DrawSo:

; 2120 : 	}
; 2121 : 
; 2122 : 	// draw the text
; 2123 : 	if( CON_LINES_COUNT > 0 )

	cmp	DWORD PTR _con+24, 0
	jle	$LN9@Con_DrawSo

; 2124 : 	{
; 2125 : 		int	ymax = lines - (con.curFont->charHeight * 2.0f);

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	mov	eax, DWORD PTR _con+13156
	cvtsi2ss xmm1, DWORD PTR [eax+4356]
	mulss	xmm1, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _ymax$2[ebp], ecx

; 2126 : 		int	lastline;
; 2127 : 
; 2128 : 		Con_LastVisibleLine( &lastline );

	lea	eax, DWORD PTR _lastline$1[ebp]
	push	eax
	call	_Con_LastVisibleLine
	add	esp, 4

; 2129 : 		y = ymax - con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _ymax$2[ebp]
	sub	ecx, DWORD PTR [eax+4356]
	mov	DWORD PTR _y$[ebp], ecx

; 2130 : 
; 2131 : 		if( con.backscroll )

	cmp	DWORD PTR _con+32, 0
	je	SHORT $LN15@Con_DrawSo

; 2132 : 		{
; 2133 : 			start = con.curFont->charWidths[' ']; // offset one space at left screen side

	mov	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _con+13156
	movzx	edx, BYTE PTR [ecx+eax+4100]
	mov	DWORD PTR _start$[ebp], edx

; 2134 : 
; 2135 : 			// draw red arrows to show the buffer is backscrolled
; 2136 : 			for( x = 0; x < con.linewidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Con_DrawSo
$LN5@Con_DrawSo:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 4
	mov	DWORD PTR _x$[ebp], eax
$LN7@Con_DrawSo:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _con+36
	jge	SHORT $LN6@Con_DrawSo

; 2137 : 				Con_DrawCharacter(( x + 1 ) * start, y, '^', g_color_table[1] );

	mov	eax, 4
	shl	eax, 0
	add	eax, OFFSET _g_color_table
	push	eax
	push	94					; 0000005eH
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@Con_DrawSo
$LN6@Con_DrawSo:

; 2138 : 			y -= con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR [eax+4356]
	mov	DWORD PTR _y$[ebp], ecx
$LN15@Con_DrawSo:

; 2139 : 		}
; 2140 : 		x = lastline;

	mov	eax, DWORD PTR _lastline$1[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN8@Con_DrawSo:

; 2141 : 
; 2142 : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@Con_DrawSo

; 2143 : 		{
; 2144 : 			y -= Con_DrawConsoleLine( y, x );

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_Con_DrawConsoleLine
	add	esp, 8
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	mov	DWORD PTR _y$[ebp], edx

; 2145 : 
; 2146 : 			// top of console buffer or console window
; 2147 : 			if( x == 0 || y < con.curFont->charHeight ) 

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN17@Con_DrawSo
	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+4356]
	jge	SHORT $LN16@Con_DrawSo
$LN17@Con_DrawSo:

; 2148 : 				break;

	jmp	SHORT $LN9@Con_DrawSo
$LN16@Con_DrawSo:

; 2149 : 			x--;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 2150 : 		}

	jmp	SHORT $LN8@Con_DrawSo
$LN9@Con_DrawSo:

; 2151 : 	}
; 2152 : 
; 2153 : 	// draw the input prompt, user text, and cursor if desired
; 2154 : 	Con_DrawInput( lines );

	mov	eax, DWORD PTR _lines$[ebp]
	push	eax
	call	_Con_DrawInput
	add	esp, 4

; 2155 : 
; 2156 : 	y = lines - ( con.curFont->charHeight * 1.2f );

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	mov	eax, DWORD PTR _con+13156
	cvtsi2ss xmm1, DWORD PTR [eax+4356]
	mulss	xmm1, DWORD PTR __real@3f99999a
	subss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _y$[ebp], ecx

; 2157 : 	SCR_DrawFPS( max( y, 4 )); // to avoid to hide fps counter

	cmp	DWORD PTR _y$[ebp], 4
	jle	SHORT $LN21@Con_DrawSo
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN22@Con_DrawSo
$LN21@Con_DrawSo:
	mov	DWORD PTR tv207[ebp], 4
$LN22@Con_DrawSo:
	mov	ecx, DWORD PTR tv207[ebp]
	push	ecx
	call	_SCR_DrawFPS
	add	esp, 4

; 2158 : 
; 2159 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@Con_DrawSo:

; 2160 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawSolidConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_LastVisibleLine
_TEXT	SEGMENT
tv65 = -76						; size = 4
_lines_seen$ = -8					; size = 4
_i$ = -4						; size = 4
_lastline$ = 8						; size = 4
_Con_LastVisibleLine PROC				; COMDAT

; 2056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2057 : 	int	i, lines_seen = 0;

	mov	DWORD PTR _lines_seen$[ebp], 0

; 2058 : 
; 2059 : 	con.backscroll = Q_max( 0, con.backscroll );

	cmp	DWORD PTR _con+32, 0
	jge	SHORT $LN7@Con_LastVi
	mov	DWORD PTR tv65[ebp], 0
	jmp	SHORT $LN8@Con_LastVi
$LN7@Con_LastVi:
	mov	eax, DWORD PTR _con+32
	mov	DWORD PTR tv65[ebp], eax
$LN8@Con_LastVi:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _con+32, ecx

; 2060 : 	*lastline = 0;

	mov	eax, DWORD PTR _lastline$[ebp]
	mov	DWORD PTR [eax], 0

; 2061 : 
; 2062 : 	// now count until we saw con_backscroll actual lines
; 2063 : 	for( i = CON_LINES_COUNT - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Con_LastVi
$LN2@Con_LastVi:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LastVi:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@Con_LastVi

; 2064 : 	{
; 2065 : 		// line is the last visible line?
; 2066 : 		*lastline = i;

	mov	eax, DWORD PTR _lastline$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 2067 : 
; 2068 : 		if( lines_seen + 1 > con.backscroll && lines_seen <= con.backscroll )

	mov	eax, DWORD PTR _lines_seen$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _con+32
	jle	SHORT $LN5@Con_LastVi
	mov	eax, DWORD PTR _lines_seen$[ebp]
	cmp	eax, DWORD PTR _con+32
	jg	SHORT $LN5@Con_LastVi

; 2069 : 			return;

	jmp	SHORT $LN1@Con_LastVi
$LN5@Con_LastVi:

; 2070 : 
; 2071 : 		lines_seen += 1;

	mov	eax, DWORD PTR _lines_seen$[ebp]
	add	eax, 1
	mov	DWORD PTR _lines_seen$[ebp], eax

; 2072 : 	}

	jmp	SHORT $LN2@Con_LastVi
$LN3@Con_LastVi:

; 2073 : 
; 2074 : 	// if we get here, no line was on screen - scroll so that one line is visible then.
; 2075 : 	con.backscroll = lines_seen - 1;

	mov	eax, DWORD PTR _lines_seen$[ebp]
	sub	eax, 1
	mov	DWORD PTR _con+32, eax
$LN1@Con_LastVi:

; 2076 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LastVisibleLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawConsoleLine
_TEXT	SEGMENT
_li$ = -4						; size = 4
_y$ = 8							; size = 4
_lineno$ = 12						; size = 4
_Con_DrawConsoleLine PROC				; COMDAT

; 2035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2036 : 	con_lineinfo_t	*li = &CON_LINES( lineno );

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _lineno$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _li$[ebp], edx

; 2037 : 
; 2038 : 	if( *li->start == '\1' )

	mov	eax, DWORD PTR _li$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 1
	jne	SHORT $LN2@Con_DrawCo

; 2039 : 		return 0;	// this string will be shown only at notify

	xor	eax, eax
	jmp	SHORT $LN1@Con_DrawCo
$LN2@Con_DrawCo:

; 2040 : 
; 2041 : 	if( y >= con.curFont->charHeight )

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+4356]
	jl	SHORT $LN3@Con_DrawCo

; 2042 : 		Con_DrawGenericString( con.curFont->charWidths[' '], y, li->start, g_color_table[7], false, -1 );

	push	-1
	push	0
	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	mov	edx, DWORD PTR _li$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _con+13156
	movzx	ecx, BYTE PTR [eax+edx+4100]
	push	ecx
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H
$LN3@Con_DrawCo:

; 2043 : 
; 2044 : 	return con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	eax, DWORD PTR [eax+4356]
$LN1@Con_DrawCo:

; 2045 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawConsoleLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawNotify
_TEXT	SEGMENT
_len$1 = -288						; size = 4
_buf$2 = -284						; size = 256
_l$3 = -28						; size = 4
_y$ = -24						; size = 4
_x$ = -20						; size = 4
_i$ = -16						; size = 4
_time$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_Con_DrawNotify PROC					; COMDAT

; 1983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1984 : 	double	time = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _time$[ebp], xmm0

; 1985 : 	int	i, x, y = 0;

	mov	DWORD PTR _y$[ebp], 0

; 1986 : 
; 1987 : 	if( !con.curFont ) return;

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN5@Con_DrawNo
	jmp	$LN1@Con_DrawNo
$LN5@Con_DrawNo:

; 1988 : 
; 1989 : 	x = con.curFont->charWidths[' ']; // offset one space at left screen side

	mov	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _con+13156
	movzx	edx, BYTE PTR [ecx+eax+4100]
	mov	DWORD PTR _x$[ebp], edx

; 1990 : 
; 1991 : 	if( host_developer.value && ( !Cvar_VariableInteger( "cl_background" ) && !Cvar_VariableInteger( "sv_background" )))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@Con_DrawNo
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN3@Con_DrawNo
	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN3@Con_DrawNo

; 1992 : 	{
; 1993 : 		for( i = CON_LINES_COUNT - con.num_times; i < CON_LINES_COUNT; i++ )

	mov	eax, DWORD PTR _con+24
	sub	eax, DWORD PTR _con+28
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Con_DrawNo
$LN2@Con_DrawNo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_DrawNo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _con+24
	jge	SHORT $LN3@Con_DrawNo

; 1994 : 		{
; 1995 : 			con_lineinfo_t	*l = &CON_LINES( i );

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _l$3[ebp], edx

; 1996 : 
; 1997 : 			if( l->addtime < ( time - con_notifytime->value ))

	mov	eax, DWORD PTR _con_notifytime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _time$[ebp]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _l$3[ebp]
	comisd	xmm1, QWORD PTR [ecx+8]
	jbe	SHORT $LN7@Con_DrawNo

; 1998 : 				continue;

	jmp	SHORT $LN2@Con_DrawNo
$LN7@Con_DrawNo:

; 1999 : 
; 2000 : 			Con_DrawString( x, y, l->start, g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	mov	edx, DWORD PTR _l$3[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 2001 : 			y += con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR [eax+4356]
	mov	DWORD PTR _y$[ebp], ecx

; 2002 : 		}

	jmp	$LN2@Con_DrawNo
$LN3@Con_DrawNo:

; 2003 : 	}
; 2004 : 	
; 2005 : 	if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	$LN8@Con_DrawNo

; 2006 : 	{
; 2007 : 		string	buf;
; 2008 : 		int	len;
; 2009 : 
; 2010 : 		// update chatline position from client.dll
; 2011 : 		if( clgame.dllFuncs.pfnChatInputPosition )

	cmp	DWORD PTR _clgame+164, 0
	je	SHORT $LN9@Con_DrawNo

; 2012 : 			clgame.dllFuncs.pfnChatInputPosition( &x, &y );

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	DWORD PTR _clgame+164
	add	esp, 8
$LN9@Con_DrawNo:

; 2013 : 
; 2014 : 		Q_snprintf( buf, sizeof( buf ), "%s: ", con.chat_cmd );

	push	OFFSET _con+13700
	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5@
	push	256					; 00000100H
	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2015 : 
; 2016 : 		Con_DrawStringLen( buf, &len, NULL );

	push	0
	lea	eax, DWORD PTR _len$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$2[ebp]
	push	ecx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2017 : 		Con_DrawString( x, y, buf, g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	lea	edx, DWORD PTR _buf$2[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 2018 : 
; 2019 : 		Field_DrawInputLine( x + len, y, &con.chat );

	push	OFFSET _con+13432
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _len$1[ebp]
	push	ecx
	call	_Field_DrawInputLine
	add	esp, 12					; 0000000cH
$LN8@Con_DrawNo:

; 2020 : 	}
; 2021 : 
; 2022 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@Con_DrawNo:

; 2023 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawNotify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawDebugLines
_TEXT	SEGMENT
tv83 = -96						; size = 4
_fontTall$1 = -28					; size = 4
_len$2 = -24						; size = 4
_x$3 = -20						; size = 4
_y$ = -16						; size = 4
_defaultX$ = -12					; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_Con_DrawDebugLines PROC				; COMDAT

; 1909 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1910 : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1911 : 	int	defaultX;
; 1912 : 	int	y = 20;

	mov	DWORD PTR _y$[ebp], 20			; 00000014H

; 1913 : 
; 1914 : 	defaultX = glState.width / 4;

	mov	eax, DWORD PTR _glState
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _defaultX$[ebp], eax

; 1915 : 	
; 1916 : 	for( i = 0; i < MAX_DBG_NOTIFY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_DrawDe
$LN2@Con_DrawDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_DrawDe:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	$LN3@Con_DrawDe

; 1917 : 	{
; 1918 : 		if( host.realtime < con.notify[i].expire && con.notify[i].key_dest == cls.key_dest )

	imul	eax, DWORD PTR _i$[ebp], 268
	cvtss2sd xmm0, DWORD PTR _con[eax+31372]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	$LN5@Con_DrawDe
	imul	eax, DWORD PTR _i$[ebp], 268
	mov	ecx, DWORD PTR _con[eax+31380]
	cmp	ecx, DWORD PTR _cls+36
	jne	$LN5@Con_DrawDe

; 1919 : 		{
; 1920 : 			int	x, len;
; 1921 : 			int	fontTall;
; 1922 : 
; 1923 : 			Con_DrawStringLen( con.notify[i].szNotify, &len, &fontTall );

	lea	eax, DWORD PTR _fontTall$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _len$2[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 268
	add	edx, OFFSET _con+31116
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 1924 : 			x = glState.width - Q_max( defaultX, len ) - 10;

	mov	eax, DWORD PTR _defaultX$[ebp]
	cmp	eax, DWORD PTR _len$2[ebp]
	jle	SHORT $LN8@Con_DrawDe
	mov	ecx, DWORD PTR _defaultX$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN9@Con_DrawDe
$LN8@Con_DrawDe:
	mov	edx, DWORD PTR _len$2[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN9@Con_DrawDe:
	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR tv83[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR _x$3[ebp], eax

; 1925 : 			fontTall += 1;

	mov	eax, DWORD PTR _fontTall$1[ebp]
	add	eax, 1
	mov	DWORD PTR _fontTall$1[ebp], eax

; 1926 : 
; 1927 : 			if( y + fontTall > glState.height - 20 )

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _fontTall$1[ebp]
	mov	ecx, DWORD PTR _glState+4
	sub	ecx, 20					; 00000014H
	cmp	eax, ecx
	jle	SHORT $LN6@Con_DrawDe

; 1928 : 				return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $LN1@Con_DrawDe
$LN6@Con_DrawDe:

; 1929 : 
; 1930 : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 1931 : 			y = 20 + fontTall * i;

	mov	eax, DWORD PTR _fontTall$1[ebp]
	imul	eax, DWORD PTR _i$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _y$[ebp], eax

; 1932 : 			Con_DrawString( x, y, con.notify[i].szNotify, con.notify[i].color );

	imul	eax, DWORD PTR _i$[ebp], 268
	add	eax, OFFSET _con+31376
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 268
	add	ecx, OFFSET _con+31116
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$3[ebp]
	push	eax
	call	_Con_DrawString
	add	esp, 16					; 00000010H
$LN5@Con_DrawDe:

; 1933 : 		}
; 1934 : 	}

	jmp	$LN2@Con_DrawDe
$LN3@Con_DrawDe:

; 1935 : 
; 1936 : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@Con_DrawDe:

; 1937 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawDebugLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawInput
_TEXT	SEGMENT
_y$ = -4						; size = 4
_lines$ = 8						; size = 4
_Con_DrawInput PROC					; COMDAT

; 1889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1890 : 	int	y;
; 1891 : 
; 1892 : 	// don't draw anything (always draw if not active)
; 1893 : 	if( cls.key_dest != key_console || !con.curFont )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN3@Con_DrawIn
	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN2@Con_DrawIn
$LN3@Con_DrawIn:

; 1894 : 		return;

	jmp	SHORT $LN1@Con_DrawIn
$LN2@Con_DrawIn:

; 1895 : 
; 1896 : 	y = lines - ( con.curFont->charHeight * 2 );

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax+4356]
	shl	ecx, 1
	mov	edx, DWORD PTR _lines$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _y$[ebp], edx

; 1897 : 	Con_DrawCharacter( 8, y, ']', g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	push	93					; 0000005dH
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	push	8
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H

; 1898 : 	Field_DrawInputLine( 16, y, &con.input );

	push	OFFSET _con+13164
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	16					; 00000010H
	call	_Field_DrawInputLine
	add	esp, 12					; 0000000cH
$LN1@Con_DrawIn:

; 1899 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Field_DrawInputLine
_TEXT	SEGMENT
tv85 = -1260						; size = 4
$T1 = -1256						; size = 4
$T2 = -1252						; size = 4
_colorDefault$ = -1056					; size = 4
_str$ = -1052						; size = 1024
_curPos$ = -28						; size = 4
_prestep$ = -24						; size = 4
_hideChar$ = -20					; size = 4
_drawLen$ = -16						; size = 4
_cursorChar$ = -12					; size = 4
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_edit$ = 16						; size = 4
_Field_DrawInputLine PROC				; COMDAT

; 1642 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1260				; 000004ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1643 : 	int	len, cursorChar;
; 1644 : 	int	drawLen, hideChar = -1;

	mov	DWORD PTR _hideChar$[ebp], -1

; 1645 : 	int	prestep, curPos;
; 1646 : 	char	str[MAX_SYSPATH];
; 1647 : 	byte	*colorDefault;
; 1648 : 
; 1649 : 	drawLen = edit->widthInChars;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR _drawLen$[ebp], ecx

; 1650 : 	len = Q_strlen( edit->buffer ) + 1;

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1651 : 	colorDefault = g_color_table[ColorIndex( COLOR_DEFAULT )];

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	mov	DWORD PTR _colorDefault$[ebp], ecx

; 1652 : 
; 1653 : 	// guarantee that cursor will be visible
; 1654 : 	if( len <= drawLen )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _drawLen$[ebp]
	jg	SHORT $LN2@Field_Draw

; 1655 : 	{
; 1656 : 		prestep = 0;

	mov	DWORD PTR _prestep$[ebp], 0

; 1657 : 	}

	jmp	SHORT $LN3@Field_Draw
$LN2@Field_Draw:

; 1658 : 	else
; 1659 : 	{
; 1660 : 		if( edit->scroll + drawLen > len )

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, DWORD PTR _drawLen$[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jle	SHORT $LN5@Field_Draw

; 1661 : 		{
; 1662 : 			edit->scroll = len - drawLen;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _drawLen$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 1663 : 			if( edit->scroll < 0 ) edit->scroll = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+260], 0
	jge	SHORT $LN5@Field_Draw
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], 0
$LN5@Field_Draw:

; 1664 : 		}
; 1665 : 
; 1666 : 		prestep = edit->scroll;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	DWORD PTR _prestep$[ebp], ecx
$LN3@Field_Draw:

; 1667 : 	}
; 1668 : 
; 1669 : 	if( prestep + drawLen > len )

	mov	eax, DWORD PTR _prestep$[ebp]
	add	eax, DWORD PTR _drawLen$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jle	SHORT $LN6@Field_Draw

; 1670 : 		drawLen = len - prestep;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR _drawLen$[ebp], eax
$LN6@Field_Draw:

; 1671 : 
; 1672 : 	// extract <drawLen> characters from the field at <prestep>
; 1673 : 	drawLen = Q_min( drawLen, MAX_SYSPATH - 1 );

	cmp	DWORD PTR _drawLen$[ebp], 1023		; 000003ffH
	jge	SHORT $LN12@Field_Draw
	mov	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN13@Field_Draw
$LN12@Field_Draw:
	mov	DWORD PTR tv85[ebp], 1023		; 000003ffH
$LN13@Field_Draw:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _drawLen$[ebp], ecx

; 1674 : 
; 1675 : 	memcpy( str, edit->buffer + prestep, drawLen );

	mov	eax, DWORD PTR _drawLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR _prestep$[ebp]
	push	ecx
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1676 : 	str[drawLen] = 0;

	mov	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 1024		; 00000400H
	jae	SHORT $LN14@Field_Draw
	jmp	SHORT $LN15@Field_Draw
$LN14@Field_Draw:
	call	___report_rangecheckfailure
$LN15@Field_Draw:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _str$[ebp+ecx], 0

; 1677 : 
; 1678 : 	// save char for overstrike
; 1679 : 	cursorChar = str[edit->cursor - prestep];

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, DWORD PTR _prestep$[ebp]
	movsx	edx, BYTE PTR _str$[ebp+ecx]
	mov	DWORD PTR _cursorChar$[ebp], edx

; 1680 : 
; 1681 : 	if( host.key_overstrike && cursorChar && !((int)( host.realtime * 4 ) & 1 ))

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN7@Field_Draw
	cmp	DWORD PTR _cursorChar$[ebp], 0
	je	SHORT $LN7@Field_Draw
	movsd	xmm0, QWORD PTR _host+1440
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvttsd2si eax, xmm0
	and	eax, 1
	jne	SHORT $LN7@Field_Draw

; 1682 : 		hideChar = edit->cursor - prestep; // skip this char

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR _hideChar$[ebp], ecx
$LN7@Field_Draw:

; 1683 : 	
; 1684 : 	// draw it
; 1685 : 	Con_DrawGenericString( x, y, str, colorDefault, false, hideChar );

	mov	eax, DWORD PTR _hideChar$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _colorDefault$[ebp]
	push	ecx
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H

; 1686 : 
; 1687 : 	// draw the cursor
; 1688 : 	if((int)( host.realtime * 4 ) & 1 ) return; // off blink

	movsd	xmm0, QWORD PTR _host+1440
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvttsd2si eax, xmm0
	and	eax, 1
	je	SHORT $LN8@Field_Draw
	jmp	$LN10@Field_Draw
$LN8@Field_Draw:

; 1689 : 
; 1690 : 	// calc cursor position
; 1691 : 	str[edit->cursor - prestep] = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN16@Field_Draw
	jmp	SHORT $LN17@Field_Draw
$LN16@Field_Draw:
	call	___report_rangecheckfailure
$LN17@Field_Draw:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _str$[ebp+edx], 0

; 1692 : 	Con_DrawStringLen( str, &curPos, NULL );

	push	0
	lea	eax, DWORD PTR _curPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 1693 : 
; 1694 : 	if( host.key_overstrike && cursorChar )

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN9@Field_Draw
	cmp	DWORD PTR _cursorChar$[ebp], 0
	je	SHORT $LN9@Field_Draw

; 1695 : 	{
; 1696 : 		// overstrike cursor
; 1697 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1698 : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1699 : 		pglBlendFunc( GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA );

	push	770					; 00000302H
	push	771					; 00000303H
	call	DWORD PTR _pglBlendFunc

; 1700 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1701 : 		Con_DrawGenericChar( x + curPos, y, cursorChar, colorDefault );

	mov	eax, DWORD PTR _colorDefault$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cursorChar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _curPos$[ebp]
	push	eax
	call	_Con_DrawGenericChar
	add	esp, 16					; 00000010H

; 1702 : 	}

	jmp	SHORT $LN10@Field_Draw
$LN9@Field_Draw:

; 1703 : 	else Con_DrawCharacter( x + curPos, y, '_', colorDefault );

	mov	eax, DWORD PTR _colorDefault$[ebp]
	push	eax
	push	95					; 0000005fH
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _curPos$[ebp]
	push	edx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
$LN10@Field_Draw:

; 1704 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Field_DrawInputLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Field_KeyDownEvent
_TEXT	SEGMENT
tv198 = -72						; size = 4
_len$ = -4						; size = 4
_edit$ = 8						; size = 4
_key$ = 12						; size = 4
_Field_KeyDownEvent PROC				; COMDAT

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1510 : 	int	len;
; 1511 : 
; 1512 : 	// shift-insert is paste
; 1513 : 	if((( key == K_INS ) || ( key == K_KP_INS )) && Key_IsDown( K_SHIFT ))

	cmp	DWORD PTR _key$[ebp], 147		; 00000093H
	je	SHORT $LN3@Field_KeyD
	cmp	DWORD PTR _key$[ebp], 170		; 000000aaH
	jne	SHORT $LN2@Field_KeyD
$LN3@Field_KeyD:
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Field_KeyD

; 1514 : 	{
; 1515 : 		Field_Paste( edit );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Field_Paste
	add	esp, 4

; 1516 : 		return;

	jmp	$LN1@Field_KeyD
$LN2@Field_KeyD:

; 1517 : 	}
; 1518 : 
; 1519 : 	len = Q_strlen( edit->buffer );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1520 : 
; 1521 : 	if( key == K_DEL )

	cmp	DWORD PTR _key$[ebp], 148		; 00000094H
	jne	SHORT $LN4@Field_KeyD

; 1522 : 	{
; 1523 : 		if( edit->cursor < len )

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	cmp	ecx, DWORD PTR _len$[ebp]
	jge	SHORT $LN5@Field_KeyD

; 1524 : 			memmove( edit->buffer + edit->cursor, edit->buffer + edit->cursor + 1, len - edit->cursor );

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR [eax+256]
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	mov	ecx, DWORD PTR _edit$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR [eax+256]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN5@Field_KeyD:

; 1525 : 		return;

	jmp	$LN1@Field_KeyD
$LN4@Field_KeyD:

; 1526 : 	}
; 1527 : 
; 1528 : 	if( key == K_BACKSPACE )

	cmp	DWORD PTR _key$[ebp], 127		; 0000007fH
	jne	SHORT $LN6@Field_KeyD

; 1529 : 	{
; 1530 : 		if( edit->cursor > 0 )

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], 0
	jle	SHORT $LN7@Field_KeyD

; 1531 : 		{
; 1532 : 			memmove( edit->buffer + edit->cursor - 1, edit->buffer + edit->cursor, len - edit->cursor + 1 );

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR [eax+256]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR _edit$[ebp]
	add	eax, DWORD PTR [edx+256]
	push	eax
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	mov	eax, DWORD PTR _edit$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1533 : 			edit->cursor--;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx

; 1534 : 			if( edit->scroll ) edit->scroll--;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN7@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	sub	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], ecx
$LN7@Field_KeyD:

; 1535 : 		}
; 1536 : 		return;

	jmp	$LN1@Field_KeyD
$LN6@Field_KeyD:

; 1537 : 	}
; 1538 : 
; 1539 : 	if( key == K_RIGHTARROW ) 

	cmp	DWORD PTR _key$[ebp], 131		; 00000083H
	jne	SHORT $LN9@Field_KeyD

; 1540 : 	{
; 1541 : 		if( edit->cursor < len ) edit->cursor++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	cmp	ecx, DWORD PTR _len$[ebp]
	jge	SHORT $LN10@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx
$LN10@Field_KeyD:

; 1542 : 		if( edit->cursor >= edit->scroll + edit->widthInChars && edit->cursor <= len )

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	edx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR [edx+264]
	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], ecx
	jl	SHORT $LN11@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	cmp	ecx, DWORD PTR _len$[ebp]
	jg	SHORT $LN11@Field_KeyD

; 1543 : 			edit->scroll++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], ecx
$LN11@Field_KeyD:

; 1544 : 		return;

	jmp	$LN1@Field_KeyD
$LN9@Field_KeyD:

; 1545 : 	}
; 1546 : 
; 1547 : 	if( key == K_LEFTARROW ) 

	cmp	DWORD PTR _key$[ebp], 130		; 00000082H
	jne	SHORT $LN12@Field_KeyD

; 1548 : 	{
; 1549 : 		if( edit->cursor > 0 ) edit->cursor--;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], 0
	jle	SHORT $LN13@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx
$LN13@Field_KeyD:

; 1550 : 		if( edit->cursor < edit->scroll ) edit->scroll--;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [eax+256]
	cmp	edx, DWORD PTR [ecx+260]
	jge	SHORT $LN14@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	sub	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], ecx
$LN14@Field_KeyD:

; 1551 : 		return;

	jmp	$LN1@Field_KeyD
$LN12@Field_KeyD:

; 1552 : 	}
; 1553 : 
; 1554 : 	if( key == K_HOME || ( Q_tolower(key) == 'a' && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 151		; 00000097H
	je	SHORT $LN16@Field_KeyD
	movzx	eax, BYTE PTR _key$[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	ecx, 97					; 00000061H
	jne	SHORT $LN15@Field_KeyD
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@Field_KeyD
$LN16@Field_KeyD:

; 1555 : 	{
; 1556 : 		edit->cursor = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], 0

; 1557 : 		return;

	jmp	SHORT $LN1@Field_KeyD
$LN15@Field_KeyD:

; 1558 : 	}
; 1559 : 
; 1560 : 	if( key == K_END || ( Q_tolower(key) == 'e' && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 152		; 00000098H
	je	SHORT $LN18@Field_KeyD
	movzx	eax, BYTE PTR _key$[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	ecx, 101				; 00000065H
	jne	SHORT $LN17@Field_KeyD
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@Field_KeyD
$LN18@Field_KeyD:

; 1561 : 	{
; 1562 : 		edit->cursor = len;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+256], ecx

; 1563 : 		return;

	jmp	SHORT $LN1@Field_KeyD
$LN17@Field_KeyD:

; 1564 : 	}
; 1565 : 
; 1566 : 	if( key == K_INS )

	cmp	DWORD PTR _key$[ebp], 147		; 00000093H
	jne	SHORT $LN1@Field_KeyD

; 1567 : 	{
; 1568 : 		host.key_overstrike = !host.key_overstrike;

	cmp	DWORD PTR _host+34344, 0
	jne	SHORT $LN21@Field_KeyD
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN22@Field_KeyD
$LN21@Field_KeyD:
	mov	DWORD PTR tv198[ebp], 0
$LN22@Field_KeyD:
	mov	eax, DWORD PTR tv198[ebp]
	mov	DWORD PTR _host+34344, eax
$LN1@Field_KeyD:

; 1569 : 		return;
; 1570 : 	}
; 1571 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Field_KeyDownEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Field_Paste
_TEXT	SEGMENT
_pasteLen$ = -12					; size = 4
_i$ = -8						; size = 4
_cbd$ = -4						; size = 4
_edit$ = 8						; size = 4
_Field_Paste PROC					; COMDAT

; 1485 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1486 : 	char	*cbd;
; 1487 : 	int	i, pasteLen;
; 1488 : 
; 1489 : 	cbd = Sys_GetClipboardData();

	call	_Sys_GetClipboardData
	mov	DWORD PTR _cbd$[ebp], eax

; 1490 : 	if( !cbd ) return;

	cmp	DWORD PTR _cbd$[ebp], 0
	jne	SHORT $LN5@Field_Past
	jmp	SHORT $LN1@Field_Past
$LN5@Field_Past:

; 1491 : 
; 1492 : 	// send as if typed, so insert / overstrike works properly
; 1493 : 	pasteLen = Q_strlen( cbd );

	mov	eax, DWORD PTR _cbd$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _pasteLen$[ebp], eax

; 1494 : 	for( i = 0; i < pasteLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Field_Past
$LN2@Field_Past:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Field_Past:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pasteLen$[ebp]
	jge	SHORT $LN1@Field_Past

; 1495 : 		Field_CharEvent( edit, cbd[i] );

	mov	eax, DWORD PTR _cbd$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	push	edx
	call	_Field_CharEvent
	add	esp, 8
	jmp	SHORT $LN2@Field_Past
$LN1@Field_Past:

; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Field_Paste ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_CompleteCommand
_TEXT	SEGMENT
tv75 = -680						; size = 4
_len$1 = -548						; size = 4
_last$2 = -544						; size = 4
_first$3 = -540						; size = 4
_i$ = -536						; size = 4
_nextcmd$ = -532					; size = 4
_filename$ = -528					; size = 256
_temp$ = -272						; size = 268
__$ArrayPad$ = -4					; size = 4
_field$ = 8						; size = 4
_Con_CompleteCommand PROC				; COMDAT

; 1367 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 680				; 000002a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1368 : 	field_t	temp;
; 1369 : 	string	filename;
; 1370 : 	qboolean	nextcmd;
; 1371 : 	int	i;
; 1372 : 
; 1373 : 	// setup the completion field
; 1374 : 	con.completionField = field;

	mov	eax, DWORD PTR _field$[ebp]
	mov	DWORD PTR _con+65680, eax

; 1375 : 
; 1376 : 	// only look at the first token for completion purposes
; 1377 : 	Cmd_TokenizeString( con.completionField->buffer );

	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 1378 : 
; 1379 : 	nextcmd = ( con.completionField->buffer[Q_strlen( con.completionField->buffer ) - 1] == ' ' ) ? true : false;

	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN27@Con_Comple
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN28@Con_Comple
$LN27@Con_Comple:
	mov	DWORD PTR tv75[ebp], 0
$LN28@Con_Comple:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _nextcmd$[ebp], eax

; 1380 : 
; 1381 : 	con.completionString = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _con+65684, eax

; 1382 : 	con.completionBuffer = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _con+65688, eax
$LN2@Con_Comple:

; 1383 : 
; 1384 : 	// skip backslash
; 1385 : 	while( *con.completionString && ( *con.completionString == '\\' || *con.completionString == '/' ))

	mov	eax, DWORD PTR _con+65684
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Con_Comple
	mov	eax, DWORD PTR _con+65684
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN11@Con_Comple
	mov	eax, DWORD PTR _con+65684
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN4@Con_Comple
$LN11@Con_Comple:

; 1386 : 		con.completionString++;

	mov	eax, DWORD PTR _con+65684
	add	eax, 1
	mov	DWORD PTR _con+65684, eax
	jmp	SHORT $LN2@Con_Comple
$LN4@Con_Comple:

; 1387 : 
; 1388 : 	// skip backslash
; 1389 : 	while( *con.completionBuffer && ( *con.completionBuffer == '\\' || *con.completionBuffer == '/' ))

	mov	eax, DWORD PTR _con+65688
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Con_Comple
	mov	eax, DWORD PTR _con+65688
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN12@Con_Comple
	mov	eax, DWORD PTR _con+65688
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN5@Con_Comple
$LN12@Con_Comple:

; 1390 : 		con.completionBuffer++;

	mov	eax, DWORD PTR _con+65688
	add	eax, 1
	mov	DWORD PTR _con+65688, eax
	jmp	SHORT $LN4@Con_Comple
$LN5@Con_Comple:

; 1391 : 
; 1392 : 	if( !Q_strlen( con.completionString ))

	mov	eax, DWORD PTR _con+65684
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@Con_Comple

; 1393 : 		return;

	jmp	$LN1@Con_Comple
$LN13@Con_Comple:

; 1394 : 
; 1395 : 	// free the old autocomplete list
; 1396 : 	for( i = 0; i < con.matchCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@Con_Comple
$LN6@Con_Comple:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@Con_Comple:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _con+82076
	jge	SHORT $LN7@Con_Comple

; 1397 : 	{
; 1398 : 		if( con.cmds[i] != NULL )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _con[eax*4+65692], 0
	je	SHORT $LN14@Con_Comple

; 1399 : 		{
; 1400 : 			Mem_Free( con.cmds[i] );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_CompleteCommand@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _con[ecx*4+65692]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1401 : 			con.cmds[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _con[eax*4+65692], 0
$LN14@Con_Comple:

; 1402 : 		}
; 1403 : 	}

	jmp	SHORT $LN6@Con_Comple
$LN7@Con_Comple:

; 1404 : 
; 1405 : 	con.matchCount = 0;

	mov	DWORD PTR _con+82076, 0

; 1406 : 	con.shortestMatch[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _con[ecx+65424], 0

; 1407 : 
; 1408 : 	// find matching commands and variables
; 1409 : 	Cmd_LookupCmds( NULL, NULL, Con_AddCommandToList );

	push	OFFSET _Con_AddCommandToList
	push	0
	push	0
	call	_Cmd_LookupCmds
	add	esp, 12					; 0000000cH

; 1410 : 	Cvar_LookupVars( 0, NULL, NULL, Con_AddCommandToList );

	push	OFFSET _Con_AddCommandToList
	push	0
	push	0
	push	0
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H

; 1411 : 
; 1412 : 	if( !con.matchCount ) return; // no matches

	cmp	DWORD PTR _con+82076, 0
	jne	SHORT $LN15@Con_Comple
	jmp	$LN1@Con_Comple
$LN15@Con_Comple:

; 1413 : 
; 1414 : 	memcpy( &temp, con.completionField, sizeof( field_t ));

	push	268					; 0000010cH
	mov	eax, DWORD PTR _con+65680
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1415 : 
; 1416 : 	// autocomplete second arg
; 1417 : 	if(( Cmd_Argc() == 2 ) || (( Cmd_Argc() == 1 ) && nextcmd ))

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN18@Con_Comple
	call	_Cmd_Argc
	cmp	eax, 1
	jne	$LN16@Con_Comple
	cmp	DWORD PTR _nextcmd$[ebp], 0
	je	SHORT $LN16@Con_Comple
$LN18@Con_Comple:

; 1418 : 	{
; 1419 : 		if( !Q_strlen( con.completionBuffer ))

	mov	eax, DWORD PTR _con+65688
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@Con_Comple

; 1420 : 			return;

	jmp	$LN1@Con_Comple
$LN19@Con_Comple:

; 1421 : 
; 1422 : 		if( Cmd_AutocompleteName( con.completionBuffer, filename, sizeof( filename )))

	push	256					; 00000100H
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _con+65688
	push	ecx
	call	_Cmd_AutocompleteName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@Con_Comple

; 1423 : 		{         
; 1424 : 			Q_sprintf( con.completionField->buffer, "%s %s", Cmd_Argv( 0 ), filename ); 

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 1425 : 			con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	mov	DWORD PTR [ecx+256], eax
$LN20@Con_Comple:

; 1426 : 		}
; 1427 : 
; 1428 : 		// don't adjusting cursor pos if we nothing found
; 1429 : 		return;

	jmp	$LN1@Con_Comple

; 1430 : 	}  

	jmp	SHORT $LN17@Con_Comple
$LN16@Con_Comple:

; 1431 : 	else if( Cmd_Argc() >= 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	jb	SHORT $LN17@Con_Comple

; 1432 : 	{
; 1433 : 		// disable autocomplete for all next args
; 1434 : 		return;

	jmp	$LN1@Con_Comple
$LN17@Con_Comple:

; 1435 : 	}
; 1436 : 
; 1437 : 	if( con.matchCount == 1 )

	cmp	DWORD PTR _con+82076, 1
	jne	SHORT $LN22@Con_Comple

; 1438 : 	{
; 1439 : 		Q_sprintf( con.completionField->buffer, "\\%s", con.cmds[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _con[ecx+65692]
	push	edx
	push	OFFSET ??_C@_03GFPEDOMH@?2?$CFs@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1440 : 		if( Cmd_Argc() == 1 ) Q_strncat( con.completionField->buffer, " ", sizeof( con.completionField->buffer ));

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN24@Con_Comple
	push	256					; 00000100H
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN25@Con_Comple
$LN24@Con_Comple:

; 1441 : 		else Con_ConcatRemaining( temp.buffer, con.completionString );

	mov	eax, DWORD PTR _con+65684
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_Con_ConcatRemaining
	add	esp, 8
$LN25@Con_Comple:

; 1442 : 		con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	mov	DWORD PTR [ecx+256], eax

; 1443 : 	}

	jmp	$LN1@Con_Comple
$LN22@Con_Comple:

; 1444 : 	else
; 1445 : 	{
; 1446 : 		char	*first, *last;
; 1447 : 		int	len = 0;

	mov	DWORD PTR _len$1[ebp], 0

; 1448 : 
; 1449 : 		qsort( con.cmds, con.matchCount, sizeof( char* ), Con_SortCmds );

	push	OFFSET _Con_SortCmds
	push	4
	mov	eax, DWORD PTR _con+82076
	push	eax
	push	OFFSET _con+65692
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 1450 : 
; 1451 : 		// find the number of matching characters between the first and
; 1452 : 		// the last element in the list and copy it
; 1453 : 		first = con.cmds[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _con[ecx+65692]
	mov	DWORD PTR _first$3[ebp], edx

; 1454 : 		last = con.cmds[con.matchCount-1];

	mov	eax, DWORD PTR _con+82076
	mov	ecx, DWORD PTR _con[eax*4+65688]
	mov	DWORD PTR _last$2[ebp], ecx
$LN9@Con_Comple:

; 1455 : 
; 1456 : 		while( *first && *last && Q_tolower( *first ) == Q_tolower( *last ))

	mov	eax, DWORD PTR _first$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN10@Con_Comple
	mov	eax, DWORD PTR _last$2[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN10@Con_Comple
	mov	eax, DWORD PTR _first$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _last$2[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN10@Con_Comple

; 1457 : 		{
; 1458 : 			first++;

	mov	eax, DWORD PTR _first$3[ebp]
	add	eax, 1
	mov	DWORD PTR _first$3[ebp], eax

; 1459 : 			last++;

	mov	eax, DWORD PTR _last$2[ebp]
	add	eax, 1
	mov	DWORD PTR _last$2[ebp], eax

; 1460 : 
; 1461 : 			con.shortestMatch[len] = con.cmds[0][len];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _con[ecx+65692]
	mov	eax, DWORD PTR _len$1[ebp]
	mov	ecx, DWORD PTR _len$1[ebp]
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _con[eax+65424], dl

; 1462 : 			len++;

	mov	eax, DWORD PTR _len$1[ebp]
	add	eax, 1
	mov	DWORD PTR _len$1[ebp], eax

; 1463 : 		}

	jmp	$LN9@Con_Comple
$LN10@Con_Comple:

; 1464 : 		con.shortestMatch[len] = 0;

	mov	eax, DWORD PTR _len$1[ebp]
	mov	BYTE PTR _con[eax+65424], 0

; 1465 : 
; 1466 : 		// multiple matches, complete to shortest
; 1467 : 		Q_sprintf( con.completionField->buffer, "\\%s", con.shortestMatch );

	push	OFFSET _con+65424
	push	OFFSET ??_C@_03GFPEDOMH@?2?$CFs@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1468 : 		con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	mov	DWORD PTR [ecx+256], eax

; 1469 : 		Con_ConcatRemaining( temp.buffer, con.completionString );

	mov	eax, DWORD PTR _con+65684
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_Con_ConcatRemaining
	add	esp, 8

; 1470 : 
; 1471 : 		Con_Printf( "]%s\n", con.completionField->buffer );

	mov	eax, DWORD PTR _con+65680
	push	eax
	push	OFFSET ??_C@_04MCOKGCBH@?$FN?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1472 : 
; 1473 : 		// run through again, printing matches
; 1474 : 		Cmd_LookupCmds( NULL, NULL, Con_PrintCmdMatches );

	push	OFFSET _Con_PrintCmdMatches
	push	0
	push	0
	call	_Cmd_LookupCmds
	add	esp, 12					; 0000000cH

; 1475 : 		Cvar_LookupVars( 0, NULL, NULL, Con_PrintCvarMatches );

	push	OFFSET _Con_PrintCvarMatches
	push	0
	push	0
	push	0
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H
$LN1@Con_Comple:

; 1476 : 	}
; 1477 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_CompleteCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_ConcatRemaining
_TEXT	SEGMENT
_i$ = -8						; size = 4
_arg$ = -4						; size = 4
_src$ = 8						; size = 4
_start$ = 12						; size = 4
_Con_ConcatRemaining PROC				; COMDAT

; 1327 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1328 : 	char	*arg;
; 1329 : 	int	i;
; 1330 : 
; 1331 : 	arg = Q_strstr( src, start );

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 1332 : 
; 1333 : 	if( !arg )

	cmp	DWORD PTR _arg$[ebp], 0
	jne	$LN7@Con_Concat

; 1334 : 	{
; 1335 : 		for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Con_Concat
$LN2@Con_Concat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_Concat:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN3@Con_Concat

; 1336 : 		{
; 1337 : 			Q_strncat( con.completionField->buffer, " ", sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1338 : 			arg = Cmd_Argv( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _arg$[ebp], eax
$LN5@Con_Concat:

; 1339 : 			while( *arg )

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@Con_Concat

; 1340 : 			{
; 1341 : 				if( *arg == ' ' )

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN8@Con_Concat

; 1342 : 				{
; 1343 : 					Q_strncat( con.completionField->buffer, "\"", sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1344 : 					break;

	jmp	SHORT $LN6@Con_Concat
$LN8@Con_Concat:

; 1345 : 				}
; 1346 : 				arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 1347 : 			}

	jmp	SHORT $LN5@Con_Concat
$LN6@Con_Concat:

; 1348 : 
; 1349 : 			Q_strncat( con.completionField->buffer, Cmd_Argv( i ), sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1350 : 			if( *arg == ' ' ) Q_strncat( con.completionField->buffer, "\"", sizeof( con.completionField->buffer ));

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN9@Con_Concat
	push	256					; 00000100H
	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN9@Con_Concat:

; 1351 : 		}

	jmp	$LN2@Con_Concat
$LN3@Con_Concat:

; 1352 : 		return;

	jmp	SHORT $LN1@Con_Concat
$LN7@Con_Concat:

; 1353 : 	}
; 1354 : 
; 1355 : 	arg += Q_strlen( start );

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _arg$[ebp], eax

; 1356 : 	Q_strncat( con.completionField->buffer, arg, sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN1@Con_Concat:

; 1357 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ConcatRemaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_PrintCvarMatches
_TEXT	SEGMENT
_s$ = 8							; size = 4
_value$ = 12						; size = 4
_m$ = 16						; size = 4
_unused2$ = 20						; size = 4
_Con_PrintCvarMatches PROC				; COMDAT

; 1313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1314 : 	if( !Q_strnicmp( s, con.shortestMatch, Q_strlen( con.shortestMatch )))

	push	OFFSET _con+65424
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET _con+65424
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Con_PrintC

; 1315 : 	{
; 1316 : 		if( COM_CheckString( m )) Con_Printf( "    %s (%s)   ^3\"%s\"\n", s, value, m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_PrintC
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@IIHNMGJ@?5?5?5?5?$CFs?5?$CI?$CFs?$CJ?5?5?5?$FO3?$CC?$CFs?$CC?6@
	call	_Con_Printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@Con_PrintC
$LN3@Con_PrintC:

; 1317 : 		else Con_Printf( "    %s  (%s)\n", s, value ); // variable or command without description

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET ??_C@_0O@MOEFDAMM@?5?5?5?5?$CFs?5?5?$CI?$CFs?$CJ?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN1@Con_PrintC:

; 1318 : 	}
; 1319 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_PrintCvarMatches ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_PrintCmdMatches
_TEXT	SEGMENT
_s$ = 8							; size = 4
_unused1$ = 12						; size = 4
_m$ = 16						; size = 4
_unused2$ = 20						; size = 4
_Con_PrintCmdMatches PROC				; COMDAT

; 1299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1300 : 	if( !Q_strnicmp( s, con.shortestMatch, Q_strlen( con.shortestMatch )))

	push	OFFSET _con+65424
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET _con+65424
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Con_PrintC

; 1301 : 	{
; 1302 : 		if( COM_CheckString( m )) Con_Printf( "    %s ^3\"%s\"\n", s, m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_PrintC
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@IMEIJKPK@?5?5?5?5?$CFs?5?$FO3?$CC?$CFs?$CC?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Con_PrintC
$LN3@Con_PrintC:

; 1303 : 		else Con_Printf( "    %s\n", s ); // variable or command without description

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_07FBMPDAOB@?5?5?5?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN1@Con_PrintC:

; 1304 : 	}
; 1305 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_PrintCmdMatches ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_SortCmds
_TEXT	SEGMENT
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
_Con_SortCmds PROC					; COMDAT

; 1289 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1290 : 	return Q_stricmp( *arg1, *arg2 );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _arg2$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _arg1$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH

; 1291 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SortCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_AddCommandToList
_TEXT	SEGMENT
_s$ = 8							; size = 4
_unused1$ = 12						; size = 4
_unused2$ = 16						; size = 4
_unused3$ = 20						; size = 4
_Con_AddCommandToList PROC				; COMDAT

; 1273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1274 : 	if( *s == '@' ) return; // never show system cvars or cmds

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN2@Con_AddCom
	jmp	SHORT $LN1@Con_AddCom
$LN2@Con_AddCom:

; 1275 : 	if( con.matchCount >= CON_MAXCMDS ) return; // list is full

	cmp	DWORD PTR _con+82076, 4096		; 00001000H
	jl	SHORT $LN3@Con_AddCom
	jmp	SHORT $LN1@Con_AddCom
$LN3@Con_AddCom:

; 1276 : 
; 1277 : 	if( Q_strnicmp( s, con.completionString, Q_strlen( con.completionString )))

	mov	eax, DWORD PTR _con+65684
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _con+65684
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@Con_AddCom

; 1278 : 		return; // no match

	jmp	SHORT $LN1@Con_AddCom
$LN4@Con_AddCom:

; 1279 : 
; 1280 : 	con.cmds[con.matchCount++] = copystring( s );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_AddCommandToList@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _con+82076
	mov	DWORD PTR _con[ecx*4+65692], eax
	mov	edx, DWORD PTR _con+82076
	add	edx, 1
	mov	DWORD PTR _con+82076, edx
$LN1@Con_AddCom:

; 1281 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_AddCommandToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawGenericString
_TEXT	SEGMENT
_s$ = -16						; size = 4
_numDraws$ = -12					; size = 4
_drawLen$ = -8						; size = 4
_color$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_setColor$ = 20						; size = 4
_forceColor$ = 24					; size = 4
_hideChar$ = 28						; size = 4
_Con_DrawGenericString PROC				; COMDAT

; 878  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 879  : 	rgba_t		color;
; 880  : 	int		drawLen = 0;

	mov	DWORD PTR _drawLen$[ebp], 0

; 881  : 	int		numDraws = 0;

	mov	DWORD PTR _numDraws$[ebp], 0

; 882  : 	const char	*s;
; 883  : 
; 884  : 	if( !con.curFont ) return 0; // no font set

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN4@Con_DrawGe
	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN4@Con_DrawGe:

; 885  : 
; 886  : 	// draw the colored text
; 887  : 	*(uint *)color = *(uint *)setColor;

	mov	eax, DWORD PTR _setColor$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _color$[ebp], ecx

; 888  : 	s = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN2@Con_DrawGe:

; 889  : 
; 890  : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Con_DrawGe

; 891  : 	{
; 892  : 		if( *s == '\n' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN5@Con_DrawGe

; 893  : 		{
; 894  : 			s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 895  : 			if( !*s ) break; // at end the string

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@Con_DrawGe
	jmp	$LN3@Con_DrawGe
$LN6@Con_DrawGe:

; 896  : 			drawLen = 0; // begin new row

	mov	DWORD PTR _drawLen$[ebp], 0

; 897  : 			y += con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR [eax+4356]
	mov	DWORD PTR _y$[ebp], ecx
$LN5@Con_DrawGe:

; 898  : 		}
; 899  : 
; 900  : 		if( IsColorString( s ))

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN7@Con_DrawGe

; 901  : 		{
; 902  : 			if( !forceColor )

	cmp	DWORD PTR _forceColor$[ebp], 0
	jne	SHORT $LN8@Con_DrawGe

; 903  : 			{
; 904  : 				memcpy( color, g_color_table[ColorIndex(*(s+1))], sizeof( color ));

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	sub	ecx, 48					; 00000030H
	and	ecx, 7
	lea	edx, DWORD PTR _g_color_table[ecx*4]
	push	edx
	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 905  : 				color[3] = setColor[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _setColor$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _color$[ebp+eax], cl
$LN8@Con_DrawGe:

; 906  : 			}
; 907  : 
; 908  : 			s += 2;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2
	mov	DWORD PTR _s$[ebp], eax

; 909  : 			numDraws++;

	mov	eax, DWORD PTR _numDraws$[ebp]
	add	eax, 1
	mov	DWORD PTR _numDraws$[ebp], eax

; 910  : 			continue;

	jmp	$LN2@Con_DrawGe
$LN7@Con_DrawGe:

; 911  : 		}
; 912  : 
; 913  : 		// hide char for overstrike mode
; 914  : 		if( hideChar == numDraws )

	mov	eax, DWORD PTR _hideChar$[ebp]
	cmp	eax, DWORD PTR _numDraws$[ebp]
	jne	SHORT $LN9@Con_DrawGe

; 915  : 			drawLen += con.curFont->charWidths[*s];

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _con+13156
	movzx	eax, BYTE PTR [edx+ecx+4100]
	add	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR _drawLen$[ebp], eax
	jmp	SHORT $LN10@Con_DrawGe
$LN9@Con_DrawGe:

; 916  : 		else drawLen += Con_DrawCharacter( x + drawLen, y, *s, color );

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _drawLen$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR _drawLen$[ebp], eax
$LN10@Con_DrawGe:

; 917  : 
; 918  : 		numDraws++;

	mov	eax, DWORD PTR _numDraws$[ebp]
	add	eax, 1
	mov	DWORD PTR _numDraws$[ebp], eax

; 919  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 920  : 	}

	jmp	$LN2@Con_DrawGe
$LN3@Con_DrawGe:

; 921  :           
; 922  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 923  : 	return drawLen;

	mov	eax, DWORD PTR _drawLen$[ebp]
$LN1@Con_DrawGe:

; 924  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawGenericString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawGenericChar
_TEXT	SEGMENT
_rc$ = -32						; size = 4
_glt$ = -28						; size = 4
_t2$ = -24						; size = 4
_s2$ = -20						; size = 4
_t1$ = -16						; size = 4
_s1$ = -12						; size = 4
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_color$ = 20						; size = 4
_Con_DrawGenericChar PROC				; COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 731  : 	int		width, height;
; 732  : 	float		s1, t1, s2, t2;
; 733  : 	gl_texture_t	*glt;
; 734  : 	wrect_t		*rc;
; 735  : 
; 736  : 	number &= 255;

	mov	eax, DWORD PTR _number$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _number$[ebp], eax

; 737  : 
; 738  : 	if( !con.curFont || !con.curFont->valid )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN3@Con_DrawGe
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax+4364], 0
	jne	SHORT $LN2@Con_DrawGe
$LN3@Con_DrawGe:

; 739  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN2@Con_DrawGe:

; 740  : 
; 741  : 	if( y < -con.curFont->charHeight )

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax+4356]
	neg	ecx
	cmp	DWORD PTR _y$[ebp], ecx
	jge	SHORT $LN4@Con_DrawGe

; 742  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN4@Con_DrawGe:

; 743  : 
; 744  : 	rc = &con.curFont->fontRc[number];

	mov	eax, DWORD PTR _number$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _con+13156
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _rc$[ebp], edx

; 745  : 	glt = R_GetTexture( con.curFont->hFontTexture );

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 746  : 	width = glt->srcWidth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+256]
	mov	DWORD PTR _width$[ebp], ecx

; 747  : 	height = glt->srcHeight;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+258]
	mov	DWORD PTR _height$[ebp], ecx

; 748  : 
; 749  : 	if( !width || !height )

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN6@Con_DrawGe
	cmp	DWORD PTR _height$[ebp], 0
	jne	SHORT $LN5@Con_DrawGe
$LN6@Con_DrawGe:

; 750  : 		return con.curFont->charWidths[number];

	mov	eax, DWORD PTR _con+13156
	add	eax, DWORD PTR _number$[ebp]
	movzx	eax, BYTE PTR [eax+4100]
	jmp	$LN1@Con_DrawGe
$LN5@Con_DrawGe:

; 751  : 
; 752  : 	// don't apply color to fixed fonts it's already colored
; 753  : 	if( con.curFont->type != FONT_FIXED || glt->format == GL_LUMINANCE8_ALPHA8 )

	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax+4360], 0
	jne	SHORT $LN9@Con_DrawGe
	mov	eax, DWORD PTR _glt$[ebp]
	cmp	DWORD PTR [eax+276], 32837		; 00008045H
	jne	SHORT $LN7@Con_DrawGe
$LN9@Con_DrawGe:

; 754  : 		pglColor4ubv( color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	DWORD PTR _pglColor4ubv
	jmp	SHORT $LN8@Con_DrawGe
$LN7@Con_DrawGe:

; 755  : 	else pglColor4ub( 255, 255, 255, color[3] );

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _color$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN8@Con_DrawGe:

; 756  : 	R_GetTextureParms( &width, &height, con.curFont->hFontTexture );

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _height$[ebp]
	push	edx
	lea	eax, DWORD PTR _width$[ebp]
	push	eax
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 757  : 
; 758  : 	// calc rectangle
; 759  : 	s1 = (float)rc->left / width;

	mov	eax, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s1$[ebp], xmm0

; 760  : 	t1 = (float)rc->top / height;

	mov	eax, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+8]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 761  : 	s2 = (float)rc->right / width;

	mov	eax, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 762  : 	t2 = (float)rc->bottom / height;

	mov	eax, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+12]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 763  : 	width = rc->right - rc->left;

	mov	eax, DWORD PTR _rc$[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _width$[ebp], edx

; 764  : 	height = rc->bottom - rc->top;

	mov	eax, DWORD PTR _rc$[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _height$[ebp], edx

; 765  : 
; 766  : 	if( clgame.ds.adjust_size )

	cmp	DWORD PTR _clgame+214868, 0
	je	SHORT $LN10@Con_DrawGe

; 767  : 		Con_TextAdjustSize( &x, &y, &width, &height );

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_TextAdjustSize
	add	esp, 16					; 00000010H
$LN10@Con_DrawGe:

; 768  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, con.curFont->hFontTexture );		

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 769  : 	pglColor4ub( 255, 255, 255, 255 ); // don't forget reset color

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 770  : 
; 771  : 	return con.curFont->charWidths[number];

	mov	eax, DWORD PTR _con+13156
	add	eax, DWORD PTR _number$[ebp]
	movzx	eax, BYTE PTR [eax+4100]
$LN1@Con_DrawGe:

; 772  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawGenericChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_TextAdjustSize
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_Con_TextAdjustSize PROC				; COMDAT

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 708  : 	float	xscale, yscale;
; 709  : 
; 710  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	jmp	$LN6@Con_TextAd
$LN2@Con_TextAd:

; 711  : 
; 712  : 	// scale for screen sizes
; 713  : 	xscale = (float)glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+217076
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 714  : 	yscale = (float)glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+217080
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 715  : 
; 716  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@Con_TextAd
	mov	eax, DWORD PTR _x$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@Con_TextAd:

; 717  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@Con_TextAd
	mov	eax, DWORD PTR _y$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@Con_TextAd:

; 718  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN5@Con_TextAd
	mov	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@Con_TextAd:

; 719  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN6@Con_TextAd
	mov	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@Con_TextAd:

; 720  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_TextAdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawCharToConback
_TEXT	SEGMENT
tv72 = -88						; size = 4
_x$ = -20						; size = 4
_drawline$ = -16					; size = 4
_source$ = -12						; size = 4
_col$ = -8						; size = 4
_row$ = -4						; size = 4
_num$ = 8						; size = 4
_conchars$ = 12						; size = 4
_dest$ = 16						; size = 4
_Con_DrawCharToConback PROC				; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 677  : 	int	row, col;
; 678  : 	byte	*source;
; 679  : 	int	drawline;
; 680  : 	int	x;
; 681  : 
; 682  : 	row = num >> 4;

	mov	eax, DWORD PTR _num$[ebp]
	sar	eax, 4
	mov	DWORD PTR _row$[ebp], eax

; 683  : 	col = num & 15;

	mov	eax, DWORD PTR _num$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _col$[ebp], eax

; 684  : 	source = conchars + (row << 10) + (col << 3);

	mov	eax, DWORD PTR _row$[ebp]
	shl	eax, 10					; 0000000aH
	add	eax, DWORD PTR _conchars$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _source$[ebp], edx

; 685  : 
; 686  : 	drawline = 8;

	mov	DWORD PTR _drawline$[ebp], 8
$LN2@Con_DrawCh:

; 687  : 
; 688  : 	while( drawline-- )

	mov	eax, DWORD PTR _drawline$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR _drawline$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _drawline$[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN1@Con_DrawCh

; 689  : 	{
; 690  : 		for( x = 0; x < 8; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN6@Con_DrawCh
$LN4@Con_DrawCh:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN6@Con_DrawCh:
	cmp	DWORD PTR _x$[ebp], 8
	jge	SHORT $LN5@Con_DrawCh

; 691  : 			if( source[x] != 255 )

	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN7@Con_DrawCh

; 692  : 				dest[x] = 0x60 + source[x];

	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _dest$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	mov	BYTE PTR [edx], cl
$LN7@Con_DrawCh:
	jmp	SHORT $LN4@Con_DrawCh
$LN5@Con_DrawCh:

; 693  : 		source += 128;

	mov	eax, DWORD PTR _source$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _source$[ebp], eax

; 694  : 		dest += 320;

	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, 320				; 00000140H
	mov	DWORD PTR _dest$[ebp], eax

; 695  : 	}

	jmp	SHORT $LN2@Con_DrawCh
$LN1@Con_DrawCh:

; 696  : 
; 697  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawCharToConback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_LoadConchars
_TEXT	SEGMENT
_fontSize$ = -8						; size = 4
_i$ = -4						; size = 4
_Con_LoadConchars PROC					; COMDAT

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 657  : 	int	i, fontSize;
; 658  : 
; 659  : 	// load all the console fonts
; 660  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadCo
$LN2@Con_LoadCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LoadCo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@Con_LoadCo

; 661  : 		Con_LoadConsoleFont( i, con.chars + i );

	imul	eax, DWORD PTR _i$[ebp], 4368
	add	eax, OFFSET _con+52
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_Con_LoadConsoleFont
	add	esp, 8
	jmp	SHORT $LN2@Con_LoadCo
$LN3@Con_LoadCo:

; 662  : 
; 663  : 	// select properly fontsize
; 664  : 	if( glState.width <= 640 )

	cmp	DWORD PTR _glState, 640			; 00000280H
	jg	SHORT $LN5@Con_LoadCo

; 665  : 		fontSize = 0;

	mov	DWORD PTR _fontSize$[ebp], 0
	jmp	SHORT $LN6@Con_LoadCo
$LN5@Con_LoadCo:

; 666  : 	else if( glState.width >= 1280 )

	cmp	DWORD PTR _glState, 1280		; 00000500H
	jl	SHORT $LN7@Con_LoadCo

; 667  : 		fontSize = 2;

	mov	DWORD PTR _fontSize$[ebp], 2
	jmp	SHORT $LN6@Con_LoadCo
$LN7@Con_LoadCo:

; 668  : 	else fontSize = 1;

	mov	DWORD PTR _fontSize$[ebp], 1
$LN6@Con_LoadCo:

; 669  : 
; 670  : 	// sets the current font
; 671  : 	con.lastUsedFont = con.curFont = &con.chars[fontSize];

	imul	eax, DWORD PTR _fontSize$[ebp], 4368
	add	eax, OFFSET _con+52
	mov	DWORD PTR _con+13156, eax
	mov	ecx, DWORD PTR _con+13156
	mov	DWORD PTR _con+13160, ecx

; 672  : 	
; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadConchars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_LoadConsoleFont
_TEXT	SEGMENT
_fontNumber$ = 8					; size = 4
_font$ = 12						; size = 4
_Con_LoadConsoleFont PROC				; COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 639  : 	if( font->valid ) return; // already loaded

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN2@Con_LoadCo
	jmp	SHORT $LN1@Con_LoadCo
$LN2@Con_LoadCo:

; 640  : 
; 641  : 	// loading conchars
; 642  : 	if( Sys_CheckParm( "-oldfont" ))

	push	OFFSET ??_C@_08MANNGIAP@?9oldfont@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_LoadCo

; 643  : 		Con_LoadVariableWidthFont( "gfx.wad/conchars.fnt", font );

	mov	eax, DWORD PTR _font$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@BPDLPEHF@gfx?4wad?1conchars?4fnt@
	call	_Con_LoadVariableWidthFont
	add	esp, 8
	jmp	SHORT $LN4@Con_LoadCo
$LN3@Con_LoadCo:

; 644  : 	else Con_LoadVariableWidthFont( va( "fonts.wad/font%i", fontNumber ), font );

	mov	eax, DWORD PTR _font$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fontNumber$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@GOBNJLKD@fonts?4wad?1font?$CFi@
	call	_va
	add	esp, 8
	push	eax
	call	_Con_LoadVariableWidthFont
	add	esp, 8
$LN4@Con_LoadCo:

; 645  : 
; 646  : 	// quake fixed font as fallback
; 647  : 	if( !font->valid ) Con_LoadFixedWidthFont( "gfx/conchars", font );

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	jne	SHORT $LN1@Con_LoadCo
	mov	eax, DWORD PTR _font$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@POKADIKD@gfx?1conchars@
	call	_Con_LoadFixedWidthFont
	add	esp, 8
$LN1@Con_LoadCo:

; 648  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadConsoleFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_LoadVariableWidthFont
_TEXT	SEGMENT
_src$ = -20						; size = 4
_length$ = -16						; size = 4
_buffer$ = -12						; size = 4
_fontWidth$ = -8					; size = 4
_i$ = -4						; size = 4
_fontname$ = 8						; size = 4
_font$ = 12						; size = 4
_Con_LoadVariableWidthFont PROC				; COMDAT

; 586  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 587  : 	int	i, fontWidth;
; 588  : 	byte	*buffer;
; 589  : 	size_t	length;
; 590  : 	qfont_t	*src;
; 591  : 
; 592  : 	if( font->valid )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN5@Con_LoadVa

; 593  : 		return true; // already loaded

	mov	eax, 1
	jmp	$LN1@Con_LoadVa
$LN5@Con_LoadVa:

; 594  : 
; 595  : 	if( !FS_FileExists( fontname, false ))

	push	0
	mov	eax, DWORD PTR _fontname$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@Con_LoadVa

; 596  : 		return false;

	xor	eax, eax
	jmp	$LN1@Con_LoadVa
$LN6@Con_LoadVa:

; 597  : 
; 598  : 	font->hFontTexture = GL_LoadTexture( fontname, NULL, 0, TF_FONT|TF_NEAREST );

	push	6145					; 00001801H
	push	0
	push	0
	mov	eax, DWORD PTR _fontname$[ebp]
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx], eax

; 599  : 	R_GetTextureParms( &fontWidth, NULL, font->hFontTexture );

	mov	eax, DWORD PTR _font$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	lea	edx, DWORD PTR _fontWidth$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 600  : 
; 601  : 	// setup consolefont
; 602  : 	if( font->hFontTexture && fontWidth != 0 )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN7@Con_LoadVa
	cmp	DWORD PTR _fontWidth$[ebp], 0
	je	$LN7@Con_LoadVa

; 603  : 	{
; 604  : 		// half-life font with variable chars witdh
; 605  : 		buffer = FS_LoadFile( fontname, &length, false );

	push	0
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fontname$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer$[ebp], eax

; 606  : 
; 607  : 		if( buffer && length >= sizeof( qfont_t ))

	cmp	DWORD PTR _buffer$[ebp], 0
	je	$LN8@Con_LoadVa
	cmp	DWORD PTR _length$[ebp], 1044		; 00000414H
	jb	$LN8@Con_LoadVa

; 608  : 		{
; 609  : 			src = (qfont_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _src$[ebp], eax

; 610  : 			font->charHeight = src->rowheight;

	mov	eax, DWORD PTR _font$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4356], edx

; 611  : 			font->type = FONT_VARIABLE;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4360], 1

; 612  : 
; 613  : 			// build rectangles
; 614  : 			for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadVa
$LN2@Con_LoadVa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LoadVa:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Con_LoadVa

; 615  : 			{
; 616  : 				font->fontRc[i].left = (word)src->fontinfo[i].startoffset % fontWidth;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [ecx+eax*4+16]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 617  : 				font->fontRc[i].right = font->fontRc[i].left + src->fontinfo[i].charwidth;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	movsx	ecx, WORD PTR [edx+ecx*4+18]
	mov	edx, DWORD PTR _font$[ebp]
	add	ecx, DWORD PTR [edx+eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+eax+8], ecx

; 618  : 				font->fontRc[i].top = (word)src->fontinfo[i].startoffset / fontWidth;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [ecx+eax*4+16]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 619  : 				font->fontRc[i].bottom = font->fontRc[i].top + src->rowheight;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	eax, DWORD PTR _src$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+ecx+16], edx

; 620  : 				font->charWidths[i] = src->fontinfo[i].charwidth;

	mov	eax, DWORD PTR _font$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+18]
	mov	BYTE PTR [eax+4100], cl

; 621  : 			}

	jmp	$LN2@Con_LoadVa
$LN3@Con_LoadVa:

; 622  : 			font->valid = true;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4364], 1
$LN8@Con_LoadVa:

; 623  : 		}
; 624  : 		if( buffer ) Mem_Free( buffer );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN7@Con_LoadVa
	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_LoadVariableWidthFont@@9@9
	add	eax, 38					; 00000026H
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@Con_LoadVa:

; 625  : 	}
; 626  : 
; 627  : 	return true;

	mov	eax, 1
$LN1@Con_LoadVa:

; 628  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadVariableWidthFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_LoadFixedWidthFont
_TEXT	SEGMENT
_fontWidth$ = -8					; size = 4
_i$ = -4						; size = 4
_fontname$ = 8						; size = 4
_font$ = 12						; size = 4
_Con_LoadFixedWidthFont PROC				; COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 553  : 	int	i, fontWidth;
; 554  : 
; 555  : 	if( font->valid )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN5@Con_LoadFi

; 556  : 		return true; // already loaded

	mov	eax, 1
	jmp	$LN1@Con_LoadFi
$LN5@Con_LoadFi:

; 557  : 
; 558  : 	if( !FS_FileExists( fontname, false ))

	push	0
	mov	eax, DWORD PTR _fontname$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@Con_LoadFi

; 559  : 		return false;

	xor	eax, eax
	jmp	$LN1@Con_LoadFi
$LN6@Con_LoadFi:

; 560  : 
; 561  : 	// keep source to print directly into conback image
; 562  : 	font->hFontTexture = GL_LoadTexture( fontname, NULL, 0, TF_FONT|TF_KEEP_SOURCE );

	push	6146					; 00001802H
	push	0
	push	0
	mov	eax, DWORD PTR _fontname$[ebp]
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx], eax

; 563  : 	R_GetTextureParms( &fontWidth, NULL, font->hFontTexture );

	mov	eax, DWORD PTR _font$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	lea	edx, DWORD PTR _fontWidth$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 564  : 
; 565  : 	if( font->hFontTexture && fontWidth != 0 )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN7@Con_LoadFi
	cmp	DWORD PTR _fontWidth$[ebp], 0
	je	$LN7@Con_LoadFi

; 566  : 	{
; 567  : 		font->charHeight = fontWidth / 16;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx+4356], eax

; 568  : 		font->type = FONT_FIXED;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4360], 0

; 569  : 
; 570  : 		// build fixed rectangles
; 571  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadFi
$LN2@Con_LoadFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LoadFi:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Con_LoadFi

; 572  : 		{
; 573  : 			font->fontRc[i].left = (i * (fontWidth / 16)) % fontWidth;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	imul	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 574  : 			font->fontRc[i].right = font->fontRc[i].left + fontWidth / 16;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _font$[ebp]
	add	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 575  : 			font->fontRc[i].top = (i / 16) * (fontWidth / 16);

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	imul	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+edx+12], ecx

; 576  : 			font->fontRc[i].bottom = font->fontRc[i].top + fontWidth / 16;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _font$[ebp]
	add	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+ecx+16], eax

; 577  : 			font->charWidths[i] = fontWidth / 16;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+4100], al

; 578  : 		}

	jmp	$LN2@Con_LoadFi
$LN3@Con_LoadFi:

; 579  : 		font->valid = true;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4364], 1
$LN7@Con_LoadFi:

; 580  : 	}
; 581  : 
; 582  : 	return true;

	mov	eax, 1
$LN1@Con_LoadFi:

; 583  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadFixedWidthFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Bottom
_TEXT	SEGMENT
_Con_Bottom PROC					; COMDAT

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 526  : 	con.backscroll = 0;

	mov	DWORD PTR _con+32, 0

; 527  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Bottom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Top
_TEXT	SEGMENT
_Con_Top PROC						; COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 516  : 	con.backscroll = CON_MAXLINES;

	mov	DWORD PTR _con+32, 16384		; 00004000H

; 517  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Top ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_PageDown
_TEXT	SEGMENT
_lines$ = 8						; size = 4
_Con_PageDown PROC					; COMDAT

; 505  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 506  : 	con.backscroll -= abs( lines );

	mov	eax, DWORD PTR _lines$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	ecx, DWORD PTR _con+32
	sub	ecx, eax
	mov	DWORD PTR _con+32, ecx

; 507  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_PageDown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_PageUp
_TEXT	SEGMENT
_lines$ = 8						; size = 4
_Con_PageUp PROC					; COMDAT

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 496  : 	con.backscroll += abs( lines );

	mov	eax, DWORD PTR _lines$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	add	eax, DWORD PTR _con+32
	mov	DWORD PTR _con+32, eax

; 497  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_PageUp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_CheckResize
_TEXT	SEGMENT
_width$ = -12						; size = 4
_i$ = -8						; size = 4
_charWidth$ = -4					; size = 4
_Con_CheckResize PROC					; COMDAT

; 466  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 467  : 	int	charWidth = 8;

	mov	DWORD PTR _charWidth$[ebp], 8

; 468  : 	int	i, width;
; 469  : 
; 470  : 	if( con.curFont && con.curFont->hFontTexture )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN5@Con_CheckR
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Con_CheckR

; 471  : 		charWidth = con.curFont->charWidths['O'] - 1;

	mov	eax, 1
	imul	ecx, eax, 79
	mov	edx, DWORD PTR _con+13156
	movzx	eax, BYTE PTR [edx+ecx+4100]
	sub	eax, 1
	mov	DWORD PTR _charWidth$[ebp], eax
$LN5@Con_CheckR:

; 472  : 
; 473  : 	width = ( glState.width / charWidth ) - 2;

	mov	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _charWidth$[ebp]
	sub	eax, 2
	mov	DWORD PTR _width$[ebp], eax

; 474  : 	if( !glw_state.initialized ) width = (640 / 5);

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN6@Con_CheckR
	mov	DWORD PTR _width$[ebp], 128		; 00000080H
$LN6@Con_CheckR:

; 475  : 
; 476  : 	if( width == con.linewidth )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _con+36
	jne	SHORT $LN7@Con_CheckR

; 477  : 		return;

	jmp	SHORT $LN1@Con_CheckR
$LN7@Con_CheckR:

; 478  : 
; 479  : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 480  : 	con.linewidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _con+36, eax

; 481  : 	con.backscroll = 0;

	mov	DWORD PTR _con+32, 0

; 482  : 
; 483  : 	con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 484  : 
; 485  : 	for( i = 0; i < CON_HISTORY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_CheckR
$LN2@Con_CheckR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_CheckR:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN1@Con_CheckR

; 486  : 		con.historyLines[i].widthInChars = con.linewidth;

	imul	eax, DWORD PTR _i$[ebp], 268
	mov	ecx, DWORD PTR _con+36
	mov	DWORD PTR _con[eax+14220], ecx
	jmp	SHORT $LN2@Con_CheckR
$LN1@Con_CheckR:

; 487  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_CheckResize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_AddLine
_TEXT	SEGMENT
_p$ = -8						; size = 4
_putpos$ = -4						; size = 4
_line$ = 8						; size = 4
_length$ = 12						; size = 4
_Con_AddLine PROC					; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 434  : 	byte		*putpos;
; 435  : 	con_lineinfo_t	*p;
; 436  : 
; 437  : 	if( !con.initialized || !con.buffer )

	cmp	DWORD PTR _con, 0
	je	SHORT $LN5@Con_AddLin
	cmp	DWORD PTR _con+4, 0
	jne	SHORT $LN4@Con_AddLin
$LN5@Con_AddLin:

; 438  : 		return;

	jmp	$LN1@Con_AddLin
$LN4@Con_AddLin:

; 439  : 
; 440  : 	Con_FixTimes();

	call	_Con_FixTimes

; 441  : 	length++;	// reserve space for term

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 442  : 
; 443  : 	ASSERT( length < CON_TEXTSIZE );

	cmp	DWORD PTR _length$[ebp], 1048576	; 00100000H
	jl	SHORT $LN6@Con_AddLin
	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_AddLine@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN6@Con_AddLin:

; 444  : 
; 445  : 	while( !( putpos = Con_BytesLeft( length )) || con.lines_count >= con.maxlines )

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	call	_Con_BytesLeft
	add	esp, 4
	mov	DWORD PTR _putpos$[ebp], eax
	cmp	DWORD PTR _putpos$[ebp], 0
	je	SHORT $LN7@Con_AddLin
	mov	eax, DWORD PTR _con+24
	cmp	eax, DWORD PTR _con+16
	jl	SHORT $LN3@Con_AddLin
$LN7@Con_AddLin:

; 446  : 		Con_DeleteLine();

	call	_Con_DeleteLine
	jmp	SHORT $LN6@Con_AddLin
$LN3@Con_AddLin:

; 447  : 
; 448  : 	memcpy( putpos, line, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _putpos$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 449  : 	putpos[length - 1] = '\0';

	mov	eax, DWORD PTR _putpos$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax-1], 0

; 450  : 	con.lines_count++;

	mov	eax, DWORD PTR _con+24
	add	eax, 1
	mov	DWORD PTR _con+24, eax

; 451  : 
; 452  : 	p = &CON_LINES_LAST();

	mov	eax, DWORD PTR _con+24
	mov	ecx, DWORD PTR _con+20
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _p$[ebp], edx

; 453  : 	p->start = putpos;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _putpos$[ebp]
	mov	DWORD PTR [eax], ecx

; 454  : 	p->length = length;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 455  : 	p->addtime = cl.time;

	mov	eax, DWORD PTR _p$[ebp]
	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR [eax+8], xmm0
$LN1@Con_AddLin:

; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_AddLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_BytesLeft
_TEXT	SEGMENT
_lastline_onepastend$1 = -8				; size = 4
_firstline_start$2 = -4					; size = 4
_length$ = 8						; size = 4
_Con_BytesLeft PROC					; COMDAT

; 389  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 390  : 	if( length > con.bufsize )

	mov	eax, DWORD PTR _length$[ebp]
	cmp	eax, DWORD PTR _con+8
	jle	SHORT $LN2@Con_BytesL

; 391  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Con_BytesL
$LN2@Con_BytesL:

; 392  : 
; 393  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN3@Con_BytesL

; 394  : 	{
; 395  : 		return con.buffer;

	mov	eax, DWORD PTR _con+4
	jmp	$LN1@Con_BytesL

; 396  : 	}

	jmp	$LN1@Con_BytesL
$LN3@Con_BytesL:

; 397  : 	else
; 398  : 	{
; 399  : 		char	*firstline_start = con.lines[con.lines_first].start;

	mov	eax, DWORD PTR _con+20
	shl	eax, 4
	mov	ecx, DWORD PTR _con+12
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _firstline_start$2[ebp], edx

; 400  : 		char	*lastline_onepastend = CON_LINES_LAST().start + CON_LINES_LAST().length;

	mov	eax, DWORD PTR _con+24
	mov	ecx, DWORD PTR _con+20
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _con+16
	mov	ecx, edx
	shl	ecx, 4
	mov	edx, DWORD PTR _con+24
	mov	eax, DWORD PTR _con+20
	lea	eax, DWORD PTR [eax+edx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	mov	ecx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _con+12
	add	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _lastline_onepastend$1[ebp], ecx

; 401  : 
; 402  : 		// the buffer is cyclic, so we first have two cases...
; 403  : 		if( firstline_start < lastline_onepastend ) // buffer is contiguous

	mov	eax, DWORD PTR _firstline_start$2[ebp]
	cmp	eax, DWORD PTR _lastline_onepastend$1[ebp]
	jae	SHORT $LN5@Con_BytesL

; 404  : 		{
; 405  : 			// put at end?
; 406  : 			if( length <= con.buffer + con.bufsize - lastline_onepastend )

	mov	eax, DWORD PTR _con+4
	add	eax, DWORD PTR _con+8
	sub	eax, DWORD PTR _lastline_onepastend$1[ebp]
	cmp	DWORD PTR _length$[ebp], eax
	jg	SHORT $LN7@Con_BytesL

; 407  : 				return lastline_onepastend;

	mov	eax, DWORD PTR _lastline_onepastend$1[ebp]
	jmp	SHORT $LN1@Con_BytesL
	jmp	SHORT $LN8@Con_BytesL
$LN7@Con_BytesL:

; 408  : 			// put at beginning?
; 409  : 			else if( length <= firstline_start - con.buffer )

	mov	eax, DWORD PTR _firstline_start$2[ebp]
	sub	eax, DWORD PTR _con+4
	cmp	DWORD PTR _length$[ebp], eax
	jg	SHORT $LN8@Con_BytesL

; 410  : 				return con.buffer;

	mov	eax, DWORD PTR _con+4
	jmp	SHORT $LN1@Con_BytesL
$LN8@Con_BytesL:

; 411  : 
; 412  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Con_BytesL

; 413  : 		}

	jmp	SHORT $LN1@Con_BytesL
$LN5@Con_BytesL:

; 414  : 		else
; 415  : 		{
; 416  : 			// buffer has a contiguous hole
; 417  : 			if( length <= firstline_start - lastline_onepastend )

	mov	eax, DWORD PTR _firstline_start$2[ebp]
	sub	eax, DWORD PTR _lastline_onepastend$1[ebp]
	cmp	DWORD PTR _length$[ebp], eax
	jg	SHORT $LN10@Con_BytesL

; 418  : 				return lastline_onepastend;

	mov	eax, DWORD PTR _lastline_onepastend$1[ebp]
	jmp	SHORT $LN1@Con_BytesL
$LN10@Con_BytesL:

; 419  : 
; 420  : 			return NULL;

	xor	eax, eax
$LN1@Con_BytesL:

; 421  : 		}
; 422  : 	}
; 423  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_BytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DeleteLastLine
_TEXT	SEGMENT
_Con_DeleteLastLine PROC				; COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 375  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN2@Con_Delete

; 376  : 		return;

	jmp	SHORT $LN1@Con_Delete
$LN2@Con_Delete:

; 377  : 	con.lines_count--;

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _con+24, eax
$LN1@Con_Delete:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DeleteLastLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DeleteLine
_TEXT	SEGMENT
_Con_DeleteLine PROC					; COMDAT

; 359  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 360  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN2@Con_Delete

; 361  : 		return;

	jmp	SHORT $LN1@Con_Delete
$LN2@Con_Delete:

; 362  : 	con.lines_count--;

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _con+24, eax

; 363  : 	con.lines_first = (con.lines_first + 1) % con.maxlines;

	mov	eax, DWORD PTR _con+20
	add	eax, 1
	cdq
	idiv	DWORD PTR _con+16
	mov	DWORD PTR _con+20, edx
$LN1@Con_Delete:

; 364  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DeleteLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_FixTimes
_TEXT	SEGMENT
_i$ = -12						; size = 4
_diff$ = -8						; size = 8
_Con_FixTimes PROC					; COMDAT

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 339  : 	double	diff;
; 340  : 	int	i;
; 341  : 
; 342  : 	if( con.lines_count <= 0 ) return;

	cmp	DWORD PTR _con+24, 0
	jg	SHORT $LN5@Con_FixTim
	jmp	$LN3@Con_FixTim
$LN5@Con_FixTim:

; 343  : 
; 344  : 	diff = cl.time - CON_LINES_LAST().addtime;

	mov	eax, DWORD PTR _con+24
	mov	ecx, DWORD PTR _con+20
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR [eax+edx+8]
	movsd	QWORD PTR _diff$[ebp], xmm0

; 345  : 	if( diff >= 0.0 ) return; // nothing to fix

	movsd	xmm0, QWORD PTR _diff$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN6@Con_FixTim
	jmp	SHORT $LN3@Con_FixTim
$LN6@Con_FixTim:

; 346  : 
; 347  : 	for( i = 0; i < con.lines_count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_FixTim
$LN2@Con_FixTim:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_FixTim:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _con+24
	jge	SHORT $LN3@Con_FixTim

; 348  : 		CON_LINES( i ).addtime += diff;

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	movsd	xmm0, QWORD PTR [eax+edx+8]
	addsd	xmm0, QWORD PTR _diff$[ebp]
	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	ecx, DWORD PTR _con+12
	movsd	QWORD PTR [ecx+edx+8], xmm0
	jmp	SHORT $LN2@Con_FixTim
$LN3@Con_FixTim:

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_FixTimes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_SetTimes_f
_TEXT	SEGMENT
tv74 = -76						; size = 4
tv73 = -72						; size = 4
_newtimes$ = -4						; size = 4
_Con_SetTimes_f PROC					; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 316  : 	int	newtimes;
; 317  : 
; 318  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@Con_SetTim

; 319  : 	{
; 320  : 		Con_Printf( S_USAGE "contimes <n lines>\n" );

	push	OFFSET ??_C@_0BL@MLFKPALA@Usage?3?5contimes?5?$DMn?5lines?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 321  : 		return;

	jmp	SHORT $LN1@Con_SetTim
$LN2@Con_SetTim:

; 322  : 	}
; 323  : 
; 324  : 	newtimes = Q_atoi( Cmd_Argv( 1 ) );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _newtimes$[ebp], eax

; 325  : 	con.num_times = bound( CON_TIMES, newtimes, CON_MAX_TIMES );

	cmp	DWORD PTR _newtimes$[ebp], 4
	jl	SHORT $LN6@Con_SetTim
	cmp	DWORD PTR _newtimes$[ebp], 64		; 00000040H
	jge	SHORT $LN4@Con_SetTim
	mov	eax, DWORD PTR _newtimes$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@Con_SetTim
$LN4@Con_SetTim:
	mov	DWORD PTR tv73[ebp], 64			; 00000040H
$LN5@Con_SetTim:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN7@Con_SetTim
$LN6@Con_SetTim:
	mov	DWORD PTR tv74[ebp], 4
$LN7@Con_SetTim:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _con+28, edx
$LN1@Con_SetTim:

; 326  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetTimes_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_MessageMode2_f
_TEXT	SEGMENT
_Con_MessageMode2_f PROC				; COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 275  : 	Q_strncpy( con.chat_cmd, "say_team", sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	OFFSET ??_C@_08NBFNGOHN@say_team@
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 276  : 	Key_SetKeyDest( key_message );

	push	3
	call	_Key_SetKeyDest
	add	esp, 4

; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_MessageMode2_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_MessageMode_f
_TEXT	SEGMENT
_Con_MessageMode_f PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 261  : 	if( Cmd_Argc() == 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jne	SHORT $LN2@Con_Messag

; 262  : 		Q_strncpy( con.chat_cmd, Cmd_Argv( 1 ), sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@Con_Messag
$LN2@Con_Messag:

; 263  : 	else Q_strncpy( con.chat_cmd, "say", sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	OFFSET ??_C@_03BANJEMDJ@say@
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN3@Con_Messag:

; 264  : 
; 265  : 	Key_SetKeyDest( key_message );

	push	3
	call	_Key_SetKeyDest
	add	esp, 4

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_MessageMode_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_StringLength
_TEXT	SEGMENT
_p$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_Con_StringLength PROC					; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 232  : 	int		len;
; 233  : 	const char	*p;
; 234  : 
; 235  : 	if( !string ) return 0;

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@Con_String
	xor	eax, eax
	jmp	SHORT $LN1@Con_String
$LN4@Con_String:

; 236  : 
; 237  : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 238  : 	p = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@Con_String:

; 239  : 
; 240  : 	while( *p )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Con_String

; 241  : 	{
; 242  : 		if( IsColorString( p ))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN5@Con_String

; 243  : 		{
; 244  : 			p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 245  : 			continue;

	jmp	SHORT $LN2@Con_String
$LN5@Con_String:

; 246  : 		}
; 247  : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 248  : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 249  : 	}

	jmp	SHORT $LN2@Con_String
$LN3@Con_String:

; 250  : 
; 251  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@Con_String:

; 252  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_StringLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_ClearTyping
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_ClearTyping PROC					; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 209  : 	int	i;
; 210  : 
; 211  : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 212  : 	con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 213  : 
; 214  : 	// free the old autocomplete list
; 215  : 	for( i = 0; i < con.matchCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_ClearT
$LN2@Con_ClearT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_ClearT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _con+82076
	jge	SHORT $LN3@Con_ClearT

; 216  : 	{
; 217  : 		freestring( con.cmds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _con[eax*4+65692], 0
	je	SHORT $LN5@Con_ClearT
	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_ClearTyping@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _con[ecx*4+65692]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _con[eax*4+65692], 0
$LN5@Con_ClearT:

; 218  : 	}

	jmp	SHORT $LN2@Con_ClearT
$LN3@Con_ClearT:

; 219  : 
; 220  : 	con.matchCount = 0;

	mov	DWORD PTR _con+82076, 0

; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ClearTyping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_ClearField
_TEXT	SEGMENT
_edit$ = 8						; size = 4
_Con_ClearField PROC					; COMDAT

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 197  : 	memset( edit->buffer, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 198  : 	edit->cursor = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], 0

; 199  : 	edit->scroll = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], 0

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ClearField ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_SetColor_f
_TEXT	SEGMENT
tv178 = -84						; size = 4
tv140 = -84						; size = 4
tv65 = -84						; size = 4
_color$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_Con_SetColor_f PROC					; COMDAT

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 155  : 	vec3_t	color;
; 156  : 
; 157  : 	switch( Cmd_Argc() )

	call	_Cmd_Argc
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN4@Con_SetCol
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN5@Con_SetCol
	cmp	DWORD PTR tv65[ebp], 4
	je	$LN6@Con_SetCol
	jmp	$LN7@Con_SetCol
$LN4@Con_SetCol:

; 158  : 	{
; 159  : 	case 1:
; 160  : 		Con_Printf( "\"con_color\" is %i %i %i\n", g_color_table[7][0], g_color_table[7][1], g_color_table[7][2] );

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _g_color_table[ecx+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _g_color_table[edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _g_color_table[eax+edx]
	push	eax
	push	OFFSET ??_C@_0BJ@ELGMFDFE@?$CCcon_color?$CC?5is?5?$CFi?5?$CFi?5?$CFi?6@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 161  : 		break;

	jmp	$LN2@Con_SetCol
$LN5@Con_SetCol:

; 162  : 	case 2:
; 163  : 		VectorSet( color, g_color_table[7][0], g_color_table[7][1], g_color_table[7][2] );

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	movzx	eax, BYTE PTR _g_color_table[ecx+eax]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _color$[ebp+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movzx	edx, BYTE PTR _g_color_table[edx+eax]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _color$[ebp+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _g_color_table[ecx+edx]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv140[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _color$[ebp+ecx], xmm0

; 164  : 		Q_atov( color, Cmd_Argv( 1 ), 3 );

	push	3
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_Q_atov
	add	esp, 12					; 0000000cH

; 165  : 		Con_DefaultColor( color[0], color[1], color[2] );

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _color$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	call	_Con_DefaultColor
	add	esp, 12					; 0000000cH

; 166  : 		break;

	jmp	$LN2@Con_SetCol
$LN6@Con_SetCol:

; 167  : 	case 4:
; 168  : 		VectorSet( color, Q_atof( Cmd_Argv( 1 )), Q_atof( Cmd_Argv( 2 )), Q_atof( Cmd_Argv( 3 )));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _color$[ebp+ecx]
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _color$[ebp+edx]
	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv178[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _color$[ebp+eax], xmm0

; 169  : 		Con_DefaultColor( color[0], color[1], color[2] );

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _color$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	call	_Con_DefaultColor
	add	esp, 12					; 0000000cH

; 170  : 		break;

	jmp	SHORT $LN2@Con_SetCol
$LN7@Con_SetCol:

; 171  : 	default:
; 172  : 		Con_Printf( S_USAGE "con_color \"r g b\"\n" );

	push	OFFSET ??_C@_0BK@LJJAIAPH@Usage?3?5con_color?5?$CCr?5g?5b?$CC?6@
	call	_Con_Printf
	add	esp, 4
$LN2@Con_SetCol:

; 173  : 		break;
; 174  : 	}
; 175  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetColor_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Clear_f
_TEXT	SEGMENT
_Con_Clear_f PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 144  : 	con.lines_count = 0;

	mov	DWORD PTR _con+24, 0

; 145  : 	con.backscroll = 0; // go to end

	mov	DWORD PTR _con+32, 0

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Clear_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Field_CharEvent
_TEXT	SEGMENT
_len$ = -4						; size = 4
_edit$ = 8						; size = 4
_ch$ = 12						; size = 4
_Field_CharEvent PROC					; COMDAT

; 1579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1580 : 	int	len;
; 1581 : 
; 1582 : 	if( ch == 'v' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 22			; 00000016H
	jne	SHORT $LN2@Field_Char

; 1583 : 	{
; 1584 : 		// ctrl-v is paste
; 1585 : 		Field_Paste( edit );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Field_Paste
	add	esp, 4

; 1586 : 		return;

	jmp	$LN1@Field_Char
$LN2@Field_Char:

; 1587 : 	}
; 1588 : 
; 1589 : 	if( ch == 'c' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 3
	jne	SHORT $LN3@Field_Char

; 1590 : 	{
; 1591 : 		// ctrl-c clears the field
; 1592 : 		Con_ClearField( edit );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Con_ClearField
	add	esp, 4

; 1593 : 		return;

	jmp	$LN1@Field_Char
$LN3@Field_Char:

; 1594 : 	}
; 1595 : 
; 1596 : 	len = Q_strlen( edit->buffer );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1597 : 
; 1598 : 	if( ch == 'a' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 1
	jne	SHORT $LN4@Field_Char

; 1599 : 	{
; 1600 : 		// ctrl-a is home
; 1601 : 		edit->cursor = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], 0

; 1602 : 		edit->scroll = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], 0

; 1603 : 		return;

	jmp	$LN1@Field_Char
$LN4@Field_Char:

; 1604 : 	}
; 1605 : 
; 1606 : 	if( ch == 'e' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 5
	jne	SHORT $LN5@Field_Char

; 1607 : 	{
; 1608 : 		// ctrl-e is end
; 1609 : 		edit->cursor = len;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+256], ecx

; 1610 : 		edit->scroll = edit->cursor - edit->widthInChars;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [eax+256]
	sub	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], edx

; 1611 : 		return;

	jmp	$LN1@Field_Char
$LN5@Field_Char:

; 1612 : 	}
; 1613 : 
; 1614 : 	// ignore any other non printable chars
; 1615 : 	if( ch < 32 ) return;

	cmp	DWORD PTR _ch$[ebp], 32			; 00000020H
	jge	SHORT $LN6@Field_Char
	jmp	$LN1@Field_Char
$LN6@Field_Char:

; 1616 : 
; 1617 : 	if( host.key_overstrike )

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN7@Field_Char

; 1618 : 	{	
; 1619 : 		if ( edit->cursor == MAX_STRING - 1 ) return;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], 255		; 000000ffH
	jne	SHORT $LN9@Field_Char
	jmp	$LN1@Field_Char
$LN9@Field_Char:

; 1620 : 		edit->buffer[edit->cursor] = ch;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1621 : 		edit->cursor++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx

; 1622 : 	}

	jmp	SHORT $LN8@Field_Char
$LN7@Field_Char:

; 1623 : 	else
; 1624 : 	{
; 1625 : 		// insert mode
; 1626 : 		if ( len == MAX_STRING - 1 ) return; // all full

	cmp	DWORD PTR _len$[ebp], 255		; 000000ffH
	jne	SHORT $LN10@Field_Char
	jmp	$LN1@Field_Char
$LN10@Field_Char:

; 1627 : 		memmove( edit->buffer + edit->cursor + 1, edit->buffer + edit->cursor, len + 1 - edit->cursor );

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _edit$[ebp]
	sub	eax, DWORD PTR [ecx+256]
	push	eax
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR _edit$[ebp]
	add	eax, DWORD PTR [edx+256]
	push	eax
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	mov	eax, DWORD PTR _edit$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1628 : 		edit->buffer[edit->cursor] = ch;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1629 : 		edit->cursor++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx
$LN8@Field_Char:

; 1630 : 	}
; 1631 : 
; 1632 : 	if( edit->cursor >= edit->widthInChars ) edit->scroll++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [eax+256]
	cmp	edx, DWORD PTR [ecx+264]
	jl	SHORT $LN11@Field_Char
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], ecx
$LN11@Field_Char:

; 1633 : 	if( edit->cursor == len + 1 ) edit->buffer[edit->cursor] = 0;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [ecx+256], eax
	jne	SHORT $LN1@Field_Char
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN1@Field_Char:

; 1634 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Field_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_FastClose
_TEXT	SEGMENT
_Con_FastClose PROC					; COMDAT

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2469 : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 2470 : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 2471 : 	con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0

; 2472 : 	con.vislines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+44, xmm0

; 2473 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_FastClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Key_Message
_TEXT	SEGMENT
_buffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_Key_Message PROC					; COMDAT

; 1848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1220				; 000004c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1849 : 	char	buffer[MAX_SYSPATH];
; 1850 : 
; 1851 : 	if( key == K_ESCAPE )

	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	SHORT $LN2@Key_Messag

; 1852 : 	{
; 1853 : 		Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4

; 1854 : 		Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 1855 : 		return;

	jmp	$LN1@Key_Messag
$LN2@Key_Messag:

; 1856 : 	}
; 1857 : 
; 1858 : 	if( key == K_ENTER || key == K_KP_ENTER )

	cmp	DWORD PTR _key$[ebp], 13		; 0000000dH
	je	SHORT $LN4@Key_Messag
	cmp	DWORD PTR _key$[ebp], 169		; 000000a9H
	jne	SHORT $LN3@Key_Messag
$LN4@Key_Messag:

; 1859 : 	{
; 1860 : 		if( con.chat.buffer[0] && cls.state == ca_active )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13432]
	test	edx, edx
	je	SHORT $LN5@Key_Messag
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@Key_Messag

; 1861 : 		{
; 1862 : 			Q_snprintf( buffer, sizeof( buffer ), "%s \"%s\"\n", con.chat_cmd, con.chat.buffer );

	push	OFFSET _con+13432
	push	OFFSET _con+13700
	push	OFFSET ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1863 : 			Cbuf_AddText( buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4
$LN5@Key_Messag:

; 1864 : 		}
; 1865 : 
; 1866 : 		Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4

; 1867 : 		Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 1868 : 		return;

	jmp	SHORT $LN1@Key_Messag
$LN3@Key_Messag:

; 1869 : 	}
; 1870 : 
; 1871 : 	Field_KeyDownEvent( &con.chat, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _con+13432
	call	_Field_KeyDownEvent
	add	esp, 8
$LN1@Key_Messag:

; 1872 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Key_Console
_TEXT	SEGMENT
_temp$1 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_Key_Console PROC					; COMDAT

; 1721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1220				; 000004c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1722 : 	// ctrl-L clears screen
; 1723 : 	if( key == 'l' && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 108		; 0000006cH
	jne	SHORT $LN2@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Key_Consol

; 1724 : 	{
; 1725 : 		Cbuf_AddText( "clear\n" );

	push	OFFSET ??_C@_06NICJIFDH@clear?6@
	call	_Cbuf_AddText
	add	esp, 4

; 1726 : 		return;

	jmp	$LN1@Key_Consol
$LN2@Key_Consol:

; 1727 : 	}
; 1728 : 
; 1729 : 	// enter finishes the line
; 1730 : 	if( key == K_ENTER || key == K_KP_ENTER )

	cmp	DWORD PTR _key$[ebp], 13		; 0000000dH
	je	SHORT $LN4@Key_Consol
	cmp	DWORD PTR _key$[ebp], 169		; 000000a9H
	jne	$LN3@Key_Consol
$LN4@Key_Consol:

; 1731 : 	{
; 1732 : 		// if not in the game explicitly prepent a slash if needed
; 1733 : 		if( cls.state != ca_active && con.input.buffer[0] != '\\' && con.input.buffer[0] != '/' )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN5@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN5@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN5@Key_Consol

; 1734 : 		{
; 1735 : 			char	temp[MAX_SYSPATH];
; 1736 : 
; 1737 : 			Q_strncpy( temp, con.input.buffer, sizeof( temp ));

	push	1024					; 00000400H
	push	OFFSET _con+13164
	lea	eax, DWORD PTR _temp$1[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1738 : 			Q_sprintf( con.input.buffer, "\\%s", temp );

	lea	eax, DWORD PTR _temp$1[ebp]
	push	eax
	push	OFFSET ??_C@_03GFPEDOMH@?2?$CFs@
	push	OFFSET _con+13164
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1739 : 			con.input.cursor++;

	mov	eax, DWORD PTR _con+13420
	add	eax, 1
	mov	DWORD PTR _con+13420, eax
$LN5@Key_Consol:

; 1740 : 		}
; 1741 : 
; 1742 : 		// backslash text are commands, else chat
; 1743 : 		if( con.input.buffer[0] == '\\' || con.input.buffer[0] == '/' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN8@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN6@Key_Consol
$LN8@Key_Consol:

; 1744 : 			Cbuf_AddText( con.input.buffer + 1 ); // skip backslash

	push	OFFSET _con+13165
	call	_Cbuf_AddText
	add	esp, 4
	jmp	SHORT $LN7@Key_Consol
$LN6@Key_Consol:

; 1745 : 		else Cbuf_AddText( con.input.buffer ); // valid command

	push	OFFSET _con+13164
	call	_Cbuf_AddText
	add	esp, 4
$LN7@Key_Consol:

; 1746 : 		Cbuf_AddText( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4

; 1747 : 
; 1748 : 		// echo to console
; 1749 : 		Con_Printf( ">%s\n", con.input.buffer );

	push	OFFSET _con+13164
	push	OFFSET ??_C@_04BMHIGPIK@?$DO?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1750 : 
; 1751 : 		// copy line to history buffer
; 1752 : 		con.historyLines[con.nextHistoryLine % CON_HISTORY] = con.input;

	mov	eax, DWORD PTR _con+31112
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN30@Key_Consol
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN30@Key_Consol:
	imul	edi, eax, 268
	add	edi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	esi, OFFSET _con+13164
	rep movsd

; 1753 : 		con.nextHistoryLine++;

	mov	eax, DWORD PTR _con+31112
	add	eax, 1
	mov	DWORD PTR _con+31112, eax

; 1754 : 		con.historyLine = con.nextHistoryLine;

	mov	eax, DWORD PTR _con+31112
	mov	DWORD PTR _con+31108, eax

; 1755 : 
; 1756 : 		Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 1757 : 		con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 1758 : 		Con_Bottom();

	call	_Con_Bottom

; 1759 : 
; 1760 : 		if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN9@Key_Consol

; 1761 : 		{
; 1762 : 			// force an update, because the command may take some time
; 1763 : 			SCR_UpdateScreen ();

	call	_SCR_UpdateScreen
$LN9@Key_Consol:

; 1764 : 		}
; 1765 : 		return;

	jmp	$LN1@Key_Consol
$LN3@Key_Consol:

; 1766 : 	}
; 1767 : 
; 1768 : 	// command completion
; 1769 : 	if( key == K_TAB )

	cmp	DWORD PTR _key$[ebp], 9
	jne	SHORT $LN10@Key_Consol

; 1770 : 	{
; 1771 : 		Con_CompleteCommand( &con.input );

	push	OFFSET _con+13164
	call	_Con_CompleteCommand
	add	esp, 4

; 1772 : 		Con_Bottom();

	call	_Con_Bottom

; 1773 : 		return;

	jmp	$LN1@Key_Consol
$LN10@Key_Consol:

; 1774 : 	}
; 1775 : 
; 1776 : 	// command history (ctrl-p ctrl-n for unix style)
; 1777 : 	if(( key == K_MWHEELUP && Key_IsDown( K_SHIFT )) || ( key == K_UPARROW ) || (( Q_tolower(key) == 'p' ) && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 240		; 000000f0H
	jne	SHORT $LN13@Key_Consol
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@Key_Consol
$LN13@Key_Consol:
	cmp	DWORD PTR _key$[ebp], 128		; 00000080H
	je	SHORT $LN12@Key_Consol
	movzx	eax, BYTE PTR _key$[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	ecx, 112				; 00000070H
	jne	SHORT $LN11@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@Key_Consol
$LN12@Key_Consol:

; 1778 : 	{
; 1779 : 		if( con.nextHistoryLine - con.historyLine < CON_HISTORY && con.historyLine > 0 )

	mov	eax, DWORD PTR _con+31112
	sub	eax, DWORD PTR _con+31108
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN14@Key_Consol
	cmp	DWORD PTR _con+31108, 0
	jle	SHORT $LN14@Key_Consol

; 1780 : 			con.historyLine--;

	mov	eax, DWORD PTR _con+31108
	sub	eax, 1
	mov	DWORD PTR _con+31108, eax
$LN14@Key_Consol:

; 1781 : 		con.input = con.historyLines[con.historyLine % CON_HISTORY];

	mov	eax, DWORD PTR _con+31108
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN31@Key_Consol
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN31@Key_Consol:
	imul	esi, eax, 268
	add	esi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	edi, OFFSET _con+13164
	rep movsd

; 1782 : 		return;

	jmp	$LN1@Key_Consol
$LN11@Key_Consol:

; 1783 : 	}
; 1784 : 
; 1785 : 	if(( key == K_MWHEELDOWN && Key_IsDown( K_SHIFT )) || ( key == K_DOWNARROW ) || (( Q_tolower(key) == 'n' ) && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 239		; 000000efH
	jne	SHORT $LN17@Key_Consol
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@Key_Consol
$LN17@Key_Consol:
	cmp	DWORD PTR _key$[ebp], 129		; 00000081H
	je	SHORT $LN16@Key_Consol
	movzx	eax, BYTE PTR _key$[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	ecx, 110				; 0000006eH
	jne	SHORT $LN15@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@Key_Consol
$LN16@Key_Consol:

; 1786 : 	{
; 1787 : 		if( con.historyLine == con.nextHistoryLine ) return;

	mov	eax, DWORD PTR _con+31108
	cmp	eax, DWORD PTR _con+31112
	jne	SHORT $LN18@Key_Consol
	jmp	$LN1@Key_Consol
$LN18@Key_Consol:

; 1788 : 		con.historyLine++;

	mov	eax, DWORD PTR _con+31108
	add	eax, 1
	mov	DWORD PTR _con+31108, eax

; 1789 : 		con.input = con.historyLines[con.historyLine % CON_HISTORY];

	mov	eax, DWORD PTR _con+31108
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN32@Key_Consol
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN32@Key_Consol:
	imul	esi, eax, 268
	add	esi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	edi, OFFSET _con+13164
	rep movsd

; 1790 : 		return;

	jmp	$LN1@Key_Consol
$LN15@Key_Consol:

; 1791 : 	}
; 1792 : 
; 1793 : 	// console scrolling
; 1794 : 	if( key == K_PGUP )

	cmp	DWORD PTR _key$[ebp], 150		; 00000096H
	jne	SHORT $LN19@Key_Consol

; 1795 : 	{
; 1796 : 		Con_PageUp( 1 );

	push	1
	call	_Con_PageUp
	add	esp, 4

; 1797 : 		return;

	jmp	$LN1@Key_Consol
$LN19@Key_Consol:

; 1798 : 	}
; 1799 : 
; 1800 : 	if( key == K_PGDN )

	cmp	DWORD PTR _key$[ebp], 149		; 00000095H
	jne	SHORT $LN20@Key_Consol

; 1801 : 	{
; 1802 : 		Con_PageDown( 1 );

	push	1
	call	_Con_PageDown
	add	esp, 4

; 1803 : 		return;

	jmp	$LN1@Key_Consol
$LN20@Key_Consol:

; 1804 : 	}
; 1805 : 
; 1806 : 	if( key == K_MWHEELUP )

	cmp	DWORD PTR _key$[ebp], 240		; 000000f0H
	jne	SHORT $LN21@Key_Consol

; 1807 : 	{
; 1808 : 		if( Key_IsDown( K_CTRL ))

	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@Key_Consol

; 1809 : 			Con_PageUp( 8 );

	push	8
	call	_Con_PageUp
	add	esp, 4
	jmp	SHORT $LN23@Key_Consol
$LN22@Key_Consol:

; 1810 : 		else Con_PageUp( 2 );

	push	2
	call	_Con_PageUp
	add	esp, 4
$LN23@Key_Consol:

; 1811 : 		return;

	jmp	$LN1@Key_Consol
$LN21@Key_Consol:

; 1812 : 	}
; 1813 : 
; 1814 : 	if( key == K_MWHEELDOWN )

	cmp	DWORD PTR _key$[ebp], 239		; 000000efH
	jne	SHORT $LN24@Key_Consol

; 1815 : 	{	
; 1816 : 		if( Key_IsDown( K_CTRL ))

	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@Key_Consol

; 1817 : 			Con_PageDown( 8 );

	push	8
	call	_Con_PageDown
	add	esp, 4
	jmp	SHORT $LN26@Key_Consol
$LN25@Key_Consol:

; 1818 : 		else Con_PageDown( 2 );

	push	2
	call	_Con_PageDown
	add	esp, 4
$LN26@Key_Consol:

; 1819 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN24@Key_Consol:

; 1820 : 	}
; 1821 : 
; 1822 : 	// ctrl-home = top of console
; 1823 : 	if( key == K_HOME && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 151		; 00000097H
	jne	SHORT $LN27@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@Key_Consol

; 1824 : 	{
; 1825 : 		Con_Top();

	call	_Con_Top

; 1826 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN27@Key_Consol:

; 1827 : 	}
; 1828 : 
; 1829 : 	// ctrl-end = bottom of console
; 1830 : 	if( key == K_END && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 152		; 00000098H
	jne	SHORT $LN28@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Key_Consol

; 1831 : 	{
; 1832 : 		Con_Bottom();

	call	_Con_Bottom

; 1833 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN28@Key_Consol:

; 1834 : 	}
; 1835 : 
; 1836 : 	// pass to the normal editline routine
; 1837 : 	Field_KeyDownEvent( &con.input, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _con+13164
	call	_Field_KeyDownEvent
	add	esp, 8
$LN1@Key_Consol:

; 1838 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Console ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_RestoreFont
_TEXT	SEGMENT
_Con_RestoreFont PROC					; COMDAT

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 797  : 	con.curFont = con.lastUsedFont;

	mov	eax, DWORD PTR _con+13160
	mov	DWORD PTR _con+13156, eax

; 798  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_RestoreFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_CharEvent
_TEXT	SEGMENT
_key$ = 8						; size = 4
_Con_CharEvent PROC					; COMDAT

; 2322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2323 : 	// distribute the key down event to the apropriate handler
; 2324 : 	if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN2@Con_CharEv

; 2325 : 	{
; 2326 : 		Field_CharEvent( &con.input, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _con+13164
	call	_Field_CharEvent
	add	esp, 8

; 2327 : 	}

	jmp	SHORT $LN1@Con_CharEv
$LN2@Con_CharEv:

; 2328 : 	else if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN1@Con_CharEv

; 2329 : 	{
; 2330 : 		Field_CharEvent( &con.chat, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _con+13432
	call	_Field_CharEvent
	add	esp, 8
$LN1@Con_CharEv:

; 2331 : 	}
; 2332 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_SetFont
_TEXT	SEGMENT
tv67 = -72						; size = 4
tv66 = -68						; size = 4
_fontNum$ = 8						; size = 4
_Con_SetFont PROC					; COMDAT

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 783  : 	fontNum = bound( 0, fontNum, 2 ); 

	cmp	DWORD PTR _fontNum$[ebp], 0
	jl	SHORT $LN5@Con_SetFon
	cmp	DWORD PTR _fontNum$[ebp], 2
	jge	SHORT $LN3@Con_SetFon
	mov	eax, DWORD PTR _fontNum$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Con_SetFon
$LN3@Con_SetFon:
	mov	DWORD PTR tv66[ebp], 2
$LN4@Con_SetFon:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Con_SetFon
$LN5@Con_SetFon:
	mov	DWORD PTR tv67[ebp], 0
$LN6@Con_SetFon:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _fontNum$[ebp], edx

; 784  : 	con.curFont = &con.chars[fontNum];

	imul	eax, DWORD PTR _fontNum$[ebp], 4368
	add	eax, OFFSET _con+52
	mov	DWORD PTR _con+13156, eax

; 785  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_InvalidateFonts
_TEXT	SEGMENT
_Con_InvalidateFonts PROC				; COMDAT

; 2429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2430 : 	memset( con.chars, 0, sizeof( con.chars ));

	push	13104					; 00003330H
	push	0
	push	OFFSET _con+52
	call	_memset
	add	esp, 12					; 0000000cH

; 2431 : 	con.curFont = con.lastUsedFont = NULL;

	mov	DWORD PTR _con+13160, 0
	mov	eax, DWORD PTR _con+13160
	mov	DWORD PTR _con+13156, eax

; 2432 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_InvalidateFonts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DefaultColor
_TEXT	SEGMENT
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_Con_DefaultColor PROC					; COMDAT

; 2483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2484 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@Con_Defaul
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@Con_Defaul
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Con_Defaul
$LN3@Con_Defaul:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@Con_Defaul:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Con_Defaul
$LN5@Con_Defaul:
	mov	DWORD PTR tv67[ebp], 0
$LN6@Con_Defaul:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 2485 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@Con_Defaul
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@Con_Defaul
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@Con_Defaul
$LN7@Con_Defaul:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@Con_Defaul:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@Con_Defaul
$LN9@Con_Defaul:
	mov	DWORD PTR tv71[ebp], 0
$LN10@Con_Defaul:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 2486 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@Con_Defaul
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@Con_Defaul
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@Con_Defaul
$LN11@Con_Defaul:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@Con_Defaul:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@Con_Defaul
$LN13@Con_Defaul:
	mov	DWORD PTR tv75[ebp], 0
$LN14@Con_Defaul:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 2487 : 	MakeRGBA( g_color_table[7], r, g, b, 255 );

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	imul	eax, edx, 0
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _g_color_table[ecx+eax], dl
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g_color_table[ecx+edx], al
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g_color_table[edx+eax], cl
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _g_color_table[eax+edx], 255	; 000000ffH

; 2488 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DefaultColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawCharacterLen
_TEXT	SEGMENT
_number$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_Con_DrawCharacterLen PROC				; COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 822  : 	if( width && con.curFont ) *width = con.curFont->charWidths[number];

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN2@Con_DrawCh
	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN2@Con_DrawCh
	mov	eax, DWORD PTR _con+13156
	add	eax, DWORD PTR _number$[ebp]
	movzx	ecx, BYTE PTR [eax+4100]
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@Con_DrawCh:

; 823  : 	if( height && con.curFont ) *height = con.curFont->charHeight;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN1@Con_DrawCh
	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN1@Con_DrawCh
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR [ecx+4356]
	mov	DWORD PTR [eax], edx
$LN1@Con_DrawCh:

; 824  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawCharacterLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawCharacter
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_color$ = 20						; size = 4
_Con_DrawCharacter PROC					; COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 809  : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 810  : 	return Con_DrawGenericChar( x, y, number, color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawGenericChar
	add	esp, 16					; 00000010H

; 811  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawString
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_setColor$ = 20						; size = 4
_Con_DrawString PROC					; COMDAT

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 935  : 	return Con_DrawGenericString( x, y, string, setColor, false, -1 );

	push	-1
	push	0
	mov	eax, DWORD PTR _setColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H

; 936  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawStringLen
_TEXT	SEGMENT
_c$1 = -5						; size = 1
_curLength$ = -4					; size = 4
_pText$ = 8						; size = 4
_length$ = 12						; size = 4
_height$ = 16						; size = 4
_Con_DrawStringLen PROC					; COMDAT

; 834  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 835  : 	int	curLength = 0;

	mov	DWORD PTR _curLength$[ebp], 0

; 836  : 
; 837  : 	if( !con.curFont ) return;

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN4@Con_DrawSt
	jmp	$LN1@Con_DrawSt
$LN4@Con_DrawSt:

; 838  : 
; 839  : 	if( height ) *height = con.curFont->charHeight;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN5@Con_DrawSt
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR [ecx+4356]
	mov	DWORD PTR [eax], edx
$LN5@Con_DrawSt:

; 840  : 	if( !length ) return;

	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN6@Con_DrawSt
	jmp	$LN1@Con_DrawSt
$LN6@Con_DrawSt:

; 841  : 
; 842  : 	*length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Con_DrawSt:

; 843  : 
; 844  : 	while( *pText )

	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN1@Con_DrawSt

; 845  : 	{
; 846  : 		byte	c = *pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$1[ebp], cl

; 847  : 
; 848  : 		if( *pText == '\n' )

	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN7@Con_DrawSt

; 849  : 		{
; 850  : 			pText++;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 1
	mov	DWORD PTR _pText$[ebp], eax

; 851  : 			curLength = 0;

	mov	DWORD PTR _curLength$[ebp], 0
$LN7@Con_DrawSt:

; 852  : 		}
; 853  : 
; 854  : 		// skip color strings they are not drawing
; 855  : 		if( IsColorString( pText ))

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN8@Con_DrawSt
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN8@Con_DrawSt
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN8@Con_DrawSt
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN8@Con_DrawSt
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN8@Con_DrawSt

; 856  : 		{
; 857  : 			pText += 2;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 2
	mov	DWORD PTR _pText$[ebp], eax

; 858  : 			continue;

	jmp	SHORT $LN2@Con_DrawSt
$LN8@Con_DrawSt:

; 859  : 		}
; 860  : 
; 861  : 		curLength += con.curFont->charWidths[c];

	movzx	eax, BYTE PTR _c$1[ebp]
	mov	ecx, DWORD PTR _con+13156
	movzx	edx, BYTE PTR [ecx+eax+4100]
	add	edx, DWORD PTR _curLength$[ebp]
	mov	DWORD PTR _curLength$[ebp], edx

; 862  : 		pText++;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 1
	mov	DWORD PTR _pText$[ebp], eax

; 863  : 
; 864  : 		if( curLength > *length )

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _curLength$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN9@Con_DrawSt

; 865  : 			*length = curLength;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _curLength$[ebp]
	mov	DWORD PTR [eax], ecx
$LN9@Con_DrawSt:

; 866  : 	}

	jmp	$LN2@Con_DrawSt
$LN1@Con_DrawSt:

; 867  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawStringLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawVersion
_TEXT	SEGMENT
tv66 = -360						; size = 4
_curbuild$ = -292					; size = 256
_draw_version$ = -36					; size = 4
_height$ = -32						; size = 4
_start$ = -28						; size = 4
_charH$ = -24						; size = 4
_width$ = -20						; size = 4
_stringLen$ = -16					; size = 4
_i$ = -12						; size = 4
_color$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Con_DrawVersion PROC					; COMDAT

; 2237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2238 : 	// draws the current build
; 2239 : 	byte	*color = g_color_table[7];

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	mov	DWORD PTR _color$[ebp], ecx

; 2240 : 	int	i, stringLen, width = 0, charH;

	mov	DWORD PTR _width$[ebp], 0

; 2241 : 	int	start, height = glState.height;

	mov	eax, DWORD PTR _glState+4
	mov	DWORD PTR _height$[ebp], eax

; 2242 : 	qboolean	draw_version = false;

	mov	DWORD PTR _draw_version$[ebp], 0

; 2243 : 	string	curbuild;
; 2244 : 
; 2245 : 	switch( cls.scrshot_action )

	mov	eax, DWORD PTR _cls+296308
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN7@Con_DrawVe
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN7@Con_DrawVe
	jmp	SHORT $LN2@Con_DrawVe
$LN7@Con_DrawVe:

; 2246 : 	{
; 2247 : 	case scrshot_normal:
; 2248 : 	case scrshot_snapshot:
; 2249 : 		draw_version = true;

	mov	DWORD PTR _draw_version$[ebp], 1
$LN2@Con_DrawVe:

; 2250 : 		break;
; 2251 : 	}
; 2252 : 
; 2253 : 	if( !host.force_draw_version )

	cmp	DWORD PTR _host+34380, 0
	jne	SHORT $LN10@Con_DrawVe

; 2254 : 	{
; 2255 : 		if(( cls.key_dest != key_menu && !draw_version ) || CL_IsDevOverviewMode() == 2 || net_graph->value )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN12@Con_DrawVe
	cmp	DWORD PTR _draw_version$[ebp], 0
	je	SHORT $LN11@Con_DrawVe
$LN12@Con_DrawVe:
	call	_CL_IsDevOverviewMode
	cmp	eax, 2
	je	SHORT $LN11@Con_DrawVe
	mov	eax, DWORD PTR _net_graph
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@Con_DrawVe
$LN11@Con_DrawVe:

; 2256 : 			return;

	jmp	$LN5@Con_DrawVe
$LN10@Con_DrawVe:

; 2257 : 	}
; 2258 : 
; 2259 : 	if( host.force_draw_version || draw_version )

	cmp	DWORD PTR _host+34380, 0
	jne	SHORT $LN15@Con_DrawVe
	cmp	DWORD PTR _draw_version$[ebp], 0
	je	SHORT $LN13@Con_DrawVe
$LN15@Con_DrawVe:

; 2260 : 		Q_snprintf( curbuild, MAX_STRING, "Xash3D v%i/%s (build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( ));

	call	_Q_buildnum
	push	eax
	push	OFFSET ??_C@_04PNCPDLMM@0?499@
	push	49					; 00000031H
	push	OFFSET ??_C@_0BJ@JEMCKMEL@Xash3D?5v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@
	push	256					; 00000100H
	lea	eax, DWORD PTR _curbuild$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN14@Con_DrawVe
$LN13@Con_DrawVe:

; 2261 : 	else Q_snprintf( curbuild, MAX_STRING, "v%i/%s (build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( )); 

	call	_Q_buildnum
	push	eax
	push	OFFSET ??_C@_04PNCPDLMM@0?499@
	push	49					; 00000031H
	push	OFFSET ??_C@_0BC@PNIBJGBA@v?$CFi?1?$CFs?5?$CIbuild?5?$CFi?$CJ@
	push	256					; 00000100H
	lea	eax, DWORD PTR _curbuild$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN14@Con_DrawVe:

; 2262 : 	Con_DrawStringLen( curbuild, &stringLen, &charH );

	lea	eax, DWORD PTR _charH$[ebp]
	push	eax
	lea	ecx, DWORD PTR _stringLen$[ebp]
	push	ecx
	lea	edx, DWORD PTR _curbuild$[ebp]
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2263 : 	start = glState.width - stringLen * 1.05f;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _stringLen$[ebp]
	mulss	xmm1, DWORD PTR __real@3f866666
	subss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _start$[ebp], eax

; 2264 : 	stringLen = Con_StringLength( curbuild );

	lea	eax, DWORD PTR _curbuild$[ebp]
	push	eax
	call	_Con_StringLength
	add	esp, 4
	mov	DWORD PTR _stringLen$[ebp], eax

; 2265 : 	height -= charH * 1.05f;

	cvtsi2ss xmm0, DWORD PTR _charH$[ebp]
	mulss	xmm0, DWORD PTR __real@3f866666
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _height$[ebp], eax

; 2266 : 
; 2267 : 	for( i = 0; i < stringLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Con_DrawVe
$LN4@Con_DrawVe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Con_DrawVe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _stringLen$[ebp]
	jge	SHORT $LN5@Con_DrawVe

; 2268 : 		width += Con_DrawCharacter( start + width, height, curbuild[i], color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _curbuild$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], eax
	jmp	SHORT $LN4@Con_DrawVe
$LN5@Con_DrawVe:

; 2269 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawVersion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawConsole
_TEXT	SEGMENT
tv80 = -68						; size = 4
_Con_DrawConsole PROC					; COMDAT

; 2168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2169 : 	// never draw console when changelevel in-progress
; 2170 : 	if( cls.state != ca_disconnected && ( cls.changelevel || cls.changedemo ))

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN4@Con_DrawCo
	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN5@Con_DrawCo
	cmp	DWORD PTR _cls+12, 0
	je	SHORT $LN4@Con_DrawCo
$LN5@Con_DrawCo:

; 2171 : 		return;

	jmp	$LN29@Con_DrawCo
$LN4@Con_DrawCo:

; 2172 : 
; 2173 : 	// check for console width changes from a vid mode change
; 2174 : 	Con_CheckResize ();

	call	_Con_CheckResize

; 2175 : 
; 2176 : 	if( cls.state == ca_connecting || cls.state == ca_connected )

	cmp	DWORD PTR _cls, 1
	je	SHORT $LN7@Con_DrawCo
	cmp	DWORD PTR _cls, 2
	jne	$LN13@Con_DrawCo
$LN7@Con_DrawCo:

; 2177 : 	{
; 2178 : 		if( !cl_allow_levelshots->value )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@Con_DrawCo

; 2179 : 		{
; 2180 : 			if(( Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" )) && cls.key_dest != key_console )

	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@Con_DrawCo
	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@Con_DrawCo
$LN12@Con_DrawCo:
	cmp	DWORD PTR _cls+36, 0
	je	SHORT $LN10@Con_DrawCo

; 2181 : 				con.vislines = con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0
	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
	jmp	SHORT $LN11@Con_DrawCo
$LN10@Con_DrawCo:

; 2182 : 			else con.vislines = con.showlines = glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	movss	DWORD PTR _con+40, xmm0
	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN11@Con_DrawCo:

; 2183 : 		}

	jmp	SHORT $LN13@Con_DrawCo
$LN8@Con_DrawCo:

; 2184 : 		else
; 2185 : 		{
; 2186 : 			con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0

; 2187 : 
; 2188 : 			if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN13@Con_DrawCo

; 2189 : 				Con_DrawNotify(); // draw notify lines

	call	_Con_DrawNotify
$LN13@Con_DrawCo:

; 2190 : 		}
; 2191 : 	}
; 2192 : 
; 2193 : 	// if disconnected, render console full screen
; 2194 : 	switch( cls.state )

	mov	eax, DWORD PTR _cls
	mov	DWORD PTR tv80[ebp], eax
	cmp	DWORD PTR tv80[ebp], 5
	ja	$LN2@Con_DrawCo
	mov	ecx, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN31@Con_DrawCo[ecx*4]
$LN14@Con_DrawCo:

; 2195 : 	{
; 2196 : 	case ca_disconnected:
; 2197 : 		if( cls.key_dest != key_menu )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN15@Con_DrawCo

; 2198 : 		{
; 2199 : 			Con_DrawSolidConsole( glState.height );

	mov	eax, DWORD PTR _glState+4
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4

; 2200 : 			Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4
$LN15@Con_DrawCo:

; 2201 : 		}
; 2202 : 		break;

	jmp	$LN2@Con_DrawCo
$LN16@Con_DrawCo:

; 2203 : 	case ca_connecting:
; 2204 : 	case ca_connected:
; 2205 : 	case ca_validate:
; 2206 : 		// force to show console always for -dev 3 and higher 
; 2207 : 		Con_DrawSolidConsole( con.vislines );

	cvttss2si eax, DWORD PTR _con+44
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4

; 2208 : 		break;

	jmp	$LN2@Con_DrawCo
$LN19@Con_DrawCo:

; 2209 : 	case ca_active:
; 2210 : 	case ca_cinematic: 
; 2211 : 		if( Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" ))

	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@Con_DrawCo
	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@Con_DrawCo
$LN23@Con_DrawCo:

; 2212 : 		{
; 2213 : 			if( cls.key_dest == key_console ) 

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN24@Con_DrawCo

; 2214 : 				Con_DrawSolidConsole( glState.height );

	mov	eax, DWORD PTR _glState+4
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4
$LN24@Con_DrawCo:

; 2215 : 		}

	jmp	SHORT $LN27@Con_DrawCo
$LN21@Con_DrawCo:

; 2216 : 		else
; 2217 : 		{
; 2218 : 			if( con.vislines )

	movss	xmm0, DWORD PTR _con+44
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@Con_DrawCo

; 2219 : 				Con_DrawSolidConsole( con.vislines );

	cvttss2si eax, DWORD PTR _con+44
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4
	jmp	SHORT $LN27@Con_DrawCo
$LN25@Con_DrawCo:

; 2220 : 			else if( cls.state == ca_active && ( cls.key_dest == key_game || cls.key_dest == key_message ))

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN27@Con_DrawCo
	cmp	DWORD PTR _cls+36, 1
	je	SHORT $LN28@Con_DrawCo
	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN27@Con_DrawCo
$LN28@Con_DrawCo:

; 2221 : 				Con_DrawNotify(); // draw notify lines

	call	_Con_DrawNotify
$LN27@Con_DrawCo:
$LN2@Con_DrawCo:

; 2222 : 		}
; 2223 : 		break;
; 2224 : 	}
; 2225 : 
; 2226 : 	if( !Con_Visible( )) SCR_DrawFPS( 4 );

	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN29@Con_DrawCo
	push	4
	call	_SCR_DrawFPS
	add	esp, 4
$LN29@Con_DrawCo:

; 2227 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN31@Con_DrawCo:
	DD	$LN14@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN19@Con_DrawCo
	DD	$LN19@Con_DrawCo
_Con_DrawConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_RunConsole
_TEXT	SEGMENT
tv90 = -76						; size = 8
_lines_per_frame$ = -4					; size = 4
_Con_RunConsole PROC					; COMDAT

; 2279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2280 : 	float	lines_per_frame;
; 2281 : 
; 2282 : 	// decide on the destination height of the console
; 2283 : 	if( host.allow_console && cls.key_dest == key_console )

	cmp	DWORD PTR _host+34336, 0
	je	SHORT $LN2@Con_RunCon
	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN2@Con_RunCon

; 2284 : 	{
; 2285 : 		if( cls.state < ca_active || cl.first_frame )

	cmp	DWORD PTR _cls, 4
	jl	SHORT $LN6@Con_RunCon
	cmp	DWORD PTR _cl+68, 0
	je	SHORT $LN4@Con_RunCon
$LN6@Con_RunCon:

; 2286 : 			con.showlines = glState.height;	// full screen

	cvtsi2ss xmm0, DWORD PTR _glState+4
	movss	DWORD PTR _con+40, xmm0
	jmp	SHORT $LN5@Con_RunCon
$LN4@Con_RunCon:

; 2287 : 		else con.showlines = (glState.height >> 1);	// half screen	

	mov	eax, DWORD PTR _glState+4
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _con+40, xmm0
$LN5@Con_RunCon:

; 2288 : 	}

	jmp	SHORT $LN3@Con_RunCon
$LN2@Con_RunCon:

; 2289 : 	else con.showlines = 0; // none visible

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0
$LN3@Con_RunCon:

; 2290 : 
; 2291 : 	lines_per_frame = fabs( scr_conspeed->value ) * host.realframetime;

	mov	eax, DWORD PTR _scr_conspeed
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv90[ebp]
	movsd	xmm0, QWORD PTR tv90[ebp]
	mulsd	xmm0, QWORD PTR _host+1456
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _lines_per_frame$[ebp], xmm0

; 2292 : 
; 2293 : 	if( con.showlines < con.vislines )

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR _con+40
	jbe	SHORT $LN7@Con_RunCon

; 2294 : 	{
; 2295 : 		con.vislines -= lines_per_frame;

	movss	xmm0, DWORD PTR _con+44
	subss	xmm0, DWORD PTR _lines_per_frame$[ebp]
	movss	DWORD PTR _con+44, xmm0

; 2296 : 		if( con.showlines > con.vislines )

	movss	xmm0, DWORD PTR _con+40
	comiss	xmm0, DWORD PTR _con+44
	jbe	SHORT $LN9@Con_RunCon

; 2297 : 			con.vislines = con.showlines;

	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN9@Con_RunCon:

; 2298 : 	}

	jmp	SHORT $LN11@Con_RunCon
$LN7@Con_RunCon:

; 2299 : 	else if( con.showlines > con.vislines )

	movss	xmm0, DWORD PTR _con+40
	comiss	xmm0, DWORD PTR _con+44
	jbe	SHORT $LN11@Con_RunCon

; 2300 : 	{
; 2301 : 		con.vislines += lines_per_frame;

	movss	xmm0, DWORD PTR _con+44
	addss	xmm0, DWORD PTR _lines_per_frame$[ebp]
	movss	DWORD PTR _con+44, xmm0

; 2302 : 		if( con.showlines < con.vislines )

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR _con+40
	jbe	SHORT $LN11@Con_RunCon

; 2303 : 			con.vislines = con.showlines;

	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN11@Con_RunCon:

; 2304 : 	}
; 2305 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_RunConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DrawDebug
_TEXT	SEGMENT
tv140 = -340						; size = 8
_y$ = -268						; size = 4
_x$ = -264						; size = 4
_dlstring$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_Con_DrawDebug PROC					; COMDAT

; 1947 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1948 : 	static double	timeStart;
; 1949 : 	string		dlstring;
; 1950 : 	int		x, y;
; 1951 : 
; 1952 : 	if( scr_download->value != -1.0f )

	mov	eax, DWORD PTR _scr_download
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@Con_DrawDe

; 1953 : 	{
; 1954 : 		Q_snprintf( dlstring, sizeof( dlstring ), "Downloading [%d remaining]: ^2%s^7 %5.1f%% time %.f secs",

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv140[ebp]
	movsd	xmm0, QWORD PTR tv140[ebp]
	subsd	xmm0, QWORD PTR ?timeStart@?1??Con_DrawDebug@@9@9
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _scr_download
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _host+496
	mov	ecx, DWORD PTR _host+752
	push	ecx
	push	OFFSET ??_C@_0DJ@HGANGLHK@Downloading?5?$FL?$CFd?5remaining?$FN?3?5?$FO2?$CF@
	push	256					; 00000100H
	lea	edx, DWORD PTR _dlstring$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 36					; 00000024H

; 1955 : 		host.downloadcount, host.downloadfile, scr_download->value, Sys_DoubleTime() - timeStart ); 
; 1956 : 		x = glState.width - 500;

	mov	eax, DWORD PTR _glState
	sub	eax, 500				; 000001f4H
	mov	DWORD PTR _x$[ebp], eax

; 1957 : 		y = con.curFont->charHeight * 1.05f;

	mov	eax, DWORD PTR _con+13156
	cvtsi2ss xmm0, DWORD PTR [eax+4356]
	mulss	xmm0, DWORD PTR __real@3f866666
	cvttss2si ecx, xmm0
	mov	DWORD PTR _y$[ebp], ecx

; 1958 : 		Con_DrawString( x, y, dlstring, g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	lea	edx, DWORD PTR _dlstring$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 1959 : 	}

	jmp	SHORT $LN3@Con_DrawDe
$LN2@Con_DrawDe:

; 1960 : 	else
; 1961 : 	{
; 1962 : 		timeStart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR ?timeStart@?1??Con_DrawDebug@@9@9
$LN3@Con_DrawDe:

; 1963 : 	}
; 1964 : 
; 1965 : 	if( !host_developer.value || Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@Con_DrawDe
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Con_DrawDe
	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Con_DrawDe
$LN5@Con_DrawDe:

; 1966 : 		return;

	jmp	SHORT $LN7@Con_DrawDe
$LN4@Con_DrawDe:

; 1967 : 
; 1968 : 	if( con.draw_notify && !Con_Visible( ))

	cmp	DWORD PTR _con+65420, 0
	je	SHORT $LN7@Con_DrawDe
	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN7@Con_DrawDe

; 1969 : 	{
; 1970 : 		if( Con_DrawDebugLines() == 0 )

	call	_Con_DrawDebugLines
	test	eax, eax
	jne	SHORT $LN7@Con_DrawDe

; 1971 : 			con.draw_notify = false;

	mov	DWORD PTR _con+65420, 0
$LN7@Con_DrawDe:

; 1972 : 	}
; 1973 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawDebug ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_ClearNotify
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_ClearNotify PROC					; COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 184  : 	int	i;
; 185  : 	
; 186  : 	for( i = 0; i < CON_LINES_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_ClearN
$LN2@Con_ClearN:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_ClearN:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _con+24
	jge	SHORT $LN3@Con_ClearN

; 187  : 		CON_LINES( i ).addtime = 0.0;

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+edx+8], xmm0
	jmp	SHORT $LN2@Con_ClearN
$LN3@Con_ClearN:

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ClearNotify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_ToggleConsole_f
_TEXT	SEGMENT
_Con_ToggleConsole_f PROC				; COMDAT

; 285  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 286  : 	if( !host.allow_console || UI_CreditsActive( ))

	cmp	DWORD PTR _host+34336, 0
	je	SHORT $LN3@Con_Toggle
	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN2@Con_Toggle
$LN3@Con_Toggle:

; 287  : 		return; // disabled

	jmp	SHORT $LN1@Con_Toggle
$LN2@Con_Toggle:

; 288  : 
; 289  : 	// show console only in game or by special call from menu
; 290  : 	if( cls.state != ca_active || cls.key_dest == key_menu )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@Con_Toggle
	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN4@Con_Toggle
$LN5@Con_Toggle:

; 291  : 		return;

	jmp	SHORT $LN1@Con_Toggle
$LN4@Con_Toggle:

; 292  : 
; 293  : 	Con_ClearTyping();

	call	_Con_ClearTyping

; 294  : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 295  : 
; 296  : 	if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN6@Con_Toggle

; 297  : 	{
; 298  : 		if( Cvar_VariableInteger( "sv_background" ) || Cvar_VariableInteger( "cl_background" ))

	push	OFFSET ??_C@_0O@DOOGBBKD@sv_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@Con_Toggle
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Con_Toggle
$LN10@Con_Toggle:

; 299  : 			UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN9@Con_Toggle
$LN8@Con_Toggle:

; 300  : 		else UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4
$LN9@Con_Toggle:

; 301  : 	}

	jmp	SHORT $LN1@Con_Toggle
$LN6@Con_Toggle:

; 302  : 	else
; 303  : 	{
; 304  : 		UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4

; 305  : 		Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4
$LN1@Con_Toggle:

; 306  : 	}
; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ToggleConsole_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Shutdown
_TEXT	SEGMENT
_Con_Shutdown PROC					; COMDAT

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 995  : 	con.initialized = false;

	mov	DWORD PTR _con, 0

; 996  : 
; 997  : 	if( con.buffer )

	cmp	DWORD PTR _con+4, 0
	je	SHORT $LN2@Con_Shutdo

; 998  : 		Mem_Free( con.buffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_Shutdown@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _con+4
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@Con_Shutdo:

; 999  : 
; 1000 : 	if( con.lines )

	cmp	DWORD PTR _con+12, 0
	je	SHORT $LN3@Con_Shutdo

; 1001 : 		Mem_Free( con.lines );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_Shutdown@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _con+12
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@Con_Shutdo:

; 1002 : 
; 1003 : 	con.buffer = NULL;

	mov	DWORD PTR _con+4, 0

; 1004 : 	con.lines = NULL;

	mov	DWORD PTR _con+12, 0

; 1005 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_VidInit
_TEXT	SEGMENT
_y$1 = -96						; size = 4
_x$2 = -92						; size = 4
_dest$3 = -88						; size = 4
_ver$4 = -84						; size = 64
_cb$5 = -20						; size = 4
_chars$6 = -16						; size = 4
_length$7 = -12						; size = 4
_draw_to_console$8 = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_Con_VidInit PROC					; COMDAT

; 2342 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2343 : 	Con_CheckResize();

	call	_Con_CheckResize

; 2344 : 
; 2345 : 	Con_LoadConchars();

	call	_Con_LoadConchars

; 2346 : 
; 2347 : 	// loading console image
; 2348 : 	if( host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	je	$LN5@Con_VidIni

; 2349 : 	{
; 2350 : 		// trying to load truecolor image first
; 2351 : 		if( FS_FileExists( "gfx/shell/conback.bmp", false ) || FS_FileExists( "gfx/shell/conback.tga", false ))

	push	0
	push	OFFSET ??_C@_0BG@HHLPGLEH@gfx?1shell?1conback?4bmp@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@Con_VidIni
	push	0
	push	OFFSET ??_C@_0BG@FMIDMFMC@gfx?1shell?1conback?4tga@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@Con_VidIni
$LN8@Con_VidIni:

; 2352 : 			con.background = GL_LoadTexture( "gfx/shell/conback", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0BC@DJCOGMDD@gfx?1shell?1conback@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN7@Con_VidIni:

; 2353 : 
; 2354 : 		if( !con.background )

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN9@Con_VidIni

; 2355 : 		{
; 2356 : 			if( FS_FileExists( "cached/conback640", false ))

	push	0
	push	OFFSET ??_C@_0BC@NLNHOONG@cached?1conback640@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@Con_VidIni

; 2357 : 				con.background = GL_LoadTexture( "cached/conback640", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0BC@NLNHOONG@cached?1conback640@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
	jmp	SHORT $LN9@Con_VidIni
$LN10@Con_VidIni:

; 2358 : 			else if( FS_FileExists( "cached/conback", false ))

	push	0
	push	OFFSET ??_C@_0P@OOIJEEJJ@cached?1conback@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@Con_VidIni

; 2359 : 				con.background = GL_LoadTexture( "cached/conback", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0P@OOIJEEJJ@cached?1conback@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN9@Con_VidIni:

; 2360 : 		}
; 2361 : 	}

	jmp	$LN6@Con_VidIni
$LN5@Con_VidIni:

; 2362 : 	else
; 2363 : 	{
; 2364 : 		// trying to load truecolor image first
; 2365 : 		if( FS_FileExists( "gfx/shell/loading.bmp", false ) || FS_FileExists( "gfx/shell/loading.tga", false ))

	push	0
	push	OFFSET ??_C@_0BG@ECMKGMDP@gfx?1shell?1loading?4bmp@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@Con_VidIni
	push	0
	push	OFFSET ??_C@_0BG@GJPGMCLK@gfx?1shell?1loading?4tga@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@Con_VidIni
$LN14@Con_VidIni:

; 2366 : 			con.background = GL_LoadTexture( "gfx/shell/loading", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0BC@PPMBMNFK@gfx?1shell?1loading@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN13@Con_VidIni:

; 2367 : 
; 2368 : 		if( !con.background )

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN6@Con_VidIni

; 2369 : 		{
; 2370 : 			if( FS_FileExists( "cached/loading640", false ))

	push	0
	push	OFFSET ??_C@_0BC@BLHIGMPO@cached?1loading640@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@Con_VidIni

; 2371 : 				con.background = GL_LoadTexture( "cached/loading640", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0BC@BLHIGMPO@cached?1loading640@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
	jmp	SHORT $LN6@Con_VidIni
$LN16@Con_VidIni:

; 2372 : 			else if( FS_FileExists( "cached/loading", false ))

	push	0
	push	OFFSET ??_C@_0P@CIGGOFPA@cached?1loading@
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Con_VidIni

; 2373 : 				con.background = GL_LoadTexture( "cached/loading", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0P@CIGGOFPA@cached?1loading@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN6@Con_VidIni:

; 2374 : 		}
; 2375 : 	}
; 2376 : 
; 2377 : 
; 2378 : 	if( !con.background ) // last chance - quake conback image

	cmp	DWORD PTR _con+48, 0
	jne	$LN19@Con_VidIni

; 2379 : 	{
; 2380 : 		qboolean		draw_to_console = false;

	mov	DWORD PTR _draw_to_console$8[ebp], 0

; 2381 : 		int		length = 0;

	mov	DWORD PTR _length$7[ebp], 0

; 2382 : 		gl_texture_t	*chars;
; 2383 : 
; 2384 : 		// NOTE: only these games want to draw build number into console background
; 2385 : 		if( !Q_stricmp( FS_Gamedir(), "id1" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03BBBGPMCE@id1@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@Con_VidIni

; 2386 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$8[ebp], 1
$LN20@Con_VidIni:

; 2387 : 
; 2388 : 		if( !Q_stricmp( FS_Gamedir(), "hipnotic" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08BJJGNCOA@hipnotic@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Con_VidIni

; 2389 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$8[ebp], 1
$LN21@Con_VidIni:

; 2390 : 
; 2391 : 		if( !Q_stricmp( FS_Gamedir(), "rogue" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05PPPEOIOJ@rogue@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@Con_VidIni

; 2392 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$8[ebp], 1
$LN22@Con_VidIni:

; 2393 : 
; 2394 : 		if( draw_to_console && con.curFont && ( chars = R_GetTexture( con.curFont->hFontTexture )) != NULL && chars->original )

	cmp	DWORD PTR _draw_to_console$8[ebp], 0
	je	$LN23@Con_VidIni
	cmp	DWORD PTR _con+13156, 0
	je	$LN23@Con_VidIni
	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _chars$6[ebp], eax
	cmp	DWORD PTR _chars$6[ebp], 0
	je	$LN23@Con_VidIni
	mov	eax, DWORD PTR _chars$6[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	$LN23@Con_VidIni

; 2395 : 		{
; 2396 : 			lmp_t	*cb = (lmp_t *)FS_LoadFile( "gfx/conback.lmp", &length, false );

	push	0
	lea	eax, DWORD PTR _length$7[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@HPEGNDIC@gfx?1conback?4lmp@
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cb$5[ebp], eax

; 2397 : 			char	ver[64];
; 2398 : 			byte	*dest;
; 2399 : 			int	x, y;
; 2400 : 
; 2401 : 			if( cb && cb->width == 320 && cb->height == 200 )

	cmp	DWORD PTR _cb$5[ebp], 0
	je	$LN24@Con_VidIni
	mov	eax, DWORD PTR _cb$5[ebp]
	cmp	DWORD PTR [eax], 320			; 00000140H
	jne	$LN24@Con_VidIni
	mov	eax, DWORD PTR _cb$5[ebp]
	cmp	DWORD PTR [eax+4], 200			; 000000c8H
	jne	$LN24@Con_VidIni

; 2402 : 			{
; 2403 : 				Q_snprintf( ver, 64, "%i", Q_buildnum( )); // can store only buildnum

	call	_Q_buildnum
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	push	64					; 00000040H
	lea	eax, DWORD PTR _ver$4[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2404 : 				dest = (byte *)(cb + 1) + 320 * 186 + 320 - 11 - 8 * Q_strlen( ver );

	mov	esi, DWORD PTR _cb$5[ebp]
	add	esi, 59837				; 0000e9bdH
	lea	eax, DWORD PTR _ver$4[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	shl	eax, 3
	sub	esi, eax
	mov	DWORD PTR _dest$3[ebp], esi

; 2405 : 				y = Q_strlen( ver );

	lea	eax, DWORD PTR _ver$4[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _y$1[ebp], eax

; 2406 : 				for( x = 0; x < y; x++ )

	mov	DWORD PTR _x$2[ebp], 0
	jmp	SHORT $LN4@Con_VidIni
$LN2@Con_VidIni:
	mov	eax, DWORD PTR _x$2[ebp]
	add	eax, 1
	mov	DWORD PTR _x$2[ebp], eax
$LN4@Con_VidIni:
	mov	eax, DWORD PTR _x$2[ebp]
	cmp	eax, DWORD PTR _y$1[ebp]
	jge	SHORT $LN3@Con_VidIni

; 2407 : 					Con_DrawCharToConback( ver[x], chars->original->buffer, dest + (x << 3));

	mov	eax, DWORD PTR _x$2[ebp]
	mov	ecx, DWORD PTR _dest$3[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _chars$6[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _x$2[ebp]
	movsx	ecx, BYTE PTR _ver$4[ebp+eax]
	push	ecx
	call	_Con_DrawCharToConback
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Con_VidIni
$LN3@Con_VidIni:

; 2408 : 				con.background = GL_LoadTexture( "#gfx/conback.lmp", (byte *)cb, length, TF_IMAGE );

	push	6144					; 00001800H
	mov	eax, DWORD PTR _length$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cb$5[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@CHCLAABE@?$CDgfx?1conback?4lmp@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN24@Con_VidIni:

; 2409 : 			}
; 2410 : 			if( cb ) Mem_Free( cb );

	cmp	DWORD PTR _cb$5[ebp], 0
	je	SHORT $LN23@Con_VidIni
	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_VidInit@@9@9
	add	eax, 68					; 00000044H
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cb$5[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@Con_VidIni:

; 2411 : 		}
; 2412 : 
; 2413 : 		if( !con.background ) // trying the load unmodified conback

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN19@Con_VidIni

; 2414 : 			con.background = GL_LoadTexture( "gfx/conback.lmp", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET ??_C@_0BA@HPEGNDIC@gfx?1conback?4lmp@
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN19@Con_VidIni:

; 2415 : 	}
; 2416 : 
; 2417 : 	// missed console image will be replaced as gray background like X-Ray or Crysis
; 2418 : 	if( con.background == tr.defaultTexture || con.background == 0 )

	mov	eax, DWORD PTR _con+48
	cmp	eax, DWORD PTR _tr
	je	SHORT $LN28@Con_VidIni
	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN1@Con_VidIni
$LN28@Con_VidIni:

; 2419 : 		con.background = tr.grayTexture;

	mov	eax, DWORD PTR _tr+12
	mov	DWORD PTR _con+48, eax
$LN1@Con_VidIni:

; 2420 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_VidInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_FixedFont
_TEXT	SEGMENT
_Con_FixedFont PROC					; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 546  : 	if( con.curFont && con.curFont->valid && con.curFont->type == FONT_FIXED )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN2@Con_FixedF
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN2@Con_FixedF
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax+4360], 0
	jne	SHORT $LN2@Con_FixedF

; 547  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Con_FixedF
$LN2@Con_FixedF:

; 548  : 	return false;

	xor	eax, eax
$LN1@Con_FixedF:

; 549  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_FixedFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Visible
_TEXT	SEGMENT
tv65 = -68						; size = 4
_Con_Visible PROC					; COMDAT

; 535  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 536  : 	return (con.vislines > 0);

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Con_Visibl
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@Con_Visibl
$LN3@Con_Visibl:
	mov	DWORD PTR tv65[ebp], 0
$LN4@Con_Visibl:
	mov	eax, DWORD PTR tv65[ebp]

; 537  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Visible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Cmd_AutoComplete
_TEXT	SEGMENT
_input$ = -272						; size = 268
__$ArrayPad$ = -4					; size = 4
_complete_string$ = 8					; size = 4
_Cmd_AutoComplete PROC					; COMDAT

; 2442 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2443 : 	field_t	input;
; 2444 : 
; 2445 : 	if( !complete_string || !*complete_string )

	cmp	DWORD PTR _complete_string$[ebp], 0
	je	SHORT $LN3@Cmd_AutoCo
	mov	eax, DWORD PTR _complete_string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Cmd_AutoCo
$LN3@Cmd_AutoCo:

; 2446 : 		return;

	jmp	$LN1@Cmd_AutoCo
$LN2@Cmd_AutoCo:

; 2447 : 
; 2448 : 	// setup input
; 2449 : 	Q_strncpy( input.buffer, complete_string, sizeof( input.buffer ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _complete_string$[ebp]
	push	eax
	lea	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2450 : 	input.cursor = input.scroll = 0;

	mov	DWORD PTR _input$[ebp+260], 0
	mov	eax, DWORD PTR _input$[ebp+260]
	mov	DWORD PTR _input$[ebp+256], eax

; 2451 : 
; 2452 : 	Con_CompleteCommand( &input );

	lea	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_Con_CompleteCommand
	add	esp, 4

; 2453 : 
; 2454 : 	// setup output
; 2455 : 	if( input.buffer[0] == '\\' || input.buffer[0] == '/' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _input$[ebp+ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN6@Cmd_AutoCo
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _input$[ebp+ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN4@Cmd_AutoCo
$LN6@Cmd_AutoCo:

; 2456 : 		Q_strncpy( complete_string, input.buffer + 1, sizeof( input.buffer ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _input$[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _complete_string$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Cmd_AutoCo
$LN4@Cmd_AutoCo:

; 2457 : 	else Q_strncpy( complete_string, input.buffer, sizeof( input.buffer ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _complete_string$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@Cmd_AutoCo:

; 2458 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AutoComplete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _UI_NXPrintf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_info$ = 8						; size = 4
_fmt$ = 12						; size = 4
_UI_NXPrintf PROC					; COMDAT

; 1238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1239 : 	va_list	args;
; 1240 : 
; 1241 : 	if( !info ) return;

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN2@UI_NXPrint
	jmp	$LN1@UI_NXPrint
$LN2@UI_NXPrint:

; 1242 : 
; 1243 : 	if( info->index < 0 || info->index >= MAX_DBG_NOTIFY )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN4@UI_NXPrint
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 128			; 00000080H
	jl	SHORT $LN3@UI_NXPrint
$LN4@UI_NXPrint:

; 1244 : 		return;

	jmp	$LN1@UI_NXPrint
$LN3@UI_NXPrint:

; 1245 : 
; 1246 : 	memset( con.notify[info->index].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	add	ecx, OFFSET _con+31116
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1247 : 
; 1248 : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1249 : 	Q_vsnprintf( con.notify[info->index].szNotify, MAX_STRING, fmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	256					; 00000100H
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1250 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1251 : 
; 1252 : 	// setup values
; 1253 : 	con.notify[info->index].key_dest = key_menu;

	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	DWORD PTR _con[ecx+31380], 2

; 1254 : 	con.notify[info->index].expire = host.realtime + info->time_to_live;

	mov	eax, DWORD PTR _info$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	addsd	xmm0, QWORD PTR _host+1440
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[edx+31372], xmm0

; 1255 : 	MakeRGBA( con.notify[info->index].color, (byte)(info->color[0] * 255), (byte)(info->color[1] * 255), (byte)(info->color[2] * 255), 255 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	ecx, 1
	imul	ecx, ecx, 0
	mov	BYTE PTR _con[edx+ecx+31376], al
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _con[eax+edx+31376], cl
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _con[ecx+eax+31376], dl
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _con[edx+ecx+31376], 255	; 000000ffH

; 1256 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@UI_NXPrint:

; 1257 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_NXPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _UI_NPrintf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_idx$ = 8						; size = 4
_fmt$ = 12						; size = 4
_UI_NPrintf PROC					; COMDAT

; 1211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1212 : 	va_list	args;
; 1213 : 
; 1214 : 	if( idx < 0 || idx >= MAX_DBG_NOTIFY )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@UI_NPrintf
	cmp	DWORD PTR _idx$[ebp], 128		; 00000080H
	jl	SHORT $LN2@UI_NPrintf
$LN3@UI_NPrintf:

; 1215 : 		return;

	jmp	$LN1@UI_NPrintf
$LN2@UI_NPrintf:

; 1216 : 
; 1217 : 	memset( con.notify[idx].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	imul	eax, DWORD PTR _idx$[ebp], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1218 : 
; 1219 : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1220 : 	Q_vsnprintf( con.notify[idx].szNotify, MAX_STRING, fmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	256					; 00000100H
	imul	edx, DWORD PTR _idx$[ebp], 268
	add	edx, OFFSET _con+31116
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1221 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1222 : 
; 1223 : 	// reset values
; 1224 : 	con.notify[idx].key_dest = key_menu;

	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	DWORD PTR _con[eax+31380], 2

; 1225 : 	con.notify[idx].expire = host.realtime + 4.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4010000000000000
	imul	eax, DWORD PTR _idx$[ebp], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[eax+31372], xmm0

; 1226 : 	MakeRGBA( con.notify[idx].color, 255, 255, 255, 255 );

	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _con[eax+edx+31376], 255	; 000000ffH
	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _con[eax+ecx+31376], 255	; 000000ffH
	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _con[edx+eax+31376], 255	; 000000ffH
	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH

; 1227 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@UI_NPrintf:

; 1228 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_NPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_NXPrintf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_info$ = 8						; size = 4
_fmt$ = 12						; size = 4
_Con_NXPrintf PROC					; COMDAT

; 1182 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1183 : 	va_list	args;
; 1184 : 
; 1185 : 	if( !info ) return;

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN2@Con_NXPrin
	jmp	$LN1@Con_NXPrin
$LN2@Con_NXPrin:

; 1186 : 
; 1187 : 	if( info->index < 0 || info->index >= MAX_DBG_NOTIFY )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN4@Con_NXPrin
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 128			; 00000080H
	jl	SHORT $LN3@Con_NXPrin
$LN4@Con_NXPrin:

; 1188 : 		return;

	jmp	$LN1@Con_NXPrin
$LN3@Con_NXPrin:

; 1189 : 
; 1190 : 	memset( con.notify[info->index].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	add	ecx, OFFSET _con+31116
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1191 : 
; 1192 : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1193 : 	Q_vsnprintf( con.notify[info->index].szNotify, MAX_STRING, fmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	256					; 00000100H
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1194 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1195 : 
; 1196 : 	// setup values
; 1197 : 	con.notify[info->index].key_dest = key_game;

	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	DWORD PTR _con[ecx+31380], 1

; 1198 : 	con.notify[info->index].expire = host.realtime + info->time_to_live;

	mov	eax, DWORD PTR _info$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	addsd	xmm0, QWORD PTR _host+1440
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[edx+31372], xmm0

; 1199 : 	MakeRGBA( con.notify[info->index].color, (byte)(info->color[0] * 255), (byte)(info->color[1] * 255), (byte)(info->color[2] * 255), 255 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	ecx, 1
	imul	ecx, ecx, 0
	mov	BYTE PTR _con[edx+ecx+31376], al
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _con[eax+edx+31376], cl
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _con[ecx+eax+31376], dl
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _con[edx+ecx+31376], 255	; 000000ffH

; 1200 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@Con_NXPrin:

; 1201 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_NXPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_NPrintf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_idx$ = 8						; size = 4
_fmt$ = 12						; size = 4
_Con_NPrintf PROC					; COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1156 : 	va_list	args;
; 1157 : 
; 1158 : 	if( idx < 0 || idx >= MAX_DBG_NOTIFY )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@Con_NPrint
	cmp	DWORD PTR _idx$[ebp], 128		; 00000080H
	jl	SHORT $LN2@Con_NPrint
$LN3@Con_NPrint:

; 1159 : 		return;

	jmp	$LN1@Con_NPrint
$LN2@Con_NPrint:

; 1160 : 
; 1161 : 	memset( con.notify[idx].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	imul	eax, DWORD PTR _idx$[ebp], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1162 : 
; 1163 : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1164 : 	Q_vsnprintf( con.notify[idx].szNotify, MAX_STRING, fmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	256					; 00000100H
	imul	edx, DWORD PTR _idx$[ebp], 268
	add	edx, OFFSET _con+31116
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1165 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1166 : 
; 1167 : 	// reset values
; 1168 : 	con.notify[idx].key_dest = key_game;

	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	DWORD PTR _con[eax+31380], 1

; 1169 : 	con.notify[idx].expire = host.realtime + 4.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4010000000000000
	imul	eax, DWORD PTR _idx$[ebp], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[eax+31372], xmm0

; 1170 : 	MakeRGBA( con.notify[idx].color, 255, 255, 255, 255 );

	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _con[eax+edx+31376], 255	; 000000ffH
	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _con[eax+ecx+31376], 255	; 000000ffH
	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _con[edx+eax+31376], 255	; 000000ffH
	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH

; 1171 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@Con_NPrint:

; 1172 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_NPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Print
_TEXT	SEGMENT
tv78 = -76						; size = 4
_mask$ = -8						; size = 4
_c$ = -4						; size = 4
_txt$ = 8						; size = 4
_Con_Print PROC						; COMDAT

; 1017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1018 : 	static int	cr_pending = 0;
; 1019 : 	static char	buf[MAX_PRINT_MSG];
; 1020 : 	static qboolean	inupdate;
; 1021 : 	static int	bufpos = 0;
; 1022 : 	int		c, mask = 0;

	mov	DWORD PTR _mask$[ebp], 0

; 1023 : 
; 1024 : 	// client not running
; 1025 : 	if( !con.initialized || !con.buffer )

	cmp	DWORD PTR _con, 0
	je	SHORT $LN8@Con_Print
	cmp	DWORD PTR _con+4, 0
	jne	SHORT $LN7@Con_Print
$LN8@Con_Print:

; 1026 : 		return;

	jmp	$LN19@Con_Print
$LN7@Con_Print:

; 1027 : 
; 1028 : 	if( txt[0] == 2 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _txt$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 2
	jne	SHORT $LN9@Con_Print

; 1029 : 	{
; 1030 : 		// go to colored text
; 1031 : 		if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN10@Con_Print

; 1032 : 			mask = 128;

	mov	DWORD PTR _mask$[ebp], 128		; 00000080H
$LN10@Con_Print:

; 1033 : 		txt++;

	mov	eax, DWORD PTR _txt$[ebp]
	add	eax, 1
	mov	DWORD PTR _txt$[ebp], eax
$LN9@Con_Print:

; 1034 : 	}
; 1035 : 
; 1036 : 	for( ; *txt; txt++ )

	jmp	SHORT $LN4@Con_Print
$LN2@Con_Print:
	mov	eax, DWORD PTR _txt$[ebp]
	add	eax, 1
	mov	DWORD PTR _txt$[ebp], eax
$LN4@Con_Print:
	mov	eax, DWORD PTR _txt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Con_Print

; 1037 : 	{
; 1038 : 		if( cr_pending )

	cmp	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 0
	je	SHORT $LN11@Con_Print

; 1039 : 		{
; 1040 : 			Con_DeleteLastLine();

	call	_Con_DeleteLastLine

; 1041 : 			cr_pending = 0;

	mov	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 0
$LN11@Con_Print:

; 1042 : 		}
; 1043 : 
; 1044 : 		c = *txt;

	mov	eax, DWORD PTR _txt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx

; 1045 : 
; 1046 : 		switch( c )

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 0
	je	SHORT $LN12@Con_Print
	cmp	DWORD PTR tv78[ebp], 10			; 0000000aH
	je	SHORT $LN14@Con_Print
	cmp	DWORD PTR tv78[ebp], 13			; 0000000dH
	je	SHORT $LN13@Con_Print
	jmp	SHORT $LN15@Con_Print
$LN12@Con_Print:

; 1047 : 		{
; 1048 : 		case '\0':
; 1049 : 			break;

	jmp	$LN5@Con_Print
$LN13@Con_Print:

; 1050 : 		case '\r':
; 1051 : 			Con_AddLine( buf, bufpos );

	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 8

; 1052 : 			cr_pending = 1;

	mov	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 1

; 1053 : 			bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0

; 1054 : 			break;

	jmp	SHORT $LN5@Con_Print
$LN14@Con_Print:

; 1055 : 		case '\n':
; 1056 : 			Con_AddLine( buf, bufpos );

	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 8

; 1057 : 			bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0

; 1058 : 			break;

	jmp	SHORT $LN5@Con_Print
$LN15@Con_Print:

; 1059 : 		default:
; 1060 : 			buf[bufpos++] = c | mask;

	mov	eax, DWORD PTR _c$[ebp]
	or	eax, DWORD PTR _mask$[ebp]
	mov	ecx, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	mov	BYTE PTR ?buf@?1??Con_Print@@9@9[ecx], al
	mov	edx, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	add	edx, 1
	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, edx

; 1061 : 			if(( bufpos >= sizeof( buf ) - 1 ) || bufpos >= ( con.linewidth - 1 ))

	cmp	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 8191 ; 00001fffH
	jae	SHORT $LN17@Con_Print
	mov	eax, DWORD PTR _con+36
	sub	eax, 1
	cmp	DWORD PTR ?bufpos@?1??Con_Print@@9@9, eax
	jl	SHORT $LN16@Con_Print
$LN17@Con_Print:

; 1062 : 			{
; 1063 : 				Con_AddLine( buf, bufpos );

	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 8

; 1064 : 				bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0
$LN16@Con_Print:
$LN5@Con_Print:

; 1065 : 			}
; 1066 : 			break;
; 1067 : 		}
; 1068 : 	}

	jmp	$LN2@Con_Print
$LN3@Con_Print:

; 1069 : 
; 1070 : 	if( cls.state != ca_disconnected && cls.state < ca_active && !cl.video_prepped && !cls.disable_screen )

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN19@Con_Print
	cmp	DWORD PTR _cls, 4
	jge	SHORT $LN19@Con_Print
	cmp	DWORD PTR _cl+16, 0
	jne	SHORT $LN19@Con_Print
	movss	xmm0, DWORD PTR _cls+24
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@Con_Print

; 1071 : 	{
; 1072 : 		if( !inupdate )

	cmp	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 0
	jne	SHORT $LN19@Con_Print

; 1073 : 		{
; 1074 : 			inupdate = true;

	mov	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 1

; 1075 : 			SCR_UpdateScreen ();

	call	_SCR_UpdateScreen

; 1076 : 			inupdate = false;

	mov	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 0
$LN19@Con_Print:

; 1077 : 		}
; 1078 : 	}
; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Init
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_Init PROC						; COMDAT

; 944  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 945  : 	int	i;
; 946  : 
; 947  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@Con_Init

; 948  : 		return; // dedicated server already have console

	jmp	$LN1@Con_Init
$LN5@Con_Init:

; 949  : 
; 950  : 	// must be init before startup video subsystem
; 951  : 	scr_conspeed = Cvar_Get( "scr_conspeed", "600", FCVAR_ARCHIVE, "console moving speed" );

	push	OFFSET ??_C@_0BF@CAMOCHIE@console?5moving?5speed@
	push	1
	push	OFFSET ??_C@_03PANGFEPN@600@
	push	OFFSET ??_C@_0N@MGJFCGAP@scr_conspeed@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _scr_conspeed, eax

; 952  : 	con_notifytime = Cvar_Get( "con_notifytime", "3", FCVAR_ARCHIVE, "notify time to live" );

	push	OFFSET ??_C@_0BE@IFHMLKJ@notify?5time?5to?5live@
	push	1
	push	OFFSET ??_C@_01EKENIIDA@3@
	push	OFFSET ??_C@_0P@INMLCMIF@con_notifytime@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con_notifytime, eax

; 953  : 	con_fontsize = Cvar_Get( "con_fontsize", "1", FCVAR_ARCHIVE, "console font number (0, 1 or 2)" );

	push	OFFSET ??_C@_0CA@IPEAEPHH@console?5font?5number?5?$CI0?0?51?5or?52?$CJ@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0N@IHPBPOML@con_fontsize@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con_fontsize, eax

; 954  : 
; 955  : 	// init the console buffer
; 956  : 	con.bufsize = CON_TEXTSIZE;

	mov	DWORD PTR _con+8, 1048576		; 00100000H

; 957  : 	con.buffer = (char *)Z_Calloc( con.bufsize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_Init@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _con+8
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _con+4, eax

; 958  : 	con.maxlines = CON_MAXLINES;

	mov	DWORD PTR _con+16, 16384		; 00004000H

; 959  : 	con.lines = (con_lineinfo_t *)Z_Calloc( con.maxlines * sizeof( *con.lines ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Con_Init@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DE@GCOAEKEN@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _con+16
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _con+12, eax

; 960  : 	con.lines_first = con.lines_count = 0;

	mov	DWORD PTR _con+24, 0
	mov	eax, DWORD PTR _con+24
	mov	DWORD PTR _con+20, eax

; 961  : 	con.num_times = CON_TIMES; // default as 4

	mov	DWORD PTR _con+28, 4

; 962  : 
; 963  : 	Con_CheckResize();

	call	_Con_CheckResize

; 964  : 
; 965  : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 966  : 	con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 967  : 
; 968  : 	Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 969  : 	con.chat.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13696, eax

; 970  : 
; 971  : 	for( i = 0; i < CON_HISTORY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_Init
$LN2@Con_Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_Init:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@Con_Init

; 972  : 	{
; 973  : 		Con_ClearField( &con.historyLines[i] );

	imul	eax, DWORD PTR _i$[ebp], 268
	add	eax, OFFSET _con+13956
	push	eax
	call	_Con_ClearField
	add	esp, 4

; 974  : 		con.historyLines[i].widthInChars = con.linewidth;

	imul	eax, DWORD PTR _i$[ebp], 268
	mov	ecx, DWORD PTR _con+36
	mov	DWORD PTR _con[eax+14220], ecx

; 975  : 	}

	jmp	SHORT $LN2@Con_Init
$LN3@Con_Init:

; 976  : 
; 977  : 	Cmd_AddCommand( "toggleconsole", Con_ToggleConsole_f, "opens or closes the console" );

	push	OFFSET ??_C@_0BM@NLDOPNPC@opens?5or?5closes?5the?5console@
	push	OFFSET _Con_ToggleConsole_f
	push	OFFSET ??_C@_0O@JJBKLGLG@toggleconsole@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 978  : 	Cmd_AddCommand( "con_color", Con_SetColor_f, "set a custom console color" );

	push	OFFSET ??_C@_0BL@DCHKFMKF@set?5a?5custom?5console?5color@
	push	OFFSET _Con_SetColor_f
	push	OFFSET ??_C@_09PPDAPOC@con_color@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 979  : 	Cmd_AddCommand( "clear", Con_Clear_f, "clear console history" );

	push	OFFSET ??_C@_0BG@IHNLBNJN@clear?5console?5history@
	push	OFFSET _Con_Clear_f
	push	OFFSET ??_C@_05MEHLAELG@clear@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 980  : 	Cmd_AddCommand( "messagemode", Con_MessageMode_f, "enable message mode \"say\"" );

	push	OFFSET ??_C@_0BK@JLLANAOF@enable?5message?5mode?5?$CCsay?$CC@
	push	OFFSET _Con_MessageMode_f
	push	OFFSET ??_C@_0M@JINOELJH@messagemode@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 981  : 	Cmd_AddCommand( "messagemode2", Con_MessageMode2_f, "enable message mode \"say_team\"" );

	push	OFFSET ??_C@_0BP@LJHCNEMD@enable?5message?5mode?5?$CCsay_team?$CC@
	push	OFFSET _Con_MessageMode2_f
	push	OFFSET ??_C@_0N@IDIDIMNN@messagemode2@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 982  : 	Cmd_AddCommand( "contimes", Con_SetTimes_f, "change number of console overlay lines (4-64)" );

	push	OFFSET ??_C@_0CO@EHLOLBON@change?5number?5of?5console?5overla@
	push	OFFSET _Con_SetTimes_f
	push	OFFSET ??_C@_08CJIJIFFE@contimes@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 983  : 	con.initialized = true;

	mov	DWORD PTR _con, 1

; 984  : 
; 985  : 	Con_Printf( "Console initialized.\n" );

	push	OFFSET ??_C@_0BG@PCBGEEM@Console?5initialized?4?6@
	call	_Con_Printf
	add	esp, 4
$LN1@Con_Init:

; 986  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Printf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_Printf PROC					; COMDAT

; 1088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1089 : 	static char	buffer[MAX_PRINT_MSG];
; 1090 : 	va_list		args;
; 1091 : 
; 1092 : 	if( !host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	jne	SHORT $LN2@Con_Printf

; 1093 : 		return;

	jmp	SHORT $LN1@Con_Printf
$LN2@Con_Printf:

; 1094 : 
; 1095 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1096 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_Printf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1097 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1098 : 
; 1099 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_Printf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_Printf:

; 1100 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_DPrintf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_DPrintf PROC					; COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1110 : 	static char	buffer[MAX_PRINT_MSG];
; 1111 : 	va_list		args;
; 1112 : 
; 1113 : 	if( host_developer.value < DEV_NORMAL )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN2@Con_DPrint

; 1114 : 		return;

	jmp	SHORT $LN1@Con_DPrint
$LN2@Con_DPrint:

; 1115 : 
; 1116 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1117 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_DPrintf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1118 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1119 : 
; 1120 : 	if( buffer[0] == '0' && buffer[1] == '\n' && buffer[2] == '\0' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[ecx]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN3@Con_DPrint
	mov	eax, 1
	shl	eax, 0
	movsx	ecx, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN3@Con_DPrint
	mov	eax, 1
	shl	eax, 1
	movsx	ecx, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[eax]
	test	ecx, ecx
	jne	SHORT $LN3@Con_DPrint

; 1121 : 		return; // hlrally spam

	jmp	SHORT $LN1@Con_DPrint
$LN3@Con_DPrint:

; 1122 : 
; 1123 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_DPrintf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_DPrint:

; 1124 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\console.c
;	COMDAT _Con_Reportf
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_Reportf PROC					; COMDAT

; 1133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1134 : 	static char	buffer[MAX_PRINT_MSG];
; 1135 : 	va_list		args;
; 1136 : 
; 1137 : 	if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN2@Con_Report

; 1138 : 		return;

	jmp	SHORT $LN1@Con_Report
$LN2@Con_Report:

; 1139 : 
; 1140 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1141 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_Reportf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1142 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1143 : 
; 1144 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_Reportf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_Report:

; 1145 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Reportf ENDP
_TEXT	ENDS
END
